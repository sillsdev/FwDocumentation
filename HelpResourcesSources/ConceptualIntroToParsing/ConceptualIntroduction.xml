<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="file://%SystemDrive%//Documents and Settings/%USERNAME%/Application Data/XMLmind/XMLEditor/addon/XLingPap/XLingPap1.xsl"?>
<!DOCTYPE lingPaper PUBLIC "-//XMLmind//DTD XLingPap//EN"
"file://%SystemDrive%/Documents and Settings/%USERNAME%/Application Data/XMLmind/XMLEditor/addon/XLingPap/XLingPap.dtd">
<lingPaper
version="1.11.0"
><frontMatter
><title
>A Conceptual Introduction to Morphological Parsing<br
></br
>for Stage 1 of the<br
></br
><object
type="WordWorks"
></object
></title
><shortTitle
>Parsing Conceptual Introduction</shortTitle
><author
>H. Andrew Black<endnote
id="nJonathanCoombs"
><p
>Thanks to Jonathan Coombs (personal communication, email of May 30, 2012) for reviewing a version of this document and making many suggestions for improving it.</p
></endnote
></author
><date
>12-April-2018</date
><contents
showLevel="5"
></contents
></frontMatter
><section1
id="sIntro"
><secTitle
>Introduction</secTitle
><p
>Morphology is the study of word forms. Morphological parsers are computational tools that automatically produce a morphological analysis for a given word form. Such tools have proven to be quite useful as spelling checkers, as morphological grammar checkers, in producing interlinear text and in adaptation of a text from one related language to another. This document is designed to help the reader do morphological parsing using the approach allowed by <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of the <object
type="WordWorks"
></object
> parser. We also introduce issues related to the new <object
type="HermitCrab"
></object
>, where appropriate.</p
><p
>The purpose of this documentation is to provide an introduction to the key concepts and notions in the <object
type="WordWorks"
></object
> approach to morphological parsing. It is divided into two main sections: <indexedItem
term="iMorphotactics"
></indexedItem
>morphotactics and <indexedItem
term="iMorphophonemics"
></indexedItem
>morphophonemics. The first has to do with controlling which morphemes can co-occur with which other morphemes within a well-formed word. The second has to do with controlling the phonological shape of individual morphemes. (There are two other main sections; one deals with some issues related to lexical entries and the other to special considerations related to using compound rules.)</p
><p
>Please note that the mechanisms described here are the ones available for Stage 1, the first, rather simple-minded (linguistically-speaking) instantiation of <object
type="WordWorks"
></object
>. Later stages will provide much more power and capabilities.<endnote
id="nStages"
><p
>See Appendix <appendixRef
app="aStages"
></appendixRef
> for the basic features of each stage.</p
></endnote
> The main reason why we have stages in the <object
type="WordWorks"
></object
> development project is to avoid trying to develop tools with all the user interface challenges all in one fell swoop. Doing that would be quite a daunting task and take a long time before any product could be released. Instead, we are staging the development to handle the basic items first. Then we'll add more and more as we go along.</p
><p
><indexedItem
term="iPhonologicalRules"
></indexedItem
>As mentioned above, this document also introduces the new <object
type="HermitCrab"
></object
> that you can try in addition to the default parser that has been available since day one of <object
type="WordWorks"
></object
>. The default parser is still the one that is documented here and is robust as far as we know. The new <object
type="HermitCrab"
></object
>,<endnote
id="nHermitCrab"
><p
>This new parser is an enhanced and updated version of Mike Maxwell's <indexedItem
term="iHermitCrabParser"
></indexedItem
>Hermit Crab parser. See <link
href="http://www.sil.org/computing/HermitCrab/"
>http://www.sil.org/computing/HermitCrab/</link
>. We are deeply indebted to Mike for his pioneering work on this parser.</p
></endnote
> on the other hand, has yet to be thoroughly tested. So while our initial testing was encouraging, it may well have bugs and may not work as intended. <indexedItem
term="iPhonRuleTryParser"
></indexedItem
>If you choose to try it (and we would love to have you try it), we suggest you do so either on a copy of your main language project or on a small test language project. Please do report to us anything that you notice about this new parser that may help us make it be more effective. See appendix <appendixRef
app="aHermitCrab"
></appendixRef
> for more on this new parser, as well as the <genericRef
gref="gHermitCrabInIndex"
>subject index</genericRef
>.</p
><section2
id="sKeyIssues"
><secTitle
>Key Issues</secTitle
><p
>We begin by addressing some of the key issues that any general morphological parser must face. Before we can tell the computer what to do, we need to understand what is going on linguistically. What kinds of language phenomena must such a computational tool be able to handle if it will indeed be a general tool?</p
><section3
id="sIssueInflection"
><secTitle
>Inflection</secTitle
><p
>Many, if not most, languages <indexedItem
term="iInflection"
></indexedItem
>inflect verbs and/or nouns. Consider the nominal <indexedItem
term="iOrizabaNahuatl"
></indexedItem
>Orizaba Nahuatl forms shown in <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlNominalInflection"
></exampleRef
> and the verbal ones shown in <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlVerbalInflection"
></exampleRef
>.<endnote
id="nNahuatl"
><p
>Data are from <citation
author="yes"
ref="rTuggyCurso"
></citation
>. The abbreviations used in the <indexedItem
term="iOrizabaNahuatl"
></indexedItem
>Nahuatl data are:</p
><table
border="1"
type="LessSpaceBeforeTable"
><tr
><th
align="left"
valign="top"
>Abbreviation</th
><th
align="left"
valign="top"
>Meaning</th
></tr
><tr
><td
align="left"
valign="top"
>1SgPoss</td
><td
align="left"
valign="top"
>1st person singular possessive</td
></tr
><tr
><td
align="left"
valign="top"
>2SgPoss</td
><td
align="left"
valign="top"
>2nd person singular possessive</td
></tr
><tr
><td
align="left"
valign="top"
>3SgPoss</td
><td
align="left"
valign="top"
>3rd person singular possessive</td
></tr
><tr
><td
align="left"
valign="top"
>1PlPoss</td
><td
align="left"
valign="top"
>1st person plural possessive</td
></tr
><tr
><td
align="left"
valign="top"
>2PlPoss</td
><td
align="left"
valign="top"
>2nd person plural possessive</td
></tr
><tr
><td
align="left"
valign="top"
>3PlPoss</td
><td
align="left"
valign="top"
>3rd person plural possessive</td
></tr
><tr
><td
align="left"
valign="top"
>PlPoss</td
><td
align="left"
valign="top"
>plural possessive</td
></tr
><tr
><td
align="left"
valign="top"
>1SgSubj</td
><td
align="left"
valign="top"
>1st person singular subject</td
></tr
><tr
><td
align="left"
valign="top"
>2SgSubj</td
><td
align="left"
valign="top"
>2nd person singular subject</td
></tr
><tr
><td
align="left"
valign="top"
>3SgSubj</td
><td
align="left"
valign="top"
>3rd person singular subject</td
></tr
><tr
><td
align="left"
valign="top"
>1PlSubj</td
><td
align="left"
valign="top"
>1st person plural subject</td
></tr
><tr
><td
align="left"
valign="top"
>2PlSubj</td
><td
align="left"
valign="top"
>2nd person plural subject</td
></tr
><tr
><td
align="left"
valign="top"
>3PlSubj</td
><td
align="left"
valign="top"
>3rd person plural subject</td
></tr
><tr
><td
align="left"
valign="top"
>ImpfvPl</td
><td
align="left"
valign="top"
>plural imperfective</td
></tr
></table
></endnote
></p
><example
num="xNahuatlNominalInflection"
><table
cellpadding="0pt"
cellspacing="0pt"
><tr
><td
align="left"
valign="top"
><table
border="1"
cellpadding="0pt"
cellspacing="0pt"
><tr
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>nokal</langData
></line
><line
><langData
lang="lNahuatl"
>no-kal</langData
></line
><line
><gloss
lang="lGloss"
>1SgPoss-house</gloss
></line
></lineGroup
><free
>‘my house’</free
></interlinear
></td
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>mokal</langData
></line
><line
><langData
lang="lNahuatl"
>mo-kal</langData
></line
><line
><gloss
lang="lGloss"
>2SgPoss-house</gloss
></line
></lineGroup
><free
>‘your(sg) house’</free
></interlinear
></td
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>ikal</langData
></line
><line
><langData
lang="lNahuatl"
>i-kal</langData
></line
><line
><gloss
lang="lGloss"
>3SgPoss-house</gloss
></line
></lineGroup
><free
>‘his/her/its house’</free
></interlinear
></td
></tr
><tr
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>tokal</langData
></line
><line
><langData
lang="lNahuatl"
>to-kal</langData
></line
><line
><gloss
lang="lGloss"
>1PlPoss-house</gloss
></line
></lineGroup
><free
>‘our house’</free
></interlinear
></td
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>amokal</langData
></line
><line
><langData
lang="lNahuatl"
>amo-kal</langData
></line
><line
><gloss
lang="lGloss"
>2PlPoss-house</gloss
></line
></lineGroup
><free
>‘your(pl) house’</free
></interlinear
></td
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>inkal</langData
></line
><line
><langData
lang="lNahuatl"
>in-kal</langData
></line
><line
><gloss
lang="lGloss"
>3PlPoss-house</gloss
></line
></lineGroup
><free
>‘their house’</free
></interlinear
></td
></tr
></table
></td
></tr
><tr
><td
align="left"
valign="top"
> </td
></tr
><tr
><td
align="left"
valign="top"
><table
border="1"
cellpadding="0pt"
cellspacing="0pt"
><tr
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>nokalvan</langData
></line
><line
><langData
lang="lNahuatl"
>no-kal-van</langData
></line
><line
><gloss
lang="lGloss"
>1SgPoss-house-PlPoss</gloss
></line
></lineGroup
><free
>‘my houses’</free
></interlinear
></td
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>mokalvan</langData
></line
><line
><langData
lang="lNahuatl"
>mo-kal-van</langData
></line
><line
><gloss
lang="lGloss"
>2SgPoss-house-PlPoss</gloss
></line
></lineGroup
><free
>‘your(sg) houses’</free
></interlinear
></td
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>ikalvan</langData
></line
><line
><langData
lang="lNahuatl"
>i-kal-van</langData
></line
><line
><gloss
lang="lGloss"
>3SgPoss-house-PlPoss</gloss
></line
></lineGroup
><free
>‘his/her/its houses’</free
></interlinear
></td
></tr
><tr
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>tokalvan</langData
></line
><line
><langData
lang="lNahuatl"
>to-kal-van</langData
></line
><line
><gloss
lang="lGloss"
>1PlPoss-house-PlPoss</gloss
></line
></lineGroup
><free
>‘our houses’</free
></interlinear
></td
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>amokalvan</langData
></line
><line
><langData
lang="lNahuatl"
>amo-kal-van</langData
></line
><line
><gloss
lang="lGloss"
>2PlPoss-house-PlPoss</gloss
></line
></lineGroup
><free
>‘your(pl) houses’</free
></interlinear
></td
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>inkalvan</langData
></line
><line
><langData
lang="lNahuatl"
>in-kal-van</langData
></line
><line
><gloss
lang="lGloss"
>3PlPoss-house-PlPoss</gloss
></line
></lineGroup
><free
>‘their houses’</free
></interlinear
></td
></tr
></table
></td
></tr
></table
></example
><example
num="xNahuatlVerbalInflection"
><table
border="1"
cellpadding="0"
cellspacing="0"
><tr
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>nimiki</langData
></line
><line
><langData
lang="lNahuatl"
>ni-miki</langData
></line
><line
><gloss
lang="lGloss"
>1SgSubj-to.die</gloss
></line
></lineGroup
><free
>‘I die’</free
></interlinear
></td
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>timiki</langData
></line
><line
><langData
lang="lNahuatl"
>ti-miki</langData
></line
><line
><gloss
lang="lGloss"
>2SgSubj-to.die</gloss
></line
></lineGroup
><free
>‘you(sg) die’</free
></interlinear
></td
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>miki</langData
></line
><line
><langData
lang="lNahuatl"
>0-miki</langData
></line
><line
><gloss
lang="lGloss"
>3SgSubj-to.die</gloss
></line
></lineGroup
><free
>‘he/she/it dies’</free
></interlinear
></td
></tr
><tr
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>timikih</langData
></line
><line
><langData
lang="lNahuatl"
>ti-miki-h</langData
></line
><line
><gloss
lang="lGloss"
>1PlSubj-to.die-ImpfvPl</gloss
></line
></lineGroup
><free
>‘we die’</free
></interlinear
></td
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>anmikih</langData
></line
><line
><langData
lang="lNahuatl"
>an-miki-h</langData
></line
><line
><gloss
lang="lGloss"
>2PlSubj-to.die-ImpfvPl</gloss
></line
></lineGroup
><free
>‘you(pl) die’</free
></interlinear
></td
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>mikih</langData
></line
><line
><langData
lang="lNahuatl"
>0-miki-h</langData
></line
><line
><gloss
lang="lGloss"
>3PlSubj-to.die-ImpfvPl</gloss
></line
></lineGroup
><free
>‘they die’</free
></interlinear
></td
></tr
></table
></example
><p
>Notice how each possessed noun in <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlNominalInflection"
></exampleRef
> has at least a possessor prefix. Certain nouns require this possessor inflection. Similarly the verbs in <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlVerbalInflection"
></exampleRef
> require subject markers (with the possible exception of 3rd person). A morphological parser must account for such inflectional items.</p
></section3
><section3
id="sIssueDerivation"
><secTitle
>Derivation</secTitle
><p
><indexedItem
term="iDerivation"
></indexedItem
>Consider the <indexedItem
term="iEnglish"
></indexedItem
>English forms<endnote
id="nEnglishDerivation"
><p
>These are taken from <citation
author="yes"
page="9"
ref="rSpencer1991"
></citation
>.</p
></endnote
> in <exampleRef
equal="no"
letterOnly="no"
num="xEnglishDerivation"
></exampleRef
>. What is happening here? How do you get a dumb computer to “understand” these forms correctly?</p
><example
num="xEnglishDerivation"
><listWord
letter="xEnglishDerivationInstitute"
><langData
lang="lEng"
>institute</langData
></listWord
><listWord
letter="xEnglishDerivationInstitution"
><langData
lang="lEng"
>institution</langData
></listWord
><listWord
letter="xEnglishDerivationInstitutional"
><langData
lang="lEng"
>institutional</langData
></listWord
><listWord
letter="xEnglishDerivationInstitutionalize"
><langData
lang="lEng"
>institutionalize</langData
></listWord
><listWord
letter="xEnglishDerivationInstitutionalization"
><langData
lang="lEng"
>institutionalization</langData
></listWord
><listWord
letter="xEnglishDerivationInstitutionalizational"
><langData
lang="lEng"
>institutionalizational</langData
></listWord
><listWord
letter="xEnglishDerivationInstitutionalizationally"
><langData
lang="lEng"
>institutionalizationally</langData
></listWord
></example
><p
>In <exampleRef
equal="no"
letter="xEnglishDerivationInstitute"
letterOnly="no"
></exampleRef
> <langData
lang="lEng"
>institute</langData
> is a verb root (e.g. <langData
lang="lEng"
>We need to institute some changes around here.</langData
>). By adding the suffix ‑<langData
lang="lEng"
>ion</langData
> as in <exampleRef
equal="no"
letter="xEnglishDerivationInstitution"
letterOnly="no"
></exampleRef
>, the word is <indexedItem
term="iCategoryChanging"
></indexedItem
>changed to a noun. The suffix ‑<langData
lang="lEng"
>al</langData
> can be added to a noun stem to change it to an adjective, as in <exampleRef
equal="no"
letter="xEnglishDerivationInstitutional"
letterOnly="no"
></exampleRef
>. The suffix ‑<langData
lang="lEng"
>ize</langData
> changes an adjective into a verb <exampleRef
equal="no"
letter="xEnglishDerivationInstitutionalize"
letterOnly="no"
></exampleRef
>. Further category changes occur with the addition of each suffix in <exampleRef
equal="no"
letter="xEnglishDerivationInstitutionalization"
letterOnly="no"
paren="initial"
></exampleRef
>-<exampleRef
equal="no"
letter="xEnglishDerivationInstitutionalizationally"
letterOnly="yes"
paren="final"
></exampleRef
>. From this English example, we have seen that the computer needs to be able to distinguish between roots and suffixes, with each one restricted as to what category it attaches to and what category it changes the stem to. (Note, for example, that the suffix ‑<langData
lang="lEng"
>ly</langData
> cannot be added to either a verb stem or a noun stem: *<langData
lang="lEng"
>institutely</langData
>, *<langData
lang="lEng"
>institutionly</langData
>.)</p
><p
>A <indexedItem
term="iHuallagaQuechua"
></indexedItem
>Huallaga Quechua example showing similar category changes along with various types of verbal and nominal affixes is given in <exampleRef
equal="no"
letterOnly="no"
num="xQuechua"
></exampleRef
>. The verb root meaning ‘to see’ has the imperfective aspect marker added, followed by the first person object marker, yielding ‘to see me.’ The addition of the nominalizer changes the form to a noun meaning ‘seeing me.’ The noun form can now be possessed by the second person possessive marker and then the purpose marker may optionally follow, finally giving ‘in order that you might be seeing me.’<endnote
id="nQuechua"
><p
><indexedItem
term="iHuallagaQuechua"
></indexedItem
>The data are from <citation
author="yes"
page="8"
ref="rAMPLEBook"
></citation
>. See also <citation
author="yes"
ref="rHuallagaQuechuaGrammar"
></citation
>. The abbreviations used in the Quechua form are:</p
><table
border="1"
type="LessSpaceBeforeTable"
><tr
><th
align="left"
valign="top"
>Abbreviation</th
><th
align="left"
valign="top"
>Meaning</th
></tr
><tr
><td
align="left"
valign="top"
>Imp</td
><td
align="left"
valign="top"
>imperfective aspect</td
></tr
><tr
><td
align="left"
valign="top"
>1Obj</td
><td
align="left"
valign="top"
>first person object marker</td
></tr
><tr
><td
align="left"
valign="top"
>2Pos</td
><td
align="left"
valign="top"
>second person possessor</td
></tr
><tr
><td
align="left"
valign="top"
>Nom</td
><td
align="left"
valign="top"
>nominalizer</td
></tr
><tr
><td
align="left"
valign="top"
>Pur</td
><td
align="left"
valign="top"
>action for or with a purpose (a case-like marker; see <citation
author="yes"
page="56"
ref="rHuallagaQuechuaGrammar"
></citation
>)</td
></tr
></table
></endnote
></p
><example
num="xQuechua"
><interlinear
><lineGroup
><line
><langData
lang="lQuechua"
>rikaykaamaanaykipaq</langData
></line
><line
><langData
lang="lQuechua"
>rika-yka:-ma:-na-yki-paq</langData
></line
><line
><gloss
lang="lGloss"
>to.see-Imp-1Obj-Nom-2Pos-Pur</gloss
></line
></lineGroup
><free
>‘in order that you might be seeing me’</free
></interlinear
></example
><p
>A morphological parser must account for such derivational items.</p
></section3
><section3
id="sIssueAmbiguity"
><secTitle
>Ambiguity</secTitle
><p
><indexedItem
term="iAmbiguity"
></indexedItem
>Ambiguity is also apparent in <exampleRef
equal="no"
letter="xEnglishDerivationInstitute"
letterOnly="no"
></exampleRef
>, since <langData
lang="lEng"
>institute</langData
> can be either a verb, as above, or a noun, as in <langData
lang="lEng"
>Australian <object
type="InFocus"
>Institute</object
> of Marine and Power Engineers</langData
>. Note that there are different types of ambiguity in natural language as well. For example, the word <langData
lang="lEng"
>bank</langData
> (among other things) can mean either the side of a river or a building that holds money. With either meaning, <langData
lang="lEng"
>bank</langData
> is a noun.</p
><p
>Now consider the following word:</p
><example
num="xAmbiguity"
><listInterlinear
letter="xAmbiguityCookN"
><lineGroup
><line
><langData
lang="lEng"
>cooks</langData
></line
><line
><langData
lang="lEng"
>cook-s</langData
></line
><line
><gloss
lang="lGloss"
>person.who.prepares.food-PL</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xAmbiguityCookV"
><lineGroup
><line
><langData
lang="lEng"
>cooks</langData
></line
><line
><langData
lang="lEng"
>cook-s</langData
></line
><line
><gloss
lang="lGloss"
>to.prepare.food-3SgPres</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>Note that <langData
lang="lEng"
>cooks</langData
> is ambiguous not only in the root meaning but also as to the suffix: the <langData
lang="lEng"
>-s</langData
> is a nominal plural morpheme in <exampleRef
equal="no"
letter="xAmbiguityCookN"
letterOnly="no"
></exampleRef
> but a verbal third person singular present tense morpheme in <exampleRef
equal="no"
letter="xAmbiguityCookV"
letterOnly="no"
></exampleRef
>.</p
><p
>A morphological parser must be able to deal with the fact that individual words can legitimately be ambiguous. That is, a morphological parser must be able to discover and report all possible analyses of a word form. In many cases, the ambiguity is eliminated when the word is seen in context, so ideally a morphological parser is used in the context of computational tools that look beyond a single word.</p
></section3
><section3
id="sIssueEpenthesis"
><secTitle
>Epenthesis</secTitle
><p
><indexedItem
term="iEpenthesis"
></indexedItem
>There are still other types of challenges for morphological parsing. For example, consider the <indexedItem
term="iCaquinte"
></indexedItem
>Caquinte word in <exampleRef
equal="no"
letterOnly="no"
num="xEpenthesis"
></exampleRef
>:<endnote
id="nEpenthesis"
><p
>All <indexedItem
term="iCaquinte"
></indexedItem
>Caquinte data are from Ken Swift, p.c. and <citation
author="yes"
ref="rSwift"
></citation
>. The abbreviations used in the Caquinte forms are:</p
><table
border="1"
type="LessSpaceBeforeTable"
><tr
><th
align="left"
valign="top"
>Abbreviation</th
><th
align="left"
valign="top"
>Meaning</th
></tr
><tr
><td
align="left"
valign="top"
>3M</td
><td
align="left"
valign="top"
>third person masculine subject</td
></tr
><tr
><td
align="left"
valign="top"
>3FO</td
><td
align="left"
valign="top"
>third person feminine object</td
></tr
><tr
><td
align="left"
valign="top"
>DAT</td
><td
align="left"
valign="top"
>dative</td
></tr
><tr
><td
align="left"
valign="top"
>F</td
><td
align="left"
valign="top"
>future suffix</td
></tr
><tr
><td
align="left"
valign="top"
>FUT</td
><td
align="left"
valign="top"
>future prefix</td
></tr
><tr
><td
align="left"
valign="top"
>FOC</td
><td
align="left"
valign="top"
>focus</td
></tr
><tr
><td
align="left"
valign="top"
>NEG</td
><td
align="left"
valign="top"
>negative</td
></tr
><tr
><td
align="left"
valign="top"
>NF</td
><td
align="left"
valign="top"
>non-future suffix</td
></tr
><tr
><td
align="left"
valign="top"
>PAS</td
><td
align="left"
valign="top"
>pseudo-passive</td
></tr
><tr
><td
align="left"
valign="top"
>PROG</td
><td
align="left"
valign="top"
>progressive</td
></tr
></table
></endnote
></p
><example
num="xEpenthesis"
><interlinear
><lineGroup
><line
><langData
lang="lCaquinte"
>itsavetakohitiro</langData
></line
><line
><langData
lang="lCaquinte"
>i-tsave-(t)-ako-hi-(t)-i-ro</langData
></line
><line
><gloss
lang="lGloss"
>3M-tell- -DAT-PAS- -NF-3FO</gloss
></line
></lineGroup
><free
>‘she is told about’</free
></interlinear
></example
><p
>The <langData
lang="lCaquinte"
>(t)</langData
> in two places on the second line (which shows the word broken into morphemes) are not really morphemes at all. Instead, they are epenthetic consonants added to serve as onsets to <indexedItem
term="iSyllable"
></indexedItem
>syllables. Caquinte does not allow vowel clusters nor syllables without onsets (in this part of the verb), so whenever two vowels come together at a morpheme break, an epenthetic <langData
lang="lCaquinte"
>t</langData
> is inserted. A morphological parser needs to be able to correctly account for forms that include epenthetic segments inserted to preserve syllable structure.</p
></section3
><section3
id="sIssueDiscontinuousMorphemes"
><secTitle
>Discontinuous Morphemes</secTitle
><p
>Now consider the <indexedItem
term="iCaquinte"
></indexedItem
>Caquinte form in <exampleRef
equal="no"
letterOnly="no"
num="xCaquinteFuture"
></exampleRef
>, which is the same word as in <exampleRef
equal="no"
letterOnly="no"
num="xEpenthesis"
></exampleRef
>, but changed to future tense:</p
><example
num="xCaquinteFuture"
><interlinear
><lineGroup
><line
><langData
lang="lCaquinte"
>intsavetakohitero</langData
></line
><line
><langData
lang="lCaquinte"
>i-n-tsave-(t)-ako-hi-(t)-e-ro</langData
></line
><line
><gloss
lang="lGloss"
>3M-FUT-tell- -DAT-PAS- -F-3FO</gloss
></line
></lineGroup
><free
>‘she will be told about’</free
></interlinear
></example
><p
>What is the challenge here? The future tense is realized as a <indexedItem
term="iDiscontinuousMorpheme"
></indexedItem
>discontinuous morpheme: it is composed of the prefix <langData
lang="lCaquinte"
>n</langData
>‑ and the suffix ‑<langData
lang="lCaquinte"
>e</langData
>. The computer must be able to check these noncontiguous parts of the word to correctly analyze the future tense in Caquinte; one part cannot be present without the other.</p
></section3
><section3
id="sIssueInfixation"
><secTitle
>Infixation</secTitle
><p
>The <indexedItem
term="iTagalog"
></indexedItem
>Tagalog forms (from <citation
author="yes"
page="12-13"
ref="rSpencer1991"
></citation
>) in <exampleRef
equal="no"
letterOnly="no"
num="xTagalogInfixation"
></exampleRef
> illustrate another challenge:</p
><example
num="xTagalogInfixation"
><listWord
letter="xSulat"
><langData
lang="lTagalog"
>sulat</langData
><gloss
lang="lGloss"
>‘to write or writing (infinitive form)’</gloss
></listWord
><listWord
letter="xSumulat"
><langData
lang="lTagalog"
>sumulat</langData
><gloss
lang="lGloss"
>‘to write (with actor focus)’</gloss
></listWord
><listWord
letter="xSinulat"
><langData
lang="lTagalog"
>sinulat</langData
><gloss
lang="lGloss"
>‘to write (with object focus)’</gloss
></listWord
></example
><p
>What is happening here? This is a case of <indexedItem
term="iInfixation"
></indexedItem
>infixation, where the root <langData
lang="lTagalog"
>sulat</langData
> splits into two parts so that one of the focus morphemes, ‑<langData
lang="lTagalog"
>um</langData
>‑ or ‑<langData
lang="lTagalog"
>in</langData
>‑, can be inserted. A parser must correctly recognize the root even though it is broken apart by the infix.</p
></section3
><section3
id="sIssueReduplication"
><secTitle
>Reduplication</secTitle
><p
><indexedItem
term="iReduplication"
></indexedItem
>Look at the additional <indexedItem
term="iTagalog"
></indexedItem
>Tagalog forms in <exampleRef
equal="no"
letterOnly="no"
num="xTagalogReduplication"
></exampleRef
> to determine how the imperfective aspect is marked:</p
><example
num="xTagalogReduplication"
><listWord
letter="xSusulat"
><langData
lang="lTagalog"
>susulat</langData
><gloss
lang="lGloss"
>‘to write (imperfective)’</gloss
></listWord
><listWord
letter="xMagpasulatt"
><langData
lang="lTagalog"
>magpasulat</langData
><gloss
lang="lGloss"
>‘to make someone write (perfective)’</gloss
></listWord
><listWord
letter="xMagpapasulat"
><langData
lang="lTagalog"
>magpapasulat</langData
><gloss
lang="lGloss"
>‘to make someone write (imperfective)’</gloss
></listWord
></example
><p
>We know from <exampleRef
equal="no"
letter="xSulat"
letterOnly="no"
></exampleRef
> that <langData
lang="lTagalog"
>sulat</langData
> means ‘to write’. So in <exampleRef
equal="no"
letter="xSusulat"
letterOnly="no"
></exampleRef
> it appears that the imperfective marker is <langData
lang="lTagalog"
>su</langData
>, but we cannot tell if it is a prefix or an infix without looking at other forms. In example <exampleRef
equal="no"
letter="xMagpasulatt"
letterOnly="no"
></exampleRef
> the causative ‘to make someone’ is the prefix <langData
lang="lTagalog"
>pa</langData
>‑. The <langData
lang="lTagalog"
>mag</langData
>‑ is what some call the actor focus or actor voice morpheme. But the imperfective of this causative form is not *<langData
lang="lTagalog"
>sumagpasulat</langData
>, *<langData
lang="lTagalog"
>magsupasulat</langData
>, nor *<langData
lang="lTagalog"
>magpasusulat</langData
> as we would expect from either prefixing or infixing <langData
lang="lTagalog"
>su</langData
>. Instead, we have <langData
lang="lTagalog"
>magpapasulat</langData
> in <exampleRef
equal="no"
letter="xMagpapasulat"
letterOnly="no"
></exampleRef
> where it is clear that the marker for imperfective is the extra <langData
lang="lTagalog"
>pa</langData
>. The correct analysis is therefore that imperfective aspect is marked in Tagalog by reduplicating either the first <indexedItem
term="iSyllable"
></indexedItem
>syllable of the stem or the initial consonant and vowel of the first syllable of the stem.</p
><p
>A morphological parser must be able to recognize reduplication within a word form.</p
></section3
><section3
id="sIssueRootAndPatternMorphology"
><secTitle
>Root and Pattern Morphology</secTitle
><p
><indexedItem
term="iRootAndPatternMorphology"
></indexedItem
>Semitic languages pose a special challenge with their root and pattern morphology. These languages have roots composed of three consonants, as exemplified in the <indexedItem
term="iSilti"
></indexedItem
>Silt'i data in <exampleRef
equal="no"
letterOnly="no"
num="xSilti"
></exampleRef
>, where ‘buy’ is the root <langData
lang="lSilti"
>wkb</langData
>. The aspect markers are composed of vowel patterns that fit between or around the root consonants, such as the <langData
lang="lSilti"
>a-a</langData
> vowel pattern indicating the perfective aspect shown in <exampleRef
equal="no"
letterOnly="no"
num="xSilti"
></exampleRef
>. The parser needs to be able to find the root consonants and corresponding vowels of the aspect, even though they are intermingled in the surface form of the word.<endnote
id="nSilti"
><p
>The data are from <citation
author="yes"
ref="rGardner"
></citation
>. The abbreviations used in the <indexedItem
term="iSilti"
></indexedItem
>Silt‘i form are:</p
><table
border="1"
type="LessSpaceBeforeTable"
><tr
><th
align="left"
valign="top"
>Abbreviation</th
><th
align="left"
valign="top"
>Meaning</th
></tr
><tr
><td
align="left"
valign="top"
>Perf</td
><td
align="left"
valign="top"
>perfective aspect</td
></tr
><tr
><td
align="left"
valign="top"
>3rdSgPerf</td
><td
align="left"
valign="top"
>third person singular subject marker in the perfective aspect</td
></tr
></table
></endnote
></p
><example
num="xSilti"
><interlinear
><lineGroup
><line
><langData
lang="lSilti"
>wakaba</langData
></line
><line
><langData
lang="lSilti"
>a-a-wkb-a</langData
></line
><line
><gloss
lang="lGloss"
>Perf-buy-3rdSgPerf</gloss
></line
></lineGroup
><free
>‘he bought’</free
></interlinear
></example
></section3
><section3
id="sIssuesMetathesis"
><secTitle
>Metathesis</secTitle
><p
><indexedItem
term="iMetathesis"
></indexedItem
>Now study the following <indexedItem
term="iCaquinte"
></indexedItem
>Caquinte word.</p
><example
num="xCaquinteMetathesis"
><interlinear
><lineGroup
><line
><wrd
lang="lCaquinte"
>ihikeke<object
type="InFocus"
>ha</object
>i</wrd
></line
><line
><wrd
lang="lCaquinte"
>i-hi-k-e-ke<object
type="InFocus"
>a-h</object
>i</wrd
></line
><line
><wrd
lang="lGloss"
>3M-to.think.mistakenly-PROG-NF-FOC-NEG</wrd
></line
></lineGroup
><free
>‘he thought mistakenly’</free
></interlinear
></example
><p
>What change takes place at the juncture between the final two morphemes? Notice that where one might expect the sequence <langData
lang="lCaquinte"
>ke<object
type="InFocus"
>ah</object
>i</langData
>, what surfaces is <langData
lang="lCaquinte"
>ke<object
type="InFocus"
>ha</object
>i</langData
>, where the <langData
lang="lCaquinte"
>h</langData
> and <langData
lang="lCaquinte"
>a</langData
> switch positions.<endnote
id="nCaquinteMetathesis"
><p
>This metathesis process is actually optional. The word is from <citation
author="yes"
page="133"
ref="rSwift"
></citation
>.</p
></endnote
> Such a transposition of phonemes is called <object
type="Term"
>metathesis</object
>. Furthermore, notice that the metathesis process in <exampleRef
equal="no"
letterOnly="no"
num="xCaquinteMetathesis"
></exampleRef
> crosses morpheme boundaries.</p
><p
>Such data imply that a morphological parser must be able to correctly identify morphemes even when some segments within the morphemes may have switched positions.</p
></section3
><section3
id="sIssuesMorphemeNotSurface"
><secTitle
>Morphemes that May Be Null</secTitle
><p
><indexedItem
term="iNullAllomorph"
></indexedItem
>For a final challenge, consider these <indexedItem
term="iCaquinte"
></indexedItem
>Caquinte forms (you do not need to understand all the morpheme glosses here; just concentrate on the initial subject prefixes):</p
><example
num="xCaquintePrefix"
><listInterlinear
letter="xCaquintePrefixA"
><lineGroup
><line
><wrd
lang="lCaquinte"
><object
type="InFocus"
>a</object
>nehero</wrd
></line
><line
><wrd
lang="lCaquinte"
><object
type="InFocus"
>a</object
>-0-neh-e-ro</wrd
></line
><line
><wrd
lang="lGloss"
><object
type="InFocus"
>1I</object
>-FUT-see-F-3FO</wrd
></line
></lineGroup
><free
>‘we will see her’</free
></listInterlinear
><listInterlinear
letter="xCaquintePrefixO"
><lineGroup
><line
><wrd
lang="lCaquinte"
><object
type="InFocus"
>o</object
>keekake</wrd
></line
><line
><wrd
lang="lCaquinte"
><object
type="InFocus"
>o</object
>-keek-ak-e</wrd
></line
><line
><wrd
lang="lGloss"
><object
type="InFocus"
>3F</object
>-dig-PERF-NF</wrd
></line
></lineGroup
><free
>‘she had dug’</free
></listInterlinear
><listInterlinear
letter="xCaquintePrefix0"
><lineGroup
><line
><wrd
><langData
lang="lCaquinte"
>oasanomahakemparime</langData
></wrd
></line
><line
><wrd
lang="lCaquinte"
><object
type="InFocus"
>0</object
>-0-o-(a)-sano-maha-k-e-Npa-ri-me</wrd
></line
><line
><wrd
lang="lGloss"
><object
type="InFocus"
>1I</object
>-FUT-eat- -VERI.M-VERI-PROG-F-R-3MO-CNTR</wrd
></line
><line
><wrd
lang="lGloss"
><object
type="InFocus"
>3F</object
>-FUT-eat- -VERI.M-VERI-PROG-F-R-3MO-CNTR</wrd
></line
></lineGroup
><free
>‘we/she will not really be eating it’</free
></listInterlinear
></example
><p
>What is the problem with the subject prefixes? In <exampleRef
equal="no"
letter="xCaquintePrefixA"
letterOnly="no"
></exampleRef
> we see that the first person inclusive subject marker is <langData
lang="lCaquinte"
>a</langData
>‑, and in <exampleRef
equal="no"
letter="xCaquintePrefixO"
letterOnly="no"
></exampleRef
> the third person feminine subject marker is <langData
lang="lCaquinte"
>o</langData
>‑. Yet, in <exampleRef
equal="no"
letter="xCaquintePrefix0"
letterOnly="no"
></exampleRef
>, the gloss shows ambiguity between ‘we’ and ‘she’ as the subject, and both of these are represented as null. This is because both subject prefixes are vowels and the stem in <exampleRef
equal="no"
letter="xCaquintePrefix0"
letterOnly="no"
></exampleRef
> is vowel-initial, yielding two vowels together. Recall from <exampleRef
equal="no"
letterOnly="no"
num="xEpenthesis"
></exampleRef
> that Caquinte generally does not allow vowel clusters, and therefore adds an epenthetic ‑<langData
lang="lCaquinte"
>t</langData
>‑ when necessary to avoid such clusters. It turns out that epenthesis is only used in the suffixes. Within the prefixes, the initial vowel of a cluster deletes, causing the ambiguity seen in <exampleRef
equal="no"
letter="xCaquintePrefix0"
letterOnly="no"
></exampleRef
>.</p
><p
>This means that a morphological parser must be able to identify a morpheme even when the morpheme has no overt segments.</p
></section3
></section2
><section2
id="sTasksForMorphParser"
><secTitle
>Tasks for any Morphological Parser</secTitle
><p
><indexedItem
term="iMorphologicalParser"
></indexedItem
>Given the challenges of morphological parsing exemplified in the preceding section, how can a computer program go about analyzing words into their constituent morphemes? Let's say that the task of a morphological parser is to take a form like <langData
lang="lCaquinte"
>itsavetacojitiro</langData
> from <exampleRef
equal="no"
letterOnly="no"
num="xEpenthesis"
></exampleRef
> above and</p
><ul
><li
>see if it is a legitimate word,</li
><li
>give an indication of which characters correspond to what morpheme, and</li
><li
>produce an ordered list of its constituent morphemes (give glosses).<endnote
id="nProduceTree"
><p
>Another thing a parser could produce would be the actual word structure which could be shown via a tree diagram. <indexedItem
term="iStage1"
></indexedItem
>While the <object
type="WordWorks"
></object
> parser actually produces such a structure, we do not plan to make it visible in Stage 1.</p
></endnote
></li
></ul
><p
>What are some of the things our parser is going to have to know and what are some of the things that it is going to have to do?</p
><p
>Things the parser needs to KNOW:</p
><ul
><li
>the forms and glosses of prefixes, infixes, roots, and suffixes,</li
><li
>which of the affixes go with which roots,</li
><li
>the relative ordering of the affixes, and</li
><li
>when a particular shape of a form is legitimate and when it is not (allomorphy/phonology).</li
></ul
><p
>Things the parser needs to DO:</p
><ul
><li
>find the affixes and root(s) in a given word, and</li
><li
>check to see whether each affix can go with the rest of the word (that is, apply a set of constraints)</li
></ul
><p
>Clearly, properly using and controlling the constraints is the major task in implementing a parser for a given language. Since a morphological parser must model linguistic reality, it is a good idea to use constraints that model appropriate linguistic notions. Two major concepts for morphology are morphotactics and morphophonemics. <indexedItem
term="iMorphotactics"
></indexedItem
>Morphotactics deal with what morphemes can co-occur with what other morphemes. <indexedItem
term="iMorphophonemics"
></indexedItem
>Morphophonemics deal with what shape a given morpheme will have in various phonological and morphological environments. The next two major sections outline the constraints available with the <indexedItem
term="iStage1"
></indexedItem
>Stage 1 <object
type="WordWorks"
></object
> parser and how to use them.</p
></section2
></section1
><section1
id="sMorphotactics"
><secTitle
>Morphotactics</secTitle
><p
><indexedRangeBegin
id="bMorphotactics"
main="yes"
term="iMorphotactics"
></indexedRangeBegin
>Morphotactics has to do with controlling the order of the morphemes in a well-formed word and controlling which morphemes can co-occur with which other morphemes. As examples of the former, one would not expect to find a prefix at the end of a word or a suffix at the beginning of a word. As an example of the latter, while one would expect a tense affix to appear with a verb root in a verbal word, one would not expect a tense affix to show up on a pronoun. The morphotactic mechanisms described in this section delineate what one can do within the <object
type="WordWorks"
></object
> model to control such things. The idea is to use the morphotactic mechanisms to correctly describe the facts of the language and thereby not only provide correct parses, but also rule out false parses.</p
><p
>By the way, correctly describing the facts of the language also provides the basis for a grammatical description, something that <object
type="WordWorks"
></object
> provides. By making a correct description of the facts we can both generate a description that people can read to learn about the language and we can feed the information to a parser that can put our description to work checking spellings, adapting to other languages, and verifying the fit of our description.</p
><p
>Note that for words which consist solely of a single morpheme, there are no special morphotactic considerations. One merely adds appropriate lexical entries for these and ensures that the morpheme type of the allomorph(s)<endnote
id="nAllomorphVsForm"
><p
>We use the term “allomorph” here as a cover term for any form in a lexical entry.</p
></endnote
> in the entry is(are) set to a root or stem type.</p
><p
>This section has four major sub-sections. The first deals with handling affixation to stems (section <sectionRef
sec="sAffixation"
></sectionRef
>). The second deals with stem compounding (section <sectionRef
sec="sCompounding"
></sectionRef
>). The third discusses issues related to clitics (section <sectionRef
sec="sClitics"
></sectionRef
>). The fourth is for those cases where the parser is producing parses that are incorrect, but the <indexedItem
term="iStage1"
></indexedItem
>Stage 1 mechanisms do not allow any other way to eliminate the false parses (section <sectionRef
sec="sAdhocMorphProhibitions"
></sectionRef
>).</p
><section2
id="sAffixation"
><secTitle
>Affixation</secTitle
><p
><indexedRangeBegin
id="bAffixes"
term="iAffixes"
></indexedRangeBegin
>This section discusses issues relating to adding affixes to stems. Linguists typically divide affixes into two major categories: <indexedItem
term="iInflectionalAffix"
></indexedItem
>inflectional and <indexedItem
term="iDerivationalAffix"
></indexedItem
>derivational. Therefore, <object
type="WordWorks"
></object
> allows you to declare a given affix as being either inflectional or derivational. In the process of analyzing a language, however, sometimes one does not yet know whether a given affix is inflectional or derivational. There are certain affixes which are truly difficult to classify in this fashion. For this reason, <object
type="WordWorks"
></object
> also allows you to label a given affix as being <indexedItem
term="iAffixUnclassified"
></indexedItem
>unclassified with respect to inflection and derivation. As you study the language more, you should eventually figure out whether such affixes are inflectional or derivational and then you can change their status from being unclassified to the appropriate one.</p
><section3
id="sUnclassifiedAffixes"
><secTitle
>Unclassified Affixes</secTitle
><p
><indexedItem
term="iAffixUnclassified"
></indexedItem
>You can label an affix as “unclassified” when you do not know if it is derivational or inflectional. Please understand, though, that when you do this, the affix is relatively unconstrained as to where it can appear. As a result, the <object
type="WordWorks"
></object
> parser may return a number of incorrect parses for some word forms which happen to contain a sequence of characters that match one or more allomorphs of an unclassified affix. One partial solution to this is to indicate the category of the stem to which the affix may attach. The best solution, of course, is to classify the affix as being either inflectional or derivational<endnote
id="nUnderspecifiedInflDevAffixes"
><p
>Note that it is possible to classify an affix as being inflectional or derivational, but still not fully specify the required information. Such partially specified <indexedItem
term="iInflAffixUnderspecified"
></indexedItem
>inflectional and <indexedItem
term="iDerivAffixUnderspecified"
></indexedItem
>derivational affixes are effectively treated as “<indexedItem
term="iAffixUnclassified"
></indexedItem
>unclassified” affixes by the <object
type="WordWorks"
></object
> parser. See sections <sectionRef
sec="sInflAffixUnderspecified"
></sectionRef
> and <sectionRef
sec="sDervAffixUnderspecified"
></sectionRef
>.</p
></endnote
> so it will only show up where it should. See section <sectionRef
sec="sDerivationVsInflection"
></sectionRef
> for more on how to determine if an affix is derivational or inflectional.</p
></section3
><section3
id="sInflectionalAffixes"
><secTitle
>Inflectional Affixes</secTitle
><p
><indexedRangeBegin
id="bInflectionalAffix"
main="yes"
term="iInflectionalAffix"
></indexedRangeBegin
>Inflectional affixes typically reflect what some call “grammatical meaning.” These are things like person, number, case, gender, tense, aspect, etc. One can also typically create a paradigm of word forms with the various inflectional categories as labels on the chart.<endnote
id="nInflectionalAffix"
><p
>For more on this, see <citation
author="yes"
page="113ff"
ref="rBickford"
></citation
>.</p
></endnote
></p
><section4
id="sInflAffixSimpleExample"
><secTitle
>Simple Example</secTitle
><p
>For example, consider the information for a possessed noun in <indexedRangeBegin
id="bOrizabaInflection"
term="iOrizabaNahuatl"
></indexedRangeBegin
>Orizaba Nahuatl given in <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlNominalInflection"
></exampleRef
> above, but this time displayed in a different fashion:</p
><example
num="xNahuatlNominalPossSingluar"
><table
border="1"
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>house</gloss
></td
><td
align="left"
valign="top"
>singular possessed noun</td
></tr
><tr
><td
align="left"
valign="top"
>1st Person Singular Possessive</td
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>nokal</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>2nd Person Singular Possessive</td
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>mokal</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>3rd Person Singular Possessive</td
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>ikal</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>1st Person Plural Possessive</td
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>tokal</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>2nd Person Plural Possessive</td
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>amokal</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>3rd Person Plural Possessive</td
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>inkal</langData
></td
></tr
></table
></example
><p
>What are the inflectional affixes here? Given that every form has the sequence <langData
lang="lNahuatl"
>kal</langData
>, it appears that there are six possessor prefixes which occur before the noun stem. Similar paradigms for other singular possessed nouns would show the same situation (ignoring any morphophonology). Therefore we could posit that the singular possessed noun has an inflectional template that consists of a possessor prefix followed by the stem. We could diagram this as in <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlPossessedSingularNounTemplate"
></exampleRef
>.</p
><example
num="xNahuatlPossessedSingularNounTemplate"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Possessor</th
><th
align="left"
valign="top"
>Stem</th
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>no</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘1SgPoss’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>mo</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘2SgPoss’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>i</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘3SgPoss’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>to</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘1PlPoss’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>amo</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘2PlPoss’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>in</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘3PlPoss’</gloss
></td
></tr
></table
></td
><td
> </td
></tr
></table
></example
><p
>Now consider the plural possessed noun data from <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlNominalInflection"
></exampleRef
> above, but displayed in a similar fashion to <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlNominalPossSingluar"
></exampleRef
>.</p
><example
num="xNahuatlNominalPossPlural"
><table
border="1"
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>house</gloss
></td
><td
align="left"
valign="top"
>plural possessed noun</td
></tr
><tr
><td
align="left"
valign="top"
>1st Person Singular Possessive</td
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>nokalvan</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>2nd Person Singular Possessive</td
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>mokalvan</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>3rd Person Singular Possessive</td
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>ikalvan</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>1st Person Plural Possessive</td
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>tokalvan</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>2nd Person Plural Possessive</td
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>amokalvan</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>3rd Person Plural Possessive</td
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>inkalvan</langData
></td
></tr
></table
></example
><p
>What are the inflectional affixes here? Notice that there is the same stem (<langData
lang="lNahuatl"
>kal</langData
>) and the same set of six possessor prefixes as in <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlNominalPossSingluar"
></exampleRef
>. In addition, there is a plural suffix ‑<langData
lang="lNahuatl"
>van</langData
>. Similar paradigms for other plural possessed nouns would show the same situation (ignoring any morphophonology). <indexedRangeBegin
id="bInflectionalTemplate"
main="yes"
term="iInflectionalTemplate"
></indexedRangeBegin
>Therefore we could posit that the plural possessed noun has an inflectional template that consists of a possessor prefix followed by the stem which, in turn, is followed by a plural suffix. Since plural is an instance of the notion of number, we could diagram this as an inflectional template as shown in <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlPossessedPluralNounTemplate"
></exampleRef
>.</p
><example
num="xNahuatlPossessedPluralNounTemplate"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Possessor</th
><th
align="left"
valign="top"
>Stem</th
><th
align="left"
valign="top"
>Number</th
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>no</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘1SgPoss’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>mo</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘2SgPoss’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>i</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘3SgPoss’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>to</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘1PlPoss’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>amo</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘2PlPoss’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>in</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘3PlPoss’</gloss
></td
></tr
></table
></td
><td
> </td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>‑van</langData
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘Plural’</gloss
></td
></tr
></table
></td
></tr
></table
></example
><p
>Notice what we have described here: for a particular category (possessed noun), <indexedRangeBegin
id="bInflectionalSlot"
main="yes"
term="iInflectionalSlot"
></indexedRangeBegin
>we have an inflectional template with one prefix slot (for possessor) and one suffix slot (for number). The possessor slot can be filled by any of the inflectional prefixes listed in <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlNominalPossSingluar"
></exampleRef
>. The number slot can be filled by the plural suffix.</p
><p
>Be aware that if you define a template that has no slots, then the parser will ignore that template. A template must have slots for the parser to use it. Similarly, if a slot has no affixes in it, that slot will also be ignored.</p
></section4
><section4
id="sInflAffixOptionalSlots"
><secTitle
>Optional Affix Slots</secTitle
><p
><indexedItem
term="iInflSlotOptional"
></indexedItem
>Now you may well have noticed that there is a potential problem here with the template in <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlPossessedPluralNounTemplate"
></exampleRef
>. If we treat each slot in the template as being obligatory, then the template says we must have a number suffix in order for the template to be satisfied. This means that a possessed singular noun will not meet the requirements of this template because it does not have a suffix in the number slot. It turns out that <object
type="WordWorks"
></object
> actually does treat each slot as being obligatory unless it is overtly marked as being optional.</p
><p
>What can we do about this? There are at least three options available within the <object
type="WordWorks"
></object
> approach:</p
><ol
><li
>Treat the Number slot as being optional so that for the singular case, there would not be any suffix in the Number slot.</li
><li
>Create two distinct templates for the possessed noun category: one for singular and one for plural.</li
><li
><indexedItem
term="iNullAllomorph"
></indexedItem
>Create a null singular number suffix which could then satisfy the requirement of something being in the Number slot.</li
></ol
><p
>Which of these three should we use? Options 1 and 2 will effectively give the same result, although option 1 is definitely simpler. Following the general principle known as <indexedItem
term="iOccamsRazor"
></indexedItem
>Occam's Razor,<endnote
id="nOccamsRazor"
><p
>Occam's Razor states “one should not increase, beyond what is necessary, the number of entities required to explain anything.”. See <citation
author="yes"
ref="rOccamsRazor"
></citation
> for more detail.</p
></endnote
> option 1 is thus better.</p
><p
><indexedItem
term="iNullAllomorph"
></indexedItem
>Option 3 requires us to posit a null suffix and some argue that if an affix is always null (as it would be here) then what we really have is a <indexedItem
term="iInflFeatDefault"
></indexedItem
>default feature: unless there is an overt number suffix, assume that the number is singular. While <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
> does not allow us to mark such default features, later stages of <object
type="WordWorks"
></object
> will.</p
><p
>Therefore, from a long term perspective, we recommend following option 1.</p
><p
>This means that to model this inflectional template, we will need to do the following:</p
><example
num="xNahuatlPossessorHowTo"
><chart
type="HowTo"
><ol
><li
>Create or at least make sure we have a possessed noun category.</li
><li
>Create an inflectional template within the possessed noun category.</li
><li
>Give that template one prefix slot (for possessor).</li
><li
>Give that template one suffix slot (for number).</li
><li
>Mark the number suffix slot as optional.</li
><li
>For the possessor prefix slot, put in it the six possessor prefixes listed in the first column of <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlPossessedPluralNounTemplate"
></exampleRef
>. If these possessor prefixes do not already exist, then we need to create the lexical entries and mark them as inflectional.</li
><li
>For the number suffix slot, put the plural suffix in it. If the number suffix does not already exist, then create the lexical entry for it and mark it as inflectional.</li
></ol
></chart
></example
><p
>Once we have done this, we will have successfully set up the inflectional morphotactics for possessed nominals in Orizaba Nahuatl.</p
></section4
><section4
id="sInflAffixMultipleTemplates"
><secTitle
>Multiple Templates</secTitle
><p
>In the previous section we suggested that using optional affix slots in a template was a good choice for handling Orizaba Nahuatl nominal possession. Since we noted that within the <object
type="WordWorks"
></object
> approach, one could add more than one template to a category, one might wonder when it would be appropriate to choose such an option.</p
><p
>Orizaba Nahuatl happens to provide such a case. Consider the information for an intransitive, present tense verb given in <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlVerbalInflection"
></exampleRef
> above, but this time displayed in a fashion more conducive to our purposes here:</p
><example
num="xNahuatlVerbalParadigmPres"
><table
border="1"
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>to.die, present tense</gloss
></td
><td
align="left"
valign="top"
>1st Person Subject</td
><td
align="left"
valign="top"
>2nd Person Subject</td
><td
align="left"
valign="top"
>3rd Person Subject</td
></tr
><tr
><td
align="left"
valign="top"
>Singular</td
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>nimiki</langData
></td
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>timiki</langData
></td
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>miki</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>Plural</td
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>timikih</langData
></td
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>anmikih</langData
></td
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>mikih</langData
></td
></tr
></table
></example
><p
>What are the inflectional affixes here? At least under one analysis, there are four subject prefixes and a plural suffix. Third person subject is the default or is null. Similarly, singular number is the default or null.</p
><p
>Where do these inflectional affixes appear? Notice that all the subject ones appear just before the stem and that the plural suffix appears right after the stem. Similar paradigms for other intransitive verbs would show the same situation (ignoring any morphophonology). Therefore we could posit that the present tense, intransitive verb has an inflectional template that consists of a subject inflectional affix followed by the stem which is followed by a number inflectional suffix. We could diagram this as in <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlPresIntrTemplate"
></exampleRef
>.</p
><example
num="xNahuatlPresIntrTemplate"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Subject</th
><th
align="left"
valign="top"
>Stem</th
><th
align="left"
valign="top"
>Number</th
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>ni</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘1SgSubj’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>ti</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘2SgSubj’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>ti</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘1PlSubj’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>an</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘2PlSubj’</gloss
></td
></tr
></table
></td
><td
> </td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
>-<langData
lang="lNahuatl"
>h</langData
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘Pl’</gloss
></td
></tr
></table
></td
></tr
></table
></example
><p
>At first glance, this is very much like what we saw for possessed nominals in example <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlPossessedPluralNounTemplate"
></exampleRef
> above. We might think initially that we can do exactly what we did for possessed nominals and merely mark the Number slot as optional for these intransitive verbs. If we were to do that, however, notice what would happen for a form like <langData
lang="lNahuatl"
>timiki</langData
> which is supposed to only mean <gloss
lang="lGloss"
>‘you(sg.) die.’</gloss
> Because the Number slot would be optional, the <object
type="WordWorks"
></object
> parser would allow a parse of <gloss
lang="lGloss"
>1PlSubj-to.die</gloss
> as well (this, of course, is because both <gloss
lang="lGloss"
>2SgSubj</gloss
> and <gloss
lang="lGloss"
>1PlSubj</gloss
> have the same shape: <langData
lang="lNahuatl"
>ti</langData
>‑). At this point, we would have nothing to prevent this incorrect parse.<endnote
id="nTimikih"
><p
>In addition, the form <langData
lang="lNahuatl"
>timikih</langData
> could parse as <gloss
lang="lGloss"
>2SgSubj‑to.die‑Plural</gloss
>. This, too, is incorrect. If we used the <indexedItem
term="iMGA"
></indexedItem
>Morphosyntactic Glossing Assistant tool to create the glosses, then this parse would not appear: the subject number agreement feature would have a value of ‘singular’ which would conflict with the number agreement feature value of the suffix; namely ‘plural.’ <indexedItem
term="iStage1"
></indexedItem
><indexedItem
term="iInflFeatDefault"
></indexedItem
>Stage 1, however, does not have any way to indicate default features for a category (e.g. marking ‘singular’ as the default) in order to prevent the form <langData
lang="lNahuatl"
>timiki</langData
> from parsing as <gloss
lang="lGloss"
>1PlSubj‑to.die</gloss
>.</p
></endnote
></p
><p
>To eliminate this problem (as well as to eliminate the possibility of the parser allowing a parse for an ill-formed word such as *<langData
lang="lNahuatl"
>anmiki</langData
>), we can create two inflectional templates: one for singular and one for plural. The singular one will be like this:</p
><example
num="xNahuatlPresSingularIntrTemplate"
><table
border="1"
><tr
><th
align="left"
valign="top"
>SgSubject</th
><th
align="left"
valign="top"
>Stem</th
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>ni</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘1SgSubj’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>ti</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘2SgSubj’</gloss
></td
></tr
></table
></td
><td
> </td
></tr
></table
></example
><p
>The plural one will be like this:</p
><example
num="xNahuatlPresPluralIntrTemplate"
><table
border="1"
><tr
><th
align="left"
valign="top"
>PlSubject</th
><th
align="left"
valign="top"
>Stem</th
><th
align="left"
valign="top"
>Number</th
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>ti</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘1PlSubj’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>an</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘2PlSubj’</gloss
></td
></tr
></table
></td
><td
> </td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
>-<langData
lang="lNahuatl"
>h</langData
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘Pl’</gloss
></td
></tr
></table
></td
></tr
></table
></example
><p
>Notice how this method places the singular subject markers in the singular template and puts the plural subject markers in the plural template. This way we force the presence of the plural suffix for the plural subject prefixes.</p
><p
>What needs to be done to handle the 3rd person cases? We will need to mark the subject slot as optional in both templates in order to allow for the 3rd person cases.</p
><p
>This means that to model this inflectional template, we will need to do the following:</p
><example
num="xNahuatlIntransitiveVerbHowTo"
><chart
type="HowTo"
><ol
><li
>Create or at least make sure we have an intransitive verb category.</li
><li
>Create two inflectional templates within the intransitive verb category:<ol
><li
>For the singular template:<ol
><li
>Give it one prefix slot (for singular subject).</li
><li
>Mark this slot as optional.</li
><li
>Put the <gloss
lang="lGloss"
>1SgSubj</gloss
>‑ and <gloss
lang="lGloss"
>2SgSubj</gloss
>‑ prefixes in this slot. If these prefixes do not already exist, create them and mark them as inflectional.</li
></ol
></li
><li
>For the plural template:<ol
><li
>Give it one prefix slot (for plural subject).</li
><li
>Mark this slot as optional.</li
><li
>Put the <gloss
lang="lGloss"
>1PlSubj</gloss
>‑ and <gloss
lang="lGloss"
>2PlSubj</gloss
>‑ prefixes in this slot. If these prefixes do not already exist, create them and mark them as inflectional.</li
><li
>Give it a required suffix slot (for number).</li
><li
>Put the ‑<gloss
lang="lGloss"
>Pl</gloss
> suffix in this slot. If this suffix does not already exist, create it and mark it as inflectional<indexedRangeEnd
begin="bOrizabaInflection"
></indexedRangeEnd
>.</li
></ol
></li
></ol
></li
></ol
></chart
></example
></section4
><section4
id="sInflAffixDiscontinuous"
><secTitle
>Discontinuous Morpheme</secTitle
><p
><indexedItem
term="iCooccurrenceConstraint"
></indexedItem
>In section <sectionRef
sec="sIssueDiscontinuousMorphemes"
></sectionRef
> above, we noted that in <indexedItem
term="iCaquinte"
></indexedItem
>Caquinte, the future tense is realized as a discontinuous morpheme: it is composed of the prefix <langData
lang="lCaquinte"
>n</langData
>‑ and the suffix ‑<langData
lang="lCaquinte"
>e</langData
>. We repeat the example here:</p
><example
num="xCaquinteFuture2"
><interlinear
><lineGroup
><line
><wrd
lang="lCaquinte"
>intsavetacojitero</wrd
><wrd
lang="lReference"
><exampleRef
equal="yes"
letterOnly="no"
num="xCaquinteFuture"
></exampleRef
></wrd
></line
><line
><wrd
><langData
lang="lCaquinte"
>i-n-tsave-(t)-ako-hi-(t)-e-ro</langData
></wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>3M-FUT-tell- -DAT-PAS- -F-3FO</gloss
></wrd
></line
></lineGroup
><free
>‘she will be told about’</free
></interlinear
></example
><p
>How do we fulfill this requirement that both the future prefix and future suffix appear? One way is to create a future tense inflectional template which has both the prefix and the suffix required. The template might look like this:</p
><example
num="xCaquinteFutureTransTemplate"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Subject</th
><th
align="left"
valign="top"
>Future</th
><th
align="left"
valign="top"
>Stem</th
><th
align="left"
valign="top"
>Future</th
><th
align="left"
valign="top"
>Object</th
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lCaquinte"
>no</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘1Subj’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lCaquinte"
>a</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘1InclSubj’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lCaquinte"
>pi</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘2Subj’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lCaquinte"
>i</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘3MascSubj’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lCaquinte"
>o</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘3FemSubj’</gloss
></td
></tr
></table
></td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lCaquinte"
>N</langData
>-</td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘FUT’</gloss
></td
></tr
></table
></td
><td
> </td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
>-<langData
lang="lCaquinte"
>e</langData
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘F’</gloss
></td
></tr
></table
></td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
>-<langData
lang="lCaquinte"
>na</langData
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘1Obj’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
>-<langData
lang="lCaquinte"
>ahi</langData
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘1InclObj’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
>-<langData
lang="lCaquinte"
>Npi</langData
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘2Obj’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
>-<langData
lang="lCaquinte"
>ri</langData
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘3MascObj’</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
>-<langData
lang="lCaquinte"
>ro</langData
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘3FemObj’</gloss
></td
></tr
></table
></td
></tr
></table
></example
><p
>Another possible way to treat discontinuous morphemes when one part appears before the stem and the other appears after the stem is to treat them as a single <indexedItem
term="iCircumfix"
></indexedItem
>circumfix entry. See section <sectionRef
sec="sCircumfixes"
></sectionRef
>.</p
></section4
><section4
id="sInflAffixPOSConsiderations"
><secTitle
>Inflection and Categories Considerations</secTitle
><p
><indexedItem
term="iCategoryHierarchy"
></indexedItem
>The categories in <object
type="WordWorks"
></object
> are organized in a hierarchical fashion. For example, one can have a major category of <object
type="category"
>verb</object
> and then nest other verb types underneath it (e.g. <object
type="category"
>intransitive verb</object
>, <object
type="category"
>transitive verb</object
>, etc.) One can even nest other types under these if one so wishes (e.g. one might put <object
type="category"
>bitransitive verb</object
> under <object
type="category"
>transitive verb</object
>.).</p
><p
>The exact hierarchy one uses can make a difference for how the <object
type="WordWorks"
></object
> parser handles the inflectional templates and their slots. For templates, when you define an inflectional template for a given category, that template will be tried for any stem of that category or a stem of <object
type="InFocus"
>any of its nested categories</object
>. If, for example, you have <object
type="category"
>intransitive verb</object
> and <object
type="category"
>transitive verb</object
> nested under <object
type="category"
>verb</object
>, then any inflectional template you define on <object
type="category"
>verb</object
> will also be tried by the <object
type="WordWorks"
></object
> parser for any <object
type="category"
>intransitive verb</object
> or <object
type="category"
>transitive verb</object
> stem. On the other hand, in this scenario, any inflectional template defined under <object
type="category"
>intransitive verb</object
> will only be applied to <object
type="category"
>intransitive verb</object
> stems and any inflectional template defined under <object
type="category"
>transitive verb</object
> will only be applied to <object
type="category"
>transitive verb</object
> stems.</p
><p
>Thus, you can capture generalizations about the inflectional templates by placing common inflectional templates higher in the hierarchy.</p
><p
>Inflectional affix slots behave similarly with respect to the hierarchy: when one defines the slots for a given category, those slots may be used in any template for this category and <object
type="InFocus"
>any of its nested categories</object
>. For example, if all of your verbs share a common subject slot, then you can define this subject slot at the main <object
type="category"
>verb</object
> category. This slot will then be available for any affix templates in all sub-categories of <object
type="category"
>verb</object
>.<endnote
id="nSlotsWithSameName"
><p
>Please note that you can use the same name for slots at different points in the hierarchy (e.g. use “Subject” at both the top <object
type="category"
>verb</object
> level and also under a nested <object
type="category"
>intransitive verb</object
> category). The <object
type="WordWorks"
></object
> parser will always know which one is which. You and others who look at your implementation, however, may find it confusing. Therefore, we do not recommend that you do this.</p
></endnote
></p
><p
>You may well need to keep this in mind as you design your category hierarchy<indexedRangeEnd
begin="bInflectionalSlot"
></indexedRangeEnd
><indexedRangeEnd
begin="bInflectionalTemplate"
></indexedRangeEnd
>.</p
></section4
><section4
id="sInflAffixInflectionClasses"
><secTitle
>Inflection Classes</secTitle
><p
><indexedItem
term="iInflectionClass"
></indexedItem
>We now turn to something that is actually about morphophonemics, not morphotactics. We include it here, though, because it relates to inflectional affixes.</p
><p
>Consider the <indexedItem
term="iYalalagZapotec"
></indexedItem
>Yalálag Zapotec data given in <exampleRef
equal="no"
letterOnly="no"
num="xYalalagZapotecVerbClass1"
></exampleRef
>‑<exampleRef
equal="no"
letterOnly="no"
num="xYalalagZapotecVerbClass2"
></exampleRef
>:<endnote
id="nYalalag"
><p
></p
><p
>The data are from <citation
author="yes"
ref="rYalalagVerbBook"
></citation
>. The abbreviations used in the <indexedItem
term="iYalalagZapotec"
></indexedItem
>Yalálag Zapotec data are:</p
><table
border="1"
type="LessSpaceBeforeTable"
><tr
><th
align="left"
valign="top"
>Abbreviation</th
><th
align="left"
valign="top"
>Meaning</th
></tr
><tr
><td
align="left"
valign="top"
>Fut</td
><td
align="left"
valign="top"
>future</td
></tr
><tr
><td
align="left"
valign="top"
>1PlIncl</td
><td
align="left"
valign="top"
>1st person plural inclusive pronominal clitic</td
></tr
><tr
><td
align="left"
valign="top"
>intrans</td
><td
align="left"
valign="top"
>intransitive verb</td
></tr
><tr
><td
align="left"
valign="top"
>trans</td
><td
align="left"
valign="top"
>transitive verb</td
></tr
></table
><p
>The orthography used here is slightly different from what is used in <citation
author="yes"
ref="rYalalagVerbBook"
></citation
>. In particular, fortis consonants are preceded by a colon (<langData
lang="lYalalag"
>:</langData
>). Lenis consonants are not (and use the voiceless equivalent instead of the voiced one).</p
></endnote
></p
><example
num="xYalalagZapotecVerbClass1"
><listInterlinear
letter="xYalalagZapotecVerbClass1Pass"
><lineGroup
><line
><langData
lang="lYalalag"
>utecho</langData
></line
><line
><langData
lang="lYalalag"
>u-te-cho</langData
></line
><line
><gloss
lang="lGloss"
>Fut-to.pass(trans)-1PlIncl</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xYalalagZapotecVerbClass1Limp"
><lineGroup
><line
><langData
lang="lYalalag"
>u:ke'nia'cho</langData
></line
><line
><langData
lang="lYalalag"
>u-:ke'nia'-cho</langData
></line
><line
><gloss
lang="lGloss"
>Fut-to.limp(intrans)-1PlIncl</gloss
></line
></lineGroup
></listInterlinear
></example
><example
num="xYalalagZapotecVerbClass2"
><listInterlinear
letter="xYalalagZapotecVerbClass2Pass"
><lineGroup
><line
><langData
lang="lYalalag"
>:techo</langData
></line
><line
><langData
lang="lYalalag"
>:-te-cho</langData
></line
><line
><gloss
lang="lGloss"
>Fut-to.pass(intrans)-1PlIncl</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xYalalagZapotecVerbClass2Encourage"
><lineGroup
><line
><langData
lang="lYalalag"
>:ti:pla':chcho</langData
></line
><line
><langData
lang="lYalalag"
>:-ti:pla':ch-cho</langData
></line
><line
><gloss
lang="lGloss"
>Fut-to.encourage(trans)-1PlIncl</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>What is the phonological shape of the Future marker? It appears to be <langData
lang="lYalalag"
>u</langData
>‑ in <exampleRef
equal="no"
letterOnly="no"
num="xYalalagZapotecVerbClass1"
></exampleRef
> but the “fortifier” segment/feature <langData
lang="lYalalag"
>:</langData
>‑ (i.e. a colon) in <exampleRef
equal="no"
letterOnly="no"
num="xYalalagZapotecVerbClass2"
></exampleRef
>. Notice that there do not appear to be any phonological reasons for the different allomorphs. In fact, the stem has the same phonological shape in <exampleRef
equal="no"
letter="xYalalagZapotecVerbClass1Pass"
letterOnly="no"
></exampleRef
> and in <exampleRef
equal="no"
letter="xYalalagZapotecVerbClass2Pass"
letterOnly="no"
></exampleRef
>.<endnote
id="nYalalagClassNotTransitivity"
><p
>Also note that the difference in future allomorphy is not due to transitivity.</p
></endnote
> This problem is not isolated to these pairs of forms; it turns out that verb stems in general divide into two groups, those that take the <langData
lang="lYalalag"
>u</langData
>‑ future and those that take the <langData
lang="lYalalag"
>:</langData
>‑ future.</p
><p
><indexedItem
term="iAllomorphy"
></indexedItem
>How do we handle this kind of allomorphy when the choice of allomorphs is not motivated by the phonological environment but by the choice of the lexical stem? The <object
type="WordWorks"
></object
> approach is to use inflection classes. An inflection class is “a set of lexemes whose members each have the same type of inflectional forms” <citation
author="yes"
page="64"
ref="rAronoff1994"
></citation
>. They correspond to the traditional idea of <indexedItem
term="iDeclensionClass"
></indexedItem
>declension classes or <indexedItem
term="iConjugationClass"
></indexedItem
>conjugation classes. For Yalálag Zapotec, <indexedItem
term="iCategoryHierarchy"
></indexedItem
>we would create two inflection classes at the top-level <object
type="category"
>verb</object
> category (so that it applies to <object
type="category"
>verb</object
> and all sub-categories of <object
type="category"
>verb</object
>; see section <sectionRef
sec="sInflAffixInflectionClassesAndCategoryHierarchy"
></sectionRef
>). One class would be for stems that select the <langData
lang="lYalalag"
>u</langData
>‑ allomorph and the other would be for those that take the “fortifier” <langData
lang="lYalalag"
>:</langData
>‑ allomorph.</p
><p
>This means that to model these inflection classes, we will need to do the following:</p
><example
num="xYalalagInflectionClassHowTo"
><chart
type="HowTo"
><ol
><li
>Create two inflection classes within the verb category.</li
><li
>Create the future inflectional prefix and within it<ol
><li
>Create the <langData
lang="lYalalag"
>u</langData
>‑ allomorph and tag it as belonging to the first inflection class.</li
><li
>Create the “fortifier” <langData
lang="lYalalag"
>:</langData
>‑ allomorph and tag it as belonging to the second inflection class.</li
></ol
></li
><li
>For each verb stem, tag it as belonging to either the first or the second inflection class, whichever is correct for that verb.</li
></ol
></chart
></example
><p
>Now consider the following <indexedItem
term="iLatin"
></indexedItem
>Latin data which also illustrates the use of inflection classes.<endnote
id="nLatin"
><p
>The data are from <link
href="http://www.thelatinlibrary.com/decl.html"
>http://www.thelatinlibrary.com/decl.html</link
> and <link
href="http://www.slu.edu/colleges/AS/languages/classical/latin/tchmat/grammar/decl-c.html"
>http://www.slu.edu/colleges/AS/languages/classical/latin/tchmat/grammar/decl-c.html</link
>.</p
></endnote
></p
><example
num="xLatinDativePlurals"
><table
border="1"
><tr
><th
align="left"
valign="top"
><indexedItem
term="iDeclensionClass"
></indexedItem
>Declension</th
><th
align="left"
valign="top"
>Citation Form</th
><th
align="left"
valign="top"
>Gloss</th
><th
align="left"
valign="top"
>Dative Plural</th
></tr
><tr
><td
align="left"
valign="top"
>I</td
><td
align="left"
valign="top"
><langData
lang="lLatin"
>causa</langData
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>reason</gloss
></td
><td
align="left"
valign="top"
><langData
lang="lLatin"
>caus-is</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>II</td
><td
align="left"
valign="top"
><langData
lang="lLatin"
>annus</langData
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>year</gloss
></td
><td
align="left"
valign="top"
><langData
lang="lLatin"
>ann-is</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>III</td
><td
align="left"
valign="top"
><langData
lang="lLatin"
>civis</langData
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>citizen</gloss
></td
><td
align="left"
valign="top"
><langData
lang="lLatin"
>civ-ibus</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>IV</td
><td
align="left"
valign="top"
><langData
lang="lLatin"
>manus</langData
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>hand</gloss
></td
><td
align="left"
valign="top"
><langData
lang="lLatin"
>man-ibus</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>V</td
><td
align="left"
valign="top"
><langData
lang="lLatin"
>dies</langData
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>day</gloss
></td
><td
align="left"
valign="top"
><langData
lang="lLatin"
>di-ebus</langData
></td
></tr
></table
></example
><p
>Note that while there are five distinct declensions in Latin, there are only three forms for the dative plural: ‑<langData
lang="lLatin"
>is</langData
>, ‑<langData
lang="lLatin"
>ibus</langData
>, and ‑<langData
lang="lLatin"
>ebus</langData
>. In particular, notice that ‑<langData
lang="lLatin"
>is</langData
> is used for both declension class I and II and, similarly, ‑<langData
lang="lLatin"
>ibus</langData
> is used for both declension class III and IV. So to model this Latin data in <object
type="WordWorks"
></object
>, we will need to do the following:<endnote
id="nLatinMore"
><p
>Of course, one would want to model the full nominal paradigm if one were working on Latin, but this limited usage here illustrates the point about letting a given allomorph refer to more than one inflection class.</p
></endnote
></p
><example
num="xLatinInflectionClassHowTo"
><chart
type="HowTo"
><ol
><li
>Create five inflection classes within the noun category.</li
><li
>Create the dative plural inflectional suffix and within it<ol
><li
>Create the ‑<langData
lang="lLatin"
>is</langData
> allomorph and tag it as belonging to both the first and second inflection classes.</li
><li
>Create the ‑<langData
lang="lLatin"
>ibus</langData
> allomorph and tag it as belonging to both the third and fourth inflection classes.</li
><li
>Create the ‑<langData
lang="lLatin"
>ebus</langData
> allomorph and tag it as belonging to the fifth inflection class.</li
></ol
></li
><li
>For each noun stem, tag it as belonging to the appropriate inflection class, whichever is correct for that noun.</li
></ol
></chart
></example
><p
><indexedRangeBegin
id="bDefaultInflectionClass"
term="iInflClassDefault"
></indexedRangeBegin
>Note that one can also set the default inflection class to be one of the inflection classes. If you do this, the <object
type="WordWorks"
></object
> parser will use this default inflection class for any stem that is not overtly tagged with an inflection class.<indexedRangeEnd
begin="bDefaultInflectionClass"
></indexedRangeEnd
></p
><p
><indexedRangeBegin
id="bInflClassesEnv"
term="iInflClassEnvironments"
></indexedRangeBegin
>In addition, if an affix entry has any inflection classes and at least some of the allomorphs are constrained with environments (as described in section <sectionRef
sec="sEnvironments"
></sectionRef
>), one should be careful to tag all allomorphs in the entry with the inflection class(es) they go on. Otherwise, some allomorphs without environments may be incorrectly constrained.<indexedRangeEnd
begin="bInflClassesEnv"
></indexedRangeEnd
></p
><section5
id="sInflAffixInflectionSubClasses"
><secTitle
>Inflection Subclasses</secTitle
><p
><indexedRangeBegin
id="bInflectionSubclass"
term="iInflClassSublcass"
></indexedRangeBegin
>Now we consider one more situation where inflection classes are appropriate. Like Yalálag Zapotec, <indexedRangeBegin
id="bIsthmusZapotec"
term="iIsthmusZapotec"
></indexedRangeBegin
>Isthmus Zapotec also has verbal inflection classes.<endnote
id="nIZData"
><p
>The data are taken from <citation
ref="rIZPracticalGrammar"
></citation
> and follow the practical orthography.</p
></endnote
> There is a distinction, however. First, consider the data in <exampleRef
letter="xIZHabitual"
num="xIZHabitual"
></exampleRef
>-<exampleRef
equal="no"
letter="xIZFuture"
letterOnly="no"
num="xIZFuture"
></exampleRef
>, paying attention to the aspect prefixes.</p
><p
>Habitual aspect:</p
><example
num="xIZHabitual"
><listInterlinear
letter="xIZHabitualClass2"
><lineGroup
><line
><langData
lang="lIsthmus"
>rucaa</langData
></line
><line
><langData
lang="lIsthmus"
>ru-caa</langData
></line
><line
><gloss
lang="lGloss"
>Hab-to.write</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZHabitualClass1A"
><lineGroup
><line
><langData
lang="lIsthmus"
>riree</langData
></line
><line
><langData
lang="lIsthmus"
>ri-ree</langData
></line
><line
><gloss
lang="lGloss"
>Hab-to.leave</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZHabitualClass1B"
><lineGroup
><line
><langData
lang="lIsthmus"
>richesa</langData
></line
><line
><langData
lang="lIsthmus"
>ri-chesa</langData
></line
><line
><gloss
lang="lGloss"
>Hab-to.jump</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZHabitualClass1C"
><lineGroup
><line
><langData
lang="lIsthmus"
>rizá</langData
></line
><line
><langData
lang="lIsthmus"
>ri-zá</langData
></line
><line
><gloss
lang="lGloss"
>Hab-to.walk</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>Progressive aspect:</p
><example
num="xIZProgressive"
><listInterlinear
letter="xIZProgressiveClass2"
><lineGroup
><line
><langData
lang="lIsthmus"
>cucaa</langData
></line
><line
><langData
lang="lIsthmus"
>cu-caa</langData
></line
><line
><gloss
lang="lGloss"
>Prog-to.write</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZProgressiveClass1A"
><lineGroup
><line
><langData
lang="lIsthmus"
>caree</langData
></line
><line
><langData
lang="lIsthmus"
>ca-ree</langData
></line
><line
><gloss
lang="lGloss"
>Prog-to.leave</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZProgressiveClass1B"
><lineGroup
><line
><langData
lang="lIsthmus"
>cachesa</langData
></line
><line
><langData
lang="lIsthmus"
>ca-chesa</langData
></line
><line
><gloss
lang="lGloss"
>Prog-to.jump</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZProgressiveClass1C"
><lineGroup
><line
><langData
lang="lIsthmus"
>cazá</langData
></line
><line
><langData
lang="lIsthmus"
>ca-zá</langData
></line
><line
><gloss
lang="lGloss"
>Prog-to.walk</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>Unreal aspect:</p
><example
num="xIZUnreal"
><listInterlinear
letter="xIZUnrealClass2"
><lineGroup
><line
><langData
lang="lIsthmus"
>nucaa</langData
></line
><line
><langData
lang="lIsthmus"
>nu-caa</langData
></line
><line
><gloss
lang="lGloss"
>Un-to.write</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZUnrealClass1A"
><lineGroup
><line
><langData
lang="lIsthmus"
>niree</langData
></line
><line
><langData
lang="lIsthmus"
>ni-ree</langData
></line
><line
><gloss
lang="lGloss"
>Un-to.leave</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZUnrealClass1B"
><lineGroup
><line
><langData
lang="lIsthmus"
>nichesa</langData
></line
><line
><langData
lang="lIsthmus"
>ni-chesa</langData
></line
><line
><gloss
lang="lGloss"
>Un-to.jump</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZUnrealClass1C"
><lineGroup
><line
><langData
lang="lIsthmus"
>nizá</langData
></line
><line
><langData
lang="lIsthmus"
>ni-zá</langData
></line
><line
><gloss
lang="lGloss"
>Un-to.walk</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>Future aspect:</p
><example
num="xIZFuture"
><listInterlinear
letter="xIZFutureClass2"
><lineGroup
><line
><langData
lang="lIsthmus"
>zucaa</langData
></line
><line
><langData
lang="lIsthmus"
>zu-caa</langData
></line
><line
><gloss
lang="lGloss"
>Fut-to.write</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZFutureClass1A"
><lineGroup
><line
><langData
lang="lIsthmus"
>zaree</langData
></line
><line
><langData
lang="lIsthmus"
>za-ree</langData
></line
><line
><gloss
lang="lGloss"
>Fut-to.leave</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZFutureClass1B"
><lineGroup
><line
><langData
lang="lIsthmus"
>zachesa</langData
></line
><line
><langData
lang="lIsthmus"
>za-chesa</langData
></line
><line
><gloss
lang="lGloss"
>Fut-to.jump</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZFutureClass1C"
><lineGroup
><line
><langData
lang="lIsthmus"
>zazá</langData
></line
><line
><langData
lang="lIsthmus"
>za-zá</langData
></line
><line
><gloss
lang="lGloss"
>Fut-to.walk</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>Notice that based on this data, there are two inflection classes as summarized in <exampleRef
letter="xIZ2Classes"
num="xIZ2Classes"
></exampleRef
>.<endnote
id="nIZSwappingClassNumbers"
><p
>I am swapping the class numbering found in section 7.3 of <citation
ref="rIZPracticalGrammar"
></citation
> for pedagogical reasons.</p
></endnote
></p
><example
num="xIZ2Classes"
><table
border="1"
><tr
><th
>Aspect</th
><th
>Class 1</th
><th
>Class 2</th
></tr
><tr
><td
>Habitual</td
><td
><langData
lang="lIsthmus"
>ru-</langData
></td
><td
><langData
lang="lIsthmus"
>ri-</langData
></td
></tr
><tr
><td
>Progressive</td
><td
><langData
lang="lIsthmus"
>cu-</langData
></td
><td
><langData
lang="lIsthmus"
>ca-</langData
></td
></tr
><tr
><td
>Unreal</td
><td
><langData
lang="lIsthmus"
>nu-</langData
></td
><td
><langData
lang="lIsthmus"
>ni-</langData
></td
></tr
><tr
><td
>Future</td
><td
><langData
lang="lIsthmus"
>zu-</langData
></td
><td
><langData
lang="lIsthmus"
>za-</langData
></td
></tr
></table
></example
><p
>Second, when we consider two other aspects, things are not so straightforward. The stems are presented in the same order in <exampleRef
letter="xIZCompletive"
num="xIZCompletive"
></exampleRef
>-<exampleRef
letter="xIZPotential"
num="xIZPotential"
></exampleRef
> as they were above in <exampleRef
letter="xIZHabitual"
num="xIZHabitual"
></exampleRef
>-<exampleRef
equal="no"
letter="xIZFuture"
letterOnly="no"
num="xIZFuture"
></exampleRef
>:</p
><p
>Completive aspect:</p
><example
num="xIZCompletive"
><listInterlinear
letter="xIZCompletiveClass2"
><lineGroup
><line
><langData
lang="lIsthmus"
>bicaa</langData
></line
><line
><langData
lang="lIsthmus"
>bi-caa</langData
></line
><line
><gloss
lang="lGloss"
>Comp-to.write</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZCompletiveClass1A"
><lineGroup
><line
><langData
lang="lIsthmus"
>biree</langData
></line
><line
><langData
lang="lIsthmus"
>bi-ree</langData
></line
><line
><gloss
lang="lGloss"
>Comp-to.leave</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZCompletiveClass1B"
><lineGroup
><line
><langData
lang="lIsthmus"
>guchesa</langData
></line
><line
><langData
lang="lIsthmus"
>gu-chesa</langData
></line
><line
><gloss
lang="lGloss"
>Comp-to.jump</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZCompletiveClass1C"
><lineGroup
><line
><langData
lang="lIsthmus"
>guzá</langData
></line
><line
><langData
lang="lIsthmus"
>gu-zá</langData
></line
><line
><gloss
lang="lGloss"
>Comp-to.walk</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>Potential aspect:</p
><example
num="xIZPotential"
><listInterlinear
letter="xIZPotentialClass2"
><lineGroup
><line
><langData
lang="lIsthmus"
>gucaa</langData
></line
><line
><langData
lang="lIsthmus"
>gu-caa</langData
></line
><line
><gloss
lang="lGloss"
>Pot-to.write</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZPotentialClass1A"
><lineGroup
><line
><langData
lang="lIsthmus"
>guiree</langData
></line
><line
><langData
lang="lIsthmus"
>gui-ree</langData
></line
><line
><gloss
lang="lGloss"
>Pot-to.leave</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZPotentialClass1B"
><lineGroup
><line
><langData
lang="lIsthmus"
>guichesa</langData
></line
><line
><langData
lang="lIsthmus"
>gui-chesa</langData
></line
><line
><gloss
lang="lGloss"
>Pot-to.jump</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZPotentialClass1C"
><lineGroup
><line
><langData
lang="lIsthmus"
>sa'</langData
></line
><line
><langData
lang="lIsthmus"
>0-sa'</langData
></line
><line
><gloss
lang="lGloss"
>Pot-to.walk</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>For example, while the habitual prefix in <exampleRef
letter="xIZHabitualClass1A"
num="xIZHabitualClass1A"
></exampleRef
> differs from the one in <exampleRef
letter="xIZHabitualClass2"
num="xIZHabitualClass2"
></exampleRef
>, they are the same for completive aspect in <exampleRef
letter="xIZCompletiveClass1A"
num="xIZCompletiveClass1A"
></exampleRef
> and <exampleRef
letter="xIZCompletiveClass2"
num="xIZCompletiveClass2"
></exampleRef
>. Further, the potential aspect is quite different in <exampleRef
letter="xIZPotentialClass1C"
num="xIZPotentialClass1C"
></exampleRef
>. How can we understand this data?</p
><p
>At least one way to understand this data is to posit two main inflection classes where one of these has three subclasses. We can summarize the affix allomorphy as shown in <exampleRef
letter="xIZ2ClassesWithSubclasses"
num="xIZ2ClassesWithSubclasses"
></exampleRef
>.</p
><example
num="xIZ2ClassesWithSubclasses"
><table
border="1"
><tr
><th
>Aspect</th
><th
>Class 1</th
><th
align="center"
>Class 2</th
></tr
><tr
><td
>Habitual</td
><td
align="center"
><langData
lang="lIsthmus"
>ru-</langData
></td
><td
align="center"
><langData
lang="lIsthmus"
>ri-</langData
></td
></tr
><tr
><td
>Progressive</td
><td
align="center"
><langData
lang="lIsthmus"
>cu-</langData
></td
><td
align="center"
><langData
lang="lIsthmus"
>ca-</langData
></td
></tr
><tr
><td
>Unreal</td
><td
align="center"
><langData
lang="lIsthmus"
>nu-</langData
></td
><td
align="center"
><langData
lang="lIsthmus"
>ni-</langData
></td
></tr
><tr
><td
>Future</td
><td
align="center"
><langData
lang="lIsthmus"
>zu-</langData
></td
><td
align="center"
><langData
lang="lIsthmus"
>za-</langData
></td
></tr
><tr
><td
valign="bottom"
><br
></br
>Completive</td
><td
align="center"
valign="bottom"
><br
></br
><langData
lang="lIsthmus"
>bi-</langData
></td
><td
rowspan="2"
><table
border="1"
><tr
><th
>Class2A</th
><th
>Class2B</th
><th
>Class2C</th
></tr
><tr
><td
align="center"
><langData
lang="lIsthmus"
>bi-</langData
></td
><td
align="center"
><langData
lang="lIsthmus"
>gu-</langData
></td
><td
align="center"
><langData
lang="lIsthmus"
>gu-</langData
></td
></tr
><tr
><td
align="center"
><langData
lang="lIsthmus"
>gui-</langData
></td
><td
align="center"
><langData
lang="lIsthmus"
>gui-</langData
></td
><td
align="center"
><langData
lang="lIsthmus"
>0-</langData
></td
></tr
></table
></td
></tr
><tr
><td
>Potential</td
><td
align="center"
><langData
lang="lIsthmus"
>gu-</langData
></td
></tr
></table
></example
><p
>Finally, there is the Perfect aspect which has the same shape for all verbs as illustrated in <exampleRef
letter="xIZPerfect"
num="xIZPerfect"
></exampleRef
>.<endnote
id="nIZAspectPhonologicalChanges"
><p
>Some of these aspects also have some simple phonologically-based allomorphy which I am not showing here for pedagogical reasons.</p
></endnote
></p
><example
num="xIZPerfect"
><listInterlinear
letter="xIZPerfectClass2"
><lineGroup
><line
><langData
lang="lIsthmus"
>huacaa</langData
></line
><line
><langData
lang="lIsthmus"
>hua-caa</langData
></line
><line
><gloss
lang="lGloss"
>Perf-to.write</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZPerfectClass1A"
><lineGroup
><line
><langData
lang="lIsthmus"
>huaree</langData
></line
><line
><langData
lang="lIsthmus"
>hua-ree</langData
></line
><line
><gloss
lang="lGloss"
>Perf-to.leave</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZPerfectClass1B"
><lineGroup
><line
><langData
lang="lIsthmus"
>huachesa</langData
></line
><line
><langData
lang="lIsthmus"
>hua-chesa</langData
></line
><line
><gloss
lang="lGloss"
>Perf-to.jump</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIZPerfectClass1C"
><lineGroup
><line
><langData
lang="lIsthmus"
>huazá</langData
></line
><line
><langData
lang="lIsthmus"
>hua-zá</langData
></line
><line
><gloss
lang="lGloss"
>Hua-to.walk</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>To model this Isthmus Zapotec data in <object
type="WordWorks"
></object
>, we will need to do the following:</p
><example
num="xIZInflectionClassHowTo"
><chart
type="HowTo"
><ol
><li
>Create two inflection classes within the verb category.</li
><li
>Within the second one, create three subclasses.</li
><li
>For each verb stem, tag it as belonging to the appropriate inflection class or subclass, whichever is correct for that verb.</li
><li
>For the Perfect aspect, merely create the inflectional prefix entry with its single form.</li
><li
>For the Habitual, Progressive, Unreal, and Future aspects, create the inflectional prefix entries, including their two allomorphs.<endnote
id="nIZLexemeform"
><p
>You will need to decide which form to use as the lexeme form and which as the affix allomorph form.</p
></endnote
><ol
><li
>For the Class 1 allomorph, tag it as belonging to Class 1.</li
><li
>For the Class 2 allomorph, tag it as belonging to Class 2.</li
></ol
></li
><li
>For the Completive aspect, create the inflectional prefix entry, including its two allomorphs.<endnoteRef
note="nIZLexemeform"
></endnoteRef
><ol
><li
>For the <langData
lang="lIsthmus"
>bi-</langData
> allomorph, tag it as belonging to Class 1 and Subclass 2A.</li
><li
>For the <langData
lang="lIsthmus"
>gu-</langData
> allomorph, tag it as belonging to Subclass 2B and 2C.</li
></ol
></li
><li
>For the Potential aspect, create the inflectional prefix entry, including its three allomorphs.<endnoteRef
note="nIZLexemeform"
></endnoteRef
><ol
><li
>For the <langData
lang="lIsthmus"
>gu-</langData
> allomorph, tag it as belonging to Class 1.</li
><li
>For the <langData
lang="lIsthmus"
>gui-</langData
> allomorph, tag it as belonging to Subclass 2A and 2B.</li
><li
>For the null allomorph, tag it as belonging to Subclass 2C.<indexedRangeEnd
begin="bIsthmusZapotec"
></indexedRangeEnd
></li
></ol
></li
></ol
></chart
></example
><p
>In general terms, here is how the <object
type="WordWorks"
></object
> morphological parser will constrain an inflectional affix allomorph tagged for inflection classes when there are both main level classes and subclasses for at least one main level class:</p
><example
num="xInflectionClassGeneral"
><chart
><ol
><li
>If the inflectional affix entry has only one form, then that form will always be used, no matter what inflectional class or subclass the stem is tagged with.</li
><li
>If the inflectional affix entry has at least one allomorph tagged with a subclass:<ol
><li
>any allomorph tagged with a subclass will only go on stems which are also tagged with that subclass.</li
><li
>any allomorph tagged with a main level class will only go on stems which are also tagged with that main level class</li
></ol
></li
><li
>If the inflectional affix entry has allomorphs tagged only at the main level, then <ol
><li
>an allomorph can go on a stem tagged with the same main level inflection class as it is tagged with or</li
><li
>an allomorph can go on a stem tagged with an inflection subclass that is a subclass of the main level inflection class that it is tagged with. This implies that the <object
type="WordWorks"
></object
> parser pays attention to the inflection class hierarchy. Even if a stem is tagged with a subclass, the inflectional affix needs to only be tagged at the main level. This is the case even if there are subclasses within subclasses.<indexedRangeEnd
begin="bInflectionSubclass"
></indexedRangeEnd
></li
></ol
></li
></ol
></chart
></example
><p
><indexedRangeBegin
id="bInflSubClassesEnv"
term="iInflSubClassEnvironments"
></indexedRangeBegin
><indexedRangeBegin
id="bInflClassesEnvironmentsInSubclassSection"
term="iInflClassEnvironments"
></indexedRangeBegin
>Finally, please recall that if an affix entry has any inflection classes and at least some of the allomorphs are constrained with environments, one should be careful to tag all allomorphs in the entry with the inflection class(es) they go on. This may need to include subclasses. Otherwise, some allomorphs without environments may be incorrectly constrained. For example, if the allomorph conditioned with an environment goes on a subclass and an unconditioned allomorph is tagged with a main level inflection class, you will need to change the unconditioned one to go on all subclasses. This is because of condition 2b in <exampleRef
letter="xInflectionClassGeneral"
num="xInflectionClassGeneral"
></exampleRef
> above.<indexedRangeEnd
begin="bInflClassesEnvironmentsInSubclassSection"
></indexedRangeEnd
><indexedRangeEnd
begin="bInflSubClassesEnv"
></indexedRangeEnd
></p
></section5
><section5
id="sInflAffixInflectionClassesAndCategoryHierarchy"
><secTitle
>Inflection Classes and Category Organization</secTitle
><p
><indexedItem
term="iCategoryHierarchy"
></indexedItem
>As we noted in section <sectionRef
sec="sInflAffixPOSConsiderations"
></sectionRef
>, the categories in <object
type="WordWorks"
></object
> are organized in a hierarchical fashion.</p
><p
>The exact hierarchy one uses can make a difference for how the <object
type="WordWorks"
></object
> parser handles inflection classes. When you define an inflection class (or an inflection subclass) at a particular category in the hierarchy, then that class is available to be used for any lexical item associated with that category or <object
type="InFocus"
>any of its nested categories</object
>. Thus, you will probably want to define your inflection classes at the highest appropriate level in the hierarchy in order to capture generalizations.</p
></section5
></section4
><section4
id="sInflectionFeatures"
><secTitle
>Agreement and other Inflection Features</secTitle
><p
><indexedItem
term="iInflectionFeature"
></indexedItem
>Consider the <indexedItem
term="iSpanish"
></indexedItem
>Spanish noun data given in <exampleRef
equal="no"
letterOnly="no"
num="xSpanishGender"
></exampleRef
> below:</p
><example
num="xSpanishGender"
><listInterlinear
letter="xSpanishGenderCasa"
><lineGroup
><line
><langData
lang="lSpanish"
>casa</langData
></line
><line
><langData
lang="lSpanish"
>kas-a</langData
></line
><line
><gloss
lang="lGloss"
>house-Feminine</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xSpanishGenderCaso"
><lineGroup
><line
><langData
lang="lSpanish"
>caso</langData
></line
><line
><langData
lang="lSpanish"
>kas-o</langData
></line
><line
><gloss
lang="lGloss"
>case-Masculine</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xSpanishGenderCasita"
><lineGroup
><line
><langData
lang="lSpanish"
>casita</langData
></line
><line
><langData
lang="lSpanish"
>kas-it-a</langData
></line
><line
><gloss
lang="lGloss"
>house-Diminutive-Feminine</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xSpanishGenderCasito"
><lineGroup
><line
><langData
lang="lSpanish"
>casito</langData
></line
><line
><langData
lang="lSpanish"
>kas-it-o</langData
></line
><line
><gloss
lang="lGloss"
>case-Diminutive-Masculine</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>Notice that the main difference between these nouns is the <indexedItem
term="iGender"
></indexedItem
>gender agreement suffix. If the ‑<langData
lang="lSpanish"
>a</langData
> ‘<gloss
lang="lGloss"
>Feminine</gloss
>’ suffix is used, then the <langData
lang="lSpanish"
>cas</langData
> root means  ‘<gloss
lang="lGloss"
>house</gloss
>’. On the other hand, if the ‑<langData
lang="lSpanish"
>o</langData
> ‘<gloss
lang="lGloss"
>Masculine</gloss
>’ suffix is used, then the <langData
lang="lSpanish"
>cas</langData
> root means  ‘<gloss
lang="lGloss"
>case</gloss
>’.</p
><p
><indexedItem
term="iInflFeatRuleOutParses"
></indexedItem
>For a human, it is not necessarily difficult to keep these facts straight, but for a morphological parser, we need some way to prevent it from thinking that <langData
lang="lSpanish"
>casa</langData
> has the masculine root <langData
lang="lSpanish"
>cas</langData
> that means ‘<gloss
lang="lGloss"
>case</gloss
>’. Similarly we need a way to keep the parser from thinking that <langData
lang="lSpanish"
>caso</langData
> has the feminine root <langData
lang="lSpanish"
>cas</langData
> that means ‘<gloss
lang="lGloss"
>house</gloss
>’. That is, we need a way to prevent the parser from giving “analyses” such as the ones shown in <exampleRef
equal="no"
letterOnly="no"
num="xSpanishGenderBad"
></exampleRef
>, where the asterisk (*) indicates that the analysis is incorrect.</p
><example
num="xSpanishGenderBad"
><listInterlinear
letter="xSpanishGenderCasaBad"
><lineGroup
><line
><langData
lang="lSpanish"
>casa</langData
></line
><line
><langData
lang="lSpanish"
>kas-a</langData
></line
><line
><gloss
lang="lGloss"
>*case-Feminine</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xSpanishGenderCasoBad"
><lineGroup
><line
><langData
lang="lSpanish"
>caso</langData
></line
><line
><langData
lang="lSpanish"
>kas-o</langData
></line
><line
><gloss
lang="lGloss"
>*house-Masculine</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>With the <object
type="WordWorks"
></object
> parser we use inflection features to deal with this issue. Inflection features are typically characteristics of a morpheme that play a role in the inflection of a word and/or play a role in the syntax (such as agreement within a noun phrase or agreement between a verbal affix and the noun phrase it agrees with). Note that if you use the <indexedItem
term="iMGA"
></indexedItem
>Morphological Glossing Assistant tool for glossing inflectional affixes, then <object
type="WordWorks"
></object
> will automatically add some inflection features for you.</p
><p
>Coming back to the Spanish data in <exampleRef
equal="no"
letterOnly="no"
num="xSpanishGender"
></exampleRef
> and <exampleRef
equal="no"
letterOnly="no"
num="xSpanishGenderBad"
></exampleRef
> above, how exactly does one use inflection features to rule out incorrect parses such as the ones in <exampleRef
equal="no"
letterOnly="no"
num="xSpanishGenderBad"
></exampleRef
>? The problem here is that there is a mismatch between the gender of the root and the gender of the affix. If we can mark the root for the correct gender and also mark the suffixes for the gender they agree with, then the <object
type="WordWorks"
></object
> parser will only produce the correct parses.</p
><p
>Many languages will use one or more of the inflection features listed in the chart shown in <exampleRef
equal="no"
letterOnly="no"
num="xInflectionFeatures"
></exampleRef
> below.</p
><example
num="xInflectionFeatures"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Feature Type</th
><th
align="left"
valign="top"
>Feature Name</th
><th
align="left"
valign="top"
>Sample Values</th
></tr
><tr
><td
align="left"
rowspan="6"
valign="top"
><indexedItem
term="iInflFeatAgreement"
></indexedItem
>Agr</td
><td
align="left"
valign="top"
>Person</td
><td
align="left"
valign="top"
>1st, 2nd, 3rd</td
></tr
><tr
><td
align="left"
valign="top"
>Number</td
><td
align="left"
valign="top"
>Singular, Dual, Plural</td
></tr
><tr
><td
align="left"
valign="top"
>Gender</td
><td
align="left"
valign="top"
>Masculine, Feminine, Neuter</td
></tr
><tr
><td
align="left"
valign="top"
>Class</td
><td
align="left"
valign="top"
>1, 2, ..., 20 (or by shape or other classification system)</td
></tr
><tr
><td
align="left"
valign="top"
>Animacy</td
><td
align="left"
valign="top"
>Animate, Inanimate</td
></tr
><tr
><td
align="left"
valign="top"
>Case</td
><td
align="left"
valign="top"
>Nominative, Accusative, Dative, Locative, Genitive, Ergative, Absolutive</td
></tr
><tr
><td
align="left"
rowspan="3"
valign="top"
>Infl</td
><td
align="left"
valign="top"
>Aspect</td
><td
align="left"
valign="top"
>Completive, Continuative, Habitual, Perfective, Progressive, Stative</td
></tr
><tr
><td
align="left"
valign="top"
>Tense</td
><td
align="left"
valign="top"
>Past, Present, Future</td
></tr
><tr
><td
align="left"
valign="top"
>Mood</td
><td
align="left"
valign="top"
>Declarative, Imperative, Interrogative, Irrealis, Realis</td
></tr
></table
></example
><p
>These are just some examples. Your language may use these or may need others. You may want to check with a linguistic consultant who is familiar with your language family for ideas as to which inflection features are appropriate for your language. Or you may just want to add them only when you find a need for them, such as when the <object
type="WordWorks"
></object
> parser gives incorrect parses for forms.</p
><p
><indexedItem
term="iInflFeatComplex"
></indexedItem
>The features shown in <exampleRef
letter="xInflectionFeatures"
num="xInflectionFeatures"
></exampleRef
> are all simple features. There are times when a given word could contain more than one such set of simple features. This is where complex features are important. For example, for cases where a noun has <indexedItem
term="iNounClass"
></indexedItem
>noun class, say, and in addition, has a possessive affix which has a different noun class, then we must be careful to avoid the two noun classes from clashing with each other. If we merely use a simple inflection feature of “Class” for both the noun and the possessive affix, then the values will differ and the parser will not analyze the word. <indexedItem
term="iInflFeatAgreement"
></indexedItem
>Instead, we need to use separate noun agreement and possessor agreement complex features. Within each of these complex features, we use the “Class” feature and its values. In this way, not only does the parser correctly analyze the word (because the two complex features do not clash), it also will have the correct features demarcated for eventual syntactic analysis.</p
><p
>Another possible example for the use of complex features is when a verbal word has both subject and object agreement markers in it. If the person features are different for subject and object, then we need to be sure and use two complex features, one for the subject agreement features and the other for the object agreement features.</p
><p
><indexedItem
term="iInflFeatRuleOutParses"
></indexedItem
>The Spanish data illustrates how we can use gender inflection features to rule out incorrect parses when a gender affix shows up incorrectly on a root. Some possible situations where inflection features could play a similar role in ruling out incorrect parses include those shown in <exampleRef
equal="no"
letterOnly="no"
num="xInflectionFeaturesToRuleOutIncorrectParses"
></exampleRef
>.</p
><example
num="xInflectionFeaturesToRuleOutIncorrectParses"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Situation</th
><th
align="left"
valign="top"
>Possible Inflection Features to use</th
></tr
><tr
><td
align="left"
valign="top"
>Gender mismatch between affix and stem</td
><td
align="left"
valign="top"
>Gender agreement features</td
></tr
><tr
><td
align="left"
valign="top"
>Noun class mismatch between affix and stem</td
><td
align="left"
valign="top"
>Noun class agreement features</td
></tr
><tr
><td
align="left"
valign="top"
>Animacy mismatch between affix and stem</td
><td
align="left"
valign="top"
>Animacy agreement features</td
></tr
><tr
><td
align="left"
valign="top"
>Two or more aspect markers showing on a verb, when there should only be one</td
><td
align="left"
valign="top"
>Aspect features</td
></tr
><tr
><td
align="left"
valign="top"
>Two or more tense markers showing on a verb, when there should only be one</td
><td
align="left"
valign="top"
>Tense features</td
></tr
></table
></example
><p
>How does one create and use an inflection feature in <object
type="WordWorks"
></object
>?<endnote
id="nMovieOnNounGender"
><p
>At the time of writing, there is a demo movie called "Specifying Gender" that illustrates this.</p
></endnote
><comment
>Note: this is repeated below in the xStemNamesHowTo example. Some of it is also repeated in the xDerivAffixInflectionFeaturesHowTo example.</comment
></p
><example
num="xInflectionFeaturesHowTo"
><chart
type="HowTo"
><ol
><li
>Determine the inflection feature involved, including its <indexedItem
term="iInflFeatType"
></indexedItem
>type,<endnote
id="nInflectionFeature"
><p
><indexedItem
term="iInflFeatType"
></indexedItem
>We recommend using only two types: “Agr” for agreement features and “Infl” (= Inflection) for all others.</p
></endnote
> name, and possible values. (You may need to check with a linguistic consultant on this.)<ol
><li
><indexedItem
term="iInflFeatCatalog"
></indexedItem
>Try using the Inflection Feature Catalog<endnote
id="nInflectionFeatureCatalog"
><p
>In <object
type="WordWorks"
></object
>, go to the Grammar area, Inflection Features tool. Insert a new feature (either feature or complex feature - it does not matter, both call up the catalog).</p
></endnote
> to see if the feature is already in the catalog. If so, add the feature via the catalog (it's much easier this way).</li
><li
>If the feature is not in the catalog, then<ol
><li
>If the feature type does not yet exist, add it to the feature types.</li
><li
>Create the feature and its values in the features section.</li
></ol
></li
></ol
></li
><li
><indexedItem
term="iCategoryInflectableFeatures"
></indexedItem
>For each category which will use the feature, <ol
><li
>Add the feature to the category's set of inflectable features.</li
><li
>Make sure that the category has appropriate affix templates (see section <sectionRef
sec="sInflectionalAffixes"
></sectionRef
>). If there are no templates for the category, then the <object
type="WordWorks"
></object
> parser will ignore the features.</li
></ol
></li
><li
>For each root needing the feature, add the feature and its appropriate value to the stem's grammatical information details.</li
><li
>For each inflectional affix needing the feature, add the feature and its appropriate value to the inflectional affix's grammatical information details. Note that you may need to Show Hidden Fields to see this Inflection Features field.</li
></ol
></chart
></example
></section4
><section4
id="sInflAffixInflectionClassVsInflectionFeature"
><secTitle
>Inflection Classes versus Inflection Features</secTitle
><p
><indexedItem
term="iInflClassVsInflFeature"
></indexedItem
><indexedItem
term="iInflFeatVsInflClass"
></indexedItem
><indexedItem
term="iInflectionClass"
></indexedItem
><indexedItem
term="iInflectionFeature"
></indexedItem
>When modeling a given language, one may well wonder if a given phenomenon should be handled by inflection classes or by inflection features. Here are some guidelines to help one decide:</p
><p
>Look at the various affixes involved.</p
><table
border="1"
type="leftOffset"
><tr
><th
align="left"
valign="top"
>If they ...</th
><th
align="left"
valign="top"
>then use ...</th
></tr
><tr
><td
align="left"
valign="top"
><table
cellpadding="0"
cellspacing="0"
><tr
><td
align="left"
valign="top"
>have no semantic differences (i.e. have the same meaning),</td
></tr
><tr
><td
align="left"
valign="top"
>have non-phonologically motivated shape differences,</td
></tr
><tr
><td
align="left"
valign="top"
>and are not involved in (syntactic) agreement</td
></tr
></table
></td
><td
align="left"
valign="top"
>inflection class</td
></tr
><tr
><td
align="left"
valign="top"
>have semantic differences (i.e. actually have different meaning)</td
><td
align="left"
valign="top"
>inflection features</td
></tr
><tr
><td
align="left"
valign="top"
>are involved in (syntactic) agreement</td
><td
align="left"
valign="top"
>inflection features</td
></tr
><tr
><td
align="left"
valign="top"
>are really declension classes or conjugation classes</td
><td
align="left"
valign="top"
>inflection classes</td
></tr
><tr
><td
align="left"
valign="top"
>are noun classes or gender</td
><td
align="left"
valign="top"
>inflection features</td
></tr
></table
></section4
><section4
id="sInflAffixUnderspecified"
><secTitle
>Underspecified Inflectional Affixes</secTitle
><p
><indexedItem
term="iInflAffixUnderspecified"
></indexedItem
><indexedItem
term="iAffixUnderSpecified"
></indexedItem
>In the above, we discussed how one can fully specify inflectional affixes. Sometimes it is the case, though, that you are confident that a particular affix is inflectional, but you just do not yet know the category it goes on. Or it might be the case that you know the category, but you do not yet know what the template looks like so you cannot put it in an inflectional affix slot.</p
><p
><object
type="WordWorks"
></object
> allows you to model what you know. That is, you can still label such an affix as being inflectional, but only partially specify the rest of the information about it. If you know the category, but not the slot, you can say so. Be advised, though, that when you do this, the <object
type="WordWorks"
></object
> parser will treat such underspecified inflectional affixes just like it does for “<indexedItem
term="iAffixUnclassified"
></indexedItem
>unclassified” affixes (see section <sectionRef
sec="sUnclassifiedAffixes"
></sectionRef
>)<indexedRangeEnd
begin="bInflectionalAffix"
></indexedRangeEnd
>.</p
></section4
></section3
><section3
id="sDerivationalAffixes"
><secTitle
>Derivational Affixes</secTitle
><p
><indexedRangeBegin
id="bDerivation"
main="yes"
term="iDerivation"
></indexedRangeBegin
><indexedRangeBegin
id="bDerivationalAffix"
main="yes"
term="iDerivationalAffix"
></indexedRangeBegin
>Derivational affixes typically reflect what some call “lexical meaning.” They go on a stem to produce a new stem. The new stem may then be inflected (if the category of the new stem has inflection). Derivational affixes often <indexedItem
term="iDerivationCatChanging"
></indexedItem
>change syntactic category. See <citation
author="yes"
page="135ff"
ref="rBickford"
></citation
> for more on this.</p
><section4
id="sCatChanging"
><secTitle
>Major Category-changing Derivational Affixes</secTitle
><p
><indexedItem
term="iDerivationCatChanging"
></indexedItem
><indexedItem
term="iCategoryChanging"
></indexedItem
>The <indexedItem
term="iEnglish"
></indexedItem
>English data from example <exampleRef
equal="no"
letterOnly="no"
num="xEnglishDerivation"
></exampleRef
> is repeated below with more information:</p
><example
num="xEnglishDerivation2"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Form</th
><th
align="left"
valign="top"
>Derivational Affix</th
><th
align="left"
valign="top"
>Category</th
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>institute</langData
></td
><td
align="left"
valign="top"
>(none)</td
><td
align="left"
valign="top"
><object
type="category"
>verb</object
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>institution</langData
></td
><td
align="left"
valign="top"
>-<langData
lang="lEng"
>ion</langData
></td
><td
align="left"
valign="top"
><object
type="category"
>noun</object
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>institutional</langData
></td
><td
align="left"
valign="top"
>-<langData
lang="lEng"
>al</langData
></td
><td
align="left"
valign="top"
><object
type="category"
>adjective</object
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>institutionalize</langData
></td
><td
align="left"
valign="top"
>-<langData
lang="lEng"
>ize</langData
></td
><td
align="left"
valign="top"
><object
type="category"
>verb</object
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>institutionalization</langData
></td
><td
align="left"
valign="top"
>-<langData
lang="lEng"
>ation</langData
></td
><td
align="left"
valign="top"
><object
type="category"
>noun</object
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>institutionalizational</langData
></td
><td
align="left"
valign="top"
>-<langData
lang="lEng"
>al</langData
></td
><td
align="left"
valign="top"
><object
type="category"
>adjective</object
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>institutionalizationally</langData
></td
><td
align="left"
valign="top"
>-<langData
lang="lEng"
>ly</langData
></td
><td
align="left"
valign="top"
><object
type="category"
>adverb</object
></td
></tr
></table
></example
><p
>What do we have here? We have five derivational suffixes, each of which changes the major category of the resulting stem. Recall that these suffixes only go on stems of a certain category. For example, the ‑<langData
lang="lEng"
>al</langData
> suffix only goes on noun stems. It does not go on other stems (*<langData
lang="lEng"
>institutal</langData
>, *<langData
lang="lEng"
>institutionalal</langData
>, and *<langData
lang="lEng"
>quicklyal</langData
>). These affixes are summarized in <exampleRef
equal="no"
letterOnly="no"
num="xEnglishDerivationalAffixes"
></exampleRef
> below.</p
><example
num="xEnglishDerivationalAffixes"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Form</th
><th
align="left"
valign="top"
>“attaches to category”</th
><th
align="left"
valign="top"
>“changes to category”</th
><th
align="left"
valign="top"
>Gloss</th
></tr
><tr
><td
align="left"
valign="top"
>‑<langData
lang="lEng"
>ion</langData
></td
><td
align="left"
valign="top"
><object
type="category"
>verb</object
></td
><td
align="left"
valign="top"
><object
type="category"
>noun</object
></td
><td
align="left"
valign="top"
><langData
lang="lGloss"
>Nominalizer</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>‑<langData
lang="lEng"
>al</langData
></td
><td
align="left"
valign="top"
><object
type="category"
>noun</object
></td
><td
align="left"
valign="top"
><object
type="category"
>adjective</object
></td
><td
align="left"
valign="top"
><langData
lang="lGloss"
>Adjectivizer</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>‑<langData
lang="lEng"
>ize</langData
></td
><td
align="left"
valign="top"
><object
type="category"
>adjective</object
></td
><td
align="left"
valign="top"
><object
type="category"
>verb</object
></td
><td
align="left"
valign="top"
><langData
lang="lGloss"
>Verbalizer</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>‑<langData
lang="lEng"
>ation</langData
></td
><td
align="left"
valign="top"
><object
type="category"
>verb</object
></td
><td
align="left"
valign="top"
><object
type="category"
>noun</object
></td
><td
align="left"
valign="top"
><langData
lang="lGloss"
>Nominalizer2</langData
></td
></tr
><tr
><td
align="left"
valign="top"
>‑<langData
lang="lEng"
>ly</langData
></td
><td
align="left"
valign="top"
><object
type="category"
>adjective</object
></td
><td
align="left"
valign="top"
><object
type="category"
>adverb</object
></td
><td
align="left"
valign="top"
><langData
lang="lGloss"
>Adverbializer</langData
></td
></tr
></table
></example
><p
>How do we model these category changing affixes in <object
type="WordWorks"
></object
>? We need to do the following:</p
><example
num="xCatChangingHowTo"
><chart
type="HowTo"
><ol
><li
>Add each affix as a lexical entry and mark it as being derivational.</li
><li
>For the “attaches to category” piece of information, use the category of the stem to which this affix attaches (see section <sectionRef
sec="sDervAffixPOSConsiderations"
></sectionRef
> for more on this).</li
><li
>For the “changes to category” piece of information, use the category of the stem that results when this affix is attached (see section <sectionRef
sec="sDervAffixPOSConsiderations"
></sectionRef
> for more on this).</li
></ol
></chart
></example
></section4
><section4
id="sDervAffixSubCatChanging"
><secTitle
>Sub-category-changing Derivational Affixes</secTitle
><p
>Now consider the pairs of data in <exampleRef
equal="no"
letterOnly="no"
num="xTurkishWash"
></exampleRef
>-<exampleRef
equal="no"
letterOnly="no"
num="xTurkishSmoke"
></exampleRef
> from <indexedItem
term="iTurkish"
></indexedItem
>Turkish:<endnote
id="nTurkishLing115"
><p
>The data are from <citation
author="yes"
ref="rLing115"
></citation
>. The abbreviations used in the <indexedItem
term="iTurkish"
></indexedItem
>Turkish data are:</p
><table
border="1"
type="LessSpaceBeforeTable"
><tr
><th
align="left"
valign="top"
>Abbreviation</th
><th
align="left"
valign="top"
>Meaning</th
></tr
><tr
><td
align="left"
valign="top"
>Acct</td
><td
align="left"
valign="top"
>accusative</td
></tr
><tr
><td
align="left"
valign="top"
>Past</td
><td
align="left"
valign="top"
>past tense</td
></tr
><tr
><td
align="left"
valign="top"
>Pass</td
><td
align="left"
valign="top"
>passive</td
></tr
><tr
><td
align="left"
valign="top"
>Inf</td
><td
align="left"
valign="top"
>infinitive</td
></tr
><tr
><td
align="left"
valign="top"
>Dat</td
><td
align="left"
valign="top"
>dative</td
></tr
><tr
><td
align="left"
valign="top"
>Prog</td
><td
align="left"
valign="top"
>progressive</td
></tr
><tr
><td
align="left"
valign="top"
>3pl</td
><td
align="left"
valign="top"
>3rd person plural</td
></tr
><tr
><td
align="left"
valign="top"
>Pl</td
><td
align="left"
valign="top"
>plural</td
></tr
><tr
><td
align="left"
valign="top"
>Neg</td
><td
align="left"
valign="top"
>negative</td
></tr
></table
></endnote
><endnote
id="nTurkishLing115Note"
><p
>(I wish I had access to a more standard <indexedItem
term="iTurkish"
></indexedItem
>Turkish grammar to get examples, but this is the best I could find on the net. I also changed the glosses of two items per my Turkish Ample files which were based on Underhill's grammar.)</p
></endnote
></p
><example
num="xTurkishWash"
><listInterlinear
letter="xTurkishActiveWash"
><lineGroup
><line
><langData
lang="lTurkish"
>Çocuğu yıkadı</langData
></line
><line
><langData
lang="lTurkish"
>Çocuğ-u yıka-dı</langData
></line
><line
><gloss
lang="lGloss"
>child-Acc wash-Past</gloss
></line
></lineGroup
><free
>‘(S)he washed the child’</free
></listInterlinear
><listInterlinear
letter="xTurkishPassiveWash"
><lineGroup
><line
><langData
lang="lTurkish"
>Çocuk yıkandı</langData
></line
><line
><langData
lang="lTurkish"
>Çocuk yıka-n-dı</langData
></line
><line
><gloss
lang="lGloss"
>child wash-Pass-Past</gloss
></line
></lineGroup
><free
>‘The child was washed’</free
></listInterlinear
></example
><example
num="xTurkishWork"
><listInterlinear
letter="xTurkishActiveWork"
><lineGroup
><line
><langData
lang="lTurkish"
>Bu işi yapmaya başlıyorlar</langData
></line
><line
><langData
lang="lTurkish"
>Bu iş-i yap-ma-ya başl-ıyor-lar</langData
></line
><line
><gloss
lang="lGloss"
>this work-Acc do-Inf-Dat begin-Prog-3pl</gloss
></line
></lineGroup
><free
>‘They are beginning to do this work’</free
></listInterlinear
><listInterlinear
letter="xTurkishPassiveWork"
><lineGroup
><line
><langData
lang="lTurkish"
>Bu iş yapılmaya başlanıyor</langData
></line
><line
><langData
lang="lTurkish"
>Bu iş yap-ıl-ma-ya başla-n-ıyor</langData
></line
><line
><gloss
lang="lGloss"
>this work do-Pass-Inf-Dat begin-Pass-Prog</gloss
></line
></lineGroup
><free
>‘This work is beginning to be done’</free
></listInterlinear
></example
><example
num="xTurkishSmoke"
><listInterlinear
letter="xTurkishActiveSmoke"
><lineGroup
><line
><langData
lang="lTurkish"
>O adamlar sigara içiyor</langData
></line
><line
><langData
lang="lTurkish"
>O adam-lar sigara iç-iyor</langData
></line
><line
><gloss
lang="lGloss"
>Those man-Pl cigarette drink-Prog</gloss
></line
></lineGroup
><free
>‘Those men are smoking cigarettes’</free
></listInterlinear
><listInterlinear
letter="xTurkishPassiveSmoke"
><lineGroup
><line
><langData
lang="lTurkish"
>Sigara içilmez</langData
></line
><line
><langData
lang="lTurkish"
>Sigara iç-il-mez</langData
></line
><line
><gloss
lang="lGloss"
>cigarette(s) drink-Pass-Neg</gloss
></line
></lineGroup
><free
>‘Cigarettes are not smoked here’ (= no smoking)</free
></listInterlinear
></example
><p
>What is the key difference in each pair? It is the addition of the passive morpheme. Notice how the number of arguments changes from two (subject and object) to one (just subject) with the addition of the passive.</p
><p
><indexedItem
term="iDerivationCatChanging"
></indexedItem
><indexedItem
term="iCategoryChanging"
></indexedItem
>Is passive, then, a category changing derivational affix? While it does not change major category (i.e. it does not change a verb into a noun, say) it does change a transitive verb into an intransitive verb. That is, passive is a case where the sub-category is changed. Many languages have other such sub-category changing derivational affixes such as causatives, applicatives, and transitivizers. As far as <object
type="WordWorks"
></object
> is concerned, these are category changing derivational affixes since the result of the derivation produces a different sub-category that potentially requires a different inflectional template to complete the word form.</p
><p
>How do we model these sub-category changing affixes in <object
type="WordWorks"
></object
>? We need to do the following:</p
><example
num="xSubCatChangingHowTo"
><chart
type="HowTo"
><ol
><li
>Add each affix as a lexical entry and mark it as being derivational.</li
><li
>For the “attaches to category” piece of information, use the (sub-)category of the stem to which this affix attaches (see section <sectionRef
sec="sDervAffixPOSConsiderations"
></sectionRef
> for more on this).</li
><li
>For the “changes to category” piece of information, use the (sub-)category of the stem that results when this affix is attached (see section <sectionRef
sec="sDervAffixPOSConsiderations"
></sectionRef
> for more on this).</li
></ol
></chart
></example
></section4
><section4
id="sDervAffixNonCatChanging"
><secTitle
>Non-category-changing Derivational Affixes</secTitle
><p
>Now consider the following <indexedItem
term="iYalalagZapotec"
></indexedItem
>Yalálag Zapotec data:<endnote
id="nYalalagRepetitive"
><p
>The data are from <citation
author="yes"
ref="rYalalagVerbBook"
></citation
>. The abbreviations used in the <indexedItem
term="iYalalagZapotec"
></indexedItem
>Yalálag Zapotec data are:</p
><table
border="1"
type="LessSpaceBeforeTable"
><tr
><th
align="left"
valign="top"
>Abbreviation</th
><th
align="left"
valign="top"
>Meaning</th
></tr
><tr
><td
align="left"
valign="top"
>Fut</td
><td
align="left"
valign="top"
>future</td
></tr
><tr
><td
align="left"
valign="top"
>1PlIncl</td
><td
align="left"
valign="top"
>1st person plural inclusive pronominal clitic</td
></tr
><tr
><td
align="left"
valign="top"
>Rep</td
><td
align="left"
valign="top"
>repetitive</td
></tr
></table
><p
>The orthography used here is slightly different from what is used in <citation
author="yes"
ref="rYalalagVerbBook"
></citation
>. In particular, fortis consonants are preceded by a colon (<langData
lang="lYalalag"
>:</langData
>). Lenis consonants are not (and use the voiceless equivalent instead of the voiced one).</p
></endnote
></p
><example
num="xYalalagZapotecRepetitiveDrag"
><listInterlinear
letter="xYZRep9a"
><lineGroup
><line
><langData
lang="lYalalag"
>:xopcho</langData
></line
><line
><langData
lang="lYalalag"
>:-xop-cho</langData
></line
><line
><gloss
lang="lGloss"
>Fut-to.drag-1PlIncl</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xYZRep9b"
><lineGroup
><line
><langData
lang="lYalalag"
>waxopcho</langData
></line
><line
><langData
lang="lYalalag"
>w-a-xop-cho</langData
></line
><line
><gloss
lang="lGloss"
>Fut-Rep-to.drag-1PlIncl</gloss
></line
></lineGroup
></listInterlinear
></example
><example
num="xYalalagZapotecRepetitiveLaugh"
><listInterlinear
letter="xYZRep1a"
><lineGroup
><line
><langData
lang="lYalalag"
>uchi:chcho</langData
></line
><line
><langData
lang="lYalalag"
>u-chi:ch-cho</langData
></line
><line
><gloss
lang="lGloss"
>Fut-to.laugh-1PlIncl</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xYZRep1b"
><lineGroup
><line
><langData
lang="lYalalag"
>wachi:chcho</langData
></line
><line
><langData
lang="lYalalag"
>w-a-chi:ch-cho</langData
></line
><line
><gloss
lang="lGloss"
>Fut-Rep-to.laugh-1PlIncl</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>The addition of the repetitive prefix does not change either the major category or the sub-category of the words in <exampleRef
equal="no"
letterOnly="no"
num="xYalalagZapotecRepetitiveDrag"
></exampleRef
>-<exampleRef
equal="no"
letterOnly="no"
num="xYalalagZapotecRepetitiveLaugh"
></exampleRef
>. <indexedItem
term="iDerivationVsInflection"
></indexedItem
>One might wonder, then, if the repetitive in Yalálag Zapotec is actually an inflectional prefix. The evidence that it is derivational is that it actually changes the <indexedItem
term="iDerivationInflClass"
></indexedItem
><indexedItem
term="iInflectionClass"
></indexedItem
>inflection class of the resulting stem. As we saw in section <sectionRef
sec="sInflAffixInflectionClasses"
></sectionRef
>, Yalálag Zapotec verbs have two inflection classes. In <exampleRef
equal="no"
letter="xYZRep9a"
letterOnly="no"
></exampleRef
> the stem is inflection class 2 (because it takes the “fortifier” <langData
lang="lYalalag"
>:</langData
>‑ allomorph of the future prefix). After the <langData
lang="lYalalag"
>a</langData
>‑ repetitive prefix is added in <exampleRef
equal="no"
letter="xYZRep9b"
letterOnly="no"
></exampleRef
>, the resulting stem uses the inflection class 1 allomorph of future (<langData
lang="lYalalag"
>u/w</langData
>‑).</p
><p
>How do we model these non-category changing affixes in <object
type="WordWorks"
></object
>? We need to do the following:</p
><example
num="xNonCatChangingHowTo"
><chart
type="HowTo"
><ol
><li
>Add each affix as a lexical entry and mark it as being derivational.</li
><li
>For the “attaches to category” piece of information, use the category of the stem to which this affix attaches (see section <sectionRef
sec="sDervAffixPOSConsiderations"
></sectionRef
> for more on this).</li
><li
>For the “changes to category” piece of information, use the same category as for the “attaches to category”.</li
></ol
></chart
></example
><p
>Notice that in this case the from‑ and to‑ categories will be the same, but we do need to deal with the change in inflection class. This leads us to the next topic below.</p
></section4
><section4
id="sDervAffixInflectionClass"
><secTitle
>Inflection Class and Derivational Affixes</secTitle
><p
><indexedRangeBegin
id="bInflectionClassAndDerivation"
term="iDerivationInflClass"
></indexedRangeBegin
><indexedRangeBegin
id="bInflectionClassInDerivation"
term="iInflectionClass"
></indexedRangeBegin
>If the language you are studying has inflection classes (see section <sectionRef
sec="sInflAffixInflectionClasses"
></sectionRef
>), then what happens when derivational affixes are attached? Does the inflection class of the stem stay the same or does it change?</p
><section5
id="sDervAffixInflectionClassChange"
><secTitle
>Inflection Class May Change</secTitle
><p
>As we saw from the <indexedItem
term="iYalalagZapotec"
></indexedItem
>Yalálag Zapotec data in <sectionRef
sec="sDervAffixNonCatChanging"
></sectionRef
>, the inflection class can indeed change. How do we model this? In addition to what we've done for the categories, we need to do the following:</p
><example
num="xDervAffixInflectionClassChangeHowTo"
><chart
type="HowTo"
><ol
><li
>Also indicate the resulting inflection class in the “to inflection class” piece of information in the lexical entry for the appropriate affix.</li
></ol
></chart
></example
><p
>Note that rarely, if ever, does one need to indicate the “from inflection class” information. We include it in case you do find that you need it.</p
></section5
><section5
id="sDervAffixInflectionClassNoChange"
><secTitle
>Inflection Class Does Not Change</secTitle
><p
>There are cases, though, where a derivational affix is attached and it does not change the inflection class of the resulting stem. For example, consider the following data from <indexedItem
term="iAtzingoPopoloca"
></indexedItem
>Atzingo Popoloca:<endnote
id="nPopoloca"
><p
>Data are from <citation
author="yes"
ref="rDiccionarioPopoloca"
></citation
>. The abbreviations used in the <indexedItem
term="iAtzingoPopoloca"
></indexedItem
>Atzingo Popoloca data are:</p
><table
border="1"
type="LessSpaceBeforeTable"
><tr
><th
align="left"
valign="top"
>Abbreviation</th
><th
align="left"
valign="top"
>Meaning</th
></tr
><tr
><td
align="left"
valign="top"
>Pres</td
><td
align="left"
valign="top"
>present tense</td
></tr
><tr
><td
align="left"
valign="top"
>Apl</td
><td
align="left"
valign="top"
>applicative</td
></tr
><tr
><td
align="left"
valign="top"
>1aSgSubjAct</td
><td
align="left"
valign="top"
>1st person authority singular, active subject</td
></tr
></table
></endnote
></p
><example
num="xPopoloca1"
><listInterlinear
letter="xPopoloca1a"
><lineGroup
><line
><langData
lang="lPopoloca"
>tjanchia</langData
></line
><line
><langData
lang="lPopoloca"
>t-janchi-a</langData
></line
><line
><gloss
lang="lGloss"
>Pres-to.ask-1aSgSubjAct</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xPopoloca1b"
><lineGroup
><line
><langData
lang="lPopoloca"
>tjáncháhā</langData
></line
><line
><langData
lang="lPopoloca"
>t-jánchá-h-ā</langData
></line
><line
><gloss
lang="lGloss"
>Pres-to.ask-Apl-1aSgSubjAct</gloss
></line
></lineGroup
></listInterlinear
></example
><example
num="xPopoloca2"
><listInterlinear
letter="xPopoloca2a"
><lineGroup
><line
><langData
lang="lPopoloca"
>nínkaon</langData
></line
><line
><langData
lang="lPopoloca"
>0-nínkaon</langData
></line
><line
><gloss
lang="lGloss"
>Pres-to.get.angry</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xPopoloca2b"
><lineGroup
><line
><langData
lang="lPopoloca"
>nínkakonhen</langData
></line
><line
><langData
lang="lPopoloca"
>0-nínkakon-hen</langData
></line
><line
><gloss
lang="lGloss"
>Pres-to.get.angry-Apl</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>The applicative suffix <gloss
lang="lGloss"
>Apl</gloss
> adds an argument to the verb, but it does not change the inflection class of the resulting stem. The root in <exampleRef
equal="no"
letterOnly="no"
num="xPopoloca1"
></exampleRef
> belongs to inflection class 1 and so takes the <langData
lang="lPopoloca"
>t</langData
>‑ allomorph of the present tense morpheme. Adding the applicative does not change this <exampleRef
equal="no"
letter="xPopoloca1b"
letterOnly="no"
></exampleRef
>. Similarly, the root in <exampleRef
equal="no"
letterOnly="no"
num="xPopoloca2"
></exampleRef
> belongs to inflection class 2 and so takes a null allomorph of the present tense. Once again, adding the applicative does not change the inflection class of the resulting stem <exampleRef
equal="no"
letter="xPopoloca2b"
letterOnly="no"
></exampleRef
>.</p
><p
>To model this in <object
type="WordWorks"
></object
>, one does the following:</p
><example
num="xDervAffixInflectionClassNoChangeHowTo"
><chart
type="HowTo"
><ol
><li
>Merely leave the “to inflection class” information blank in the lexical entry for the appropriate affix.<indexedRangeEnd
begin="bInflectionClassInDerivation"
></indexedRangeEnd
><indexedRangeEnd
begin="bInflectionClassAndDerivation"
></indexedRangeEnd
></li
></ol
></chart
></example
></section5
></section4
><section4
id="sDervAffixInflectionFeatures"
><secTitle
>Inflection Features and Derivational Affixes</secTitle
><p
>If the language you are studying has <indexedItem
term="iInflectionFeature"
></indexedItem
><indexedItem
term="iDerivationInflFeature"
></indexedItem
>inflection features (see section <sectionRef
sec="sInflectionFeatures"
></sectionRef
>), then what happens when derivational affixes are attached to a stem with, say, <indexedItem
term="iInflFeatAgreement"
></indexedItem
>agreement features? Or what happens when a derivational affix <indexedItem
term="iDerivationCatChanging"
></indexedItem
><indexedItem
term="iCategoryChanging"
></indexedItem
>changes the category of the stem to a category that has agreement features? For example, consider the <indexedItem
term="iSpanish"
></indexedItem
>Spanish data in <exampleRef
equal="no"
letterOnly="no"
num="xSpanishDerivationGenderApretarApreton"
></exampleRef
> and <exampleRef
equal="no"
letterOnly="no"
num="xSpanishDerivationGenderTrasquilarTrasquilon"
></exampleRef
>:<endnote
id="nSpanishDerivation"
><p
>This data is taken from <citation
author="yes"
page="16"
ref="rVelazquezDictionary"
></citation
>.</p
></endnote
></p
><example
num="xSpanishDerivationGenderApretarApreton"
><listInterlinear
letter="xSpanishDerivationGenderApretar"
><lineGroup
><line
><langData
lang="lSpanish"
>apretar</langData
></line
><line
><langData
lang="lSpanish"
>apret-ar</langData
></line
><line
><gloss
lang="lGloss"
>to.press-Infinitive</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xSpanishDerivationGenderApreton"
><lineGroup
><line
><langData
lang="lSpanish"
>apretón</langData
></line
><line
><langData
lang="lSpanish"
>apret-ón</langData
></line
><line
><gloss
lang="lGloss"
>to.press-Nominalizer (= pressure)</gloss
></line
></lineGroup
></listInterlinear
></example
><example
num="xSpanishDerivationGenderTrasquilarTrasquilon"
><listInterlinear
letter="xSpanishDerivationGenderTrasquilar"
><lineGroup
><line
><langData
lang="lSpanish"
>trasquilar</langData
></line
><line
><langData
lang="lSpanish"
>traskil-ar</langData
></line
><line
><gloss
lang="lGloss"
>to.shear-Infinitive</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xSpanishDerivationGenderTrasquilon"
><lineGroup
><line
><langData
lang="lSpanish"
>trasquilón</langData
></line
><line
><langData
lang="lSpanish"
>traskil-ón</langData
></line
><line
><gloss
lang="lGloss"
>to.shear-Nominalizer (= clipping of wool)</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>Here we have a verb (e.g. <langData
lang="lSpanish"
>apretar</langData
>) and a noun derived from that verb (e.g. <langData
lang="lSpanish"
>apretón</langData
>). Recall from section <sectionRef
sec="sInflectionFeatures"
></sectionRef
> that Spanish nouns are marked for <indexedItem
term="iGender"
></indexedItem
>gender (masculine or feminine). While Spanish verbs are not marked for gender, a noun derived from a verb will have gender. In the case of the ‑<langData
lang="lSpanish"
>ón</langData
> derivational suffix, the resulting noun has masculine gender. To properly model this, we would need to indicate that the resulting noun has this gender.</p
><p
>How does one mark a derivational affix for inflection features in <object
type="WordWorks"
></object
>?<comment
>Note: this is repeated below in the xStemNamesHowTo example. Some of it is also repeated in the xInflectionFeaturesHowTo example above. </comment
></p
><example
num="xDerivAffixInflectionFeaturesHowTo"
><chart
type="HowTo"
><ol
><li
>Determine the inflection feature involved, including its <indexedItem
term="iInflFeatType"
></indexedItem
>type,<endnoteRef
note="nInflectionFeature"
></endnoteRef
> name, and possible values (this is repeated from <exampleRef
letter="xInflectionFeaturesHowTo"
num="xInflectionFeaturesHowTo"
></exampleRef
>) Note that you may also want to check with a linguistic consultant on this.<ol
><li
><indexedItem
term="iInflFeatCatalog"
></indexedItem
>Try using the Inflection Feature Catalog<endnoteRef
note="nInflectionFeatureCatalog"
></endnoteRef
> to see if the feature is already in the catalog. If so, add the feature via the catalog (it's much easier this way).</li
><li
>If the feature is not in the catalog, then<ol
><li
>If the feature type does not yet exist, add it to the feature types.</li
><li
>Create the feature and its values in the features section.</li
></ol
></li
></ol
></li
><li
><indexedItem
term="iCategoryInflectableFeatures"
></indexedItem
>For each category which will use the feature, add the feature to the category's set of inflectable features (if it's not already listed).</li
><li
>For each derivational affix needing a feature:<ol
><li
>If the derivational affix requires the stem to have such a feature, add the feature and its appropriate value to the derivational affix “From” features (under grammatical information details; you may need to Show Hidden Fields to see this).</li
><li
>If the stem that results from adding the derivational affix has such a feature, add the feature and its appropriate value to the derivational affix “To” features (under grammatical information details; you may need to Show Hidden Fields to see this).</li
></ol
></li
></ol
></chart
></example
></section4
><section4
id="sDervAffixPOSConsiderations"
><secTitle
>Category-changing Derivational Affixes and Category Organization</secTitle
><p
><indexedItem
term="iDerivationCatChanging"
></indexedItem
><indexedItem
term="iCategoryHierarchy"
></indexedItem
>As we noted in sections <sectionRef
sec="sInflAffixPOSConsiderations"
></sectionRef
> and <sectionRef
sec="sInflAffixInflectionClassesAndCategoryHierarchy"
></sectionRef
>, the categories in <object
type="WordWorks"
></object
> are organized in a hierarchical fashion.</p
><p
>The exact hierarchy one uses can make a difference for how the <object
type="WordWorks"
></object
> parser handles the categories of derivational affixes. When one indicates the “from category”, the <object
type="WordWorks"
></object
> parser will allow the derivational affix to apply to stems of this category and <object
type="InFocus"
>any of its nested categories</object
>. You may well need to keep this in mind as you design your category hierarchy.</p
><p
>You can use the hierarchy to capture some generalizations. For example, suppose your language has a nominalizing derivational affix that can attach to any verb stem, resulting in a noun stem. Further, suppose that the top-level <object
type="category"
>verb</object
> category has two sub-categories: <object
type="category"
>intransitive verb</object
> and <object
type="category"
>transitive verb</object
>. If you mark the “from category” as being <object
type="category"
>verb</object
>, then this affix can attach to a <object
type="category"
>verb</object
> stem, an <object
type="category"
>intransitive verb</object
> stem, or a <object
type="category"
>transitive verb</object
> stem.</p
><p
>Sometimes, however, the hierarchy implies that one will need to have more than one mapping for a given derivational affix. For example, one might need a causative to map as follows if the inflectional templates are different for <object
type="category"
>intransitive verb</object
>, <object
type="category"
>transitive verb</object
>, and <object
type="category"
>ditransitive verb</object
>:</p
><table
border="1"
type="leftOffset"
><tr
><th
align="left"
valign="top"
>“from category”</th
><th
align="left"
valign="top"
>“to category”</th
></tr
><tr
><td
align="left"
valign="top"
><object
type="category"
>intransitive verb</object
></td
><td
align="left"
valign="top"
><object
type="category"
>transitive verb</object
></td
></tr
><tr
><td
align="left"
valign="top"
><object
type="category"
>transitive verb</object
></td
><td
align="left"
valign="top"
><object
type="category"
>ditransitive verb</object
></td
></tr
><tr
><td
align="left"
valign="top"
><object
type="category"
>noun</object
></td
><td
align="left"
valign="top"
><object
type="category"
>transitive verb</object
></td
></tr
></table
><p
>To do this, you need to add a separate mapping for each possible from/to pair. You do that by adding distinct senses and associating each sense with the appropriate mapping.</p
><p
>If a derivational affix only changes meaning (i.e. it does not change the category or the sub-category), then one can use the highest level category for both the “from category” and the “to category”. In this case, the <object
type="WordWorks"
></object
> parser will pass on the (sub-)category of the stem to which the derivational affix attaches as the resulting category of the new stem. For example, if one chooses to model an adverbial affix on a verb as being derivational, then if one marks both the “from category” and the “to category” as "verb," then when this affix attaches to an intransitive verb, the resulting stem will still be intransitive. If it attaches to a transitive verb, then the resulting stem will still be transitive.</p
></section4
><section4
id="sDervAffixUnderspecified"
><secTitle
>Underspecified Derivational Affixes</secTitle
><p
><indexedItem
main="yes"
term="iDerivAffixUnderspecified"
></indexedItem
><indexedItem
term="iAffixUnderSpecified"
></indexedItem
>In the above, we discussed how one can fully specify derivational affixes. Sometimes it is the case, though, that you are confident that a particular affix is derivational, but you just do not yet know the category it goes on or the resulting category after it attaches. Or it might be the case that you know either the category it attaches to or the category it results in, but not both.</p
><p
><object
type="WordWorks"
></object
> allows you to model what you know. That is, you can still label such an affix as being derivational, but only partially specify the rest of the information about it. If you know the category it attaches to, but not the resulting category, you can say so. If you know the category it results in, but not the category it attaches to, you can say so. Be advised, though, that when you specify the category it attaches to, but not what the resulting category is, the <object
type="WordWorks"
></object
> parser will treat such an underspecified derivational affix just like it does an “<indexedItem
term="iAffixUnclassified"
></indexedItem
>unclassified” affix (see section <sectionRef
sec="sUnclassifiedAffixes"
></sectionRef
>). If, on the other hand, you do not say what category it attaches to, but do say what the resulting category is, the <object
type="WordWorks"
></object
> parser will treat it as if you had said that the derivational affix can go on every category.</p
></section4
></section3
><section3
id="sDerivationOutsideIinflection"
><secTitle
>Derivation Outside of Inflection</secTitle
><p
><indexedItem
term="iDerivOutsideInflection"
></indexedItem
>Derivational affixation tends to be close to the root. Since derivation sometimes changes the category of a stem, this is not surprising. Derivational affixes, then, normally occur inside of inflectional ones.</p
><p
>However, there are cases in some languages where a stem will be inflected, then a category changing derivational affix will be attached and the resulting stem will be inflected.</p
><p
>The <indexedItem
term="iHuallagaQuechua"
></indexedItem
>Quechua example we saw in <exampleRef
equal="no"
letterOnly="no"
num="xQuechua"
></exampleRef
> is such a case. It is repeated below in <exampleRef
equal="no"
letterOnly="no"
num="xQuechua2"
></exampleRef
>.<endnoteRef
note="nQuechua"
></endnoteRef
></p
><example
num="xQuechua2"
><interlinear
><lineGroup
><line
><wrd
><langData
lang="lQuechua"
>rikaykaamaanaykipaq</langData
></wrd
><wrd
><exampleRef
equal="yes"
letterOnly="no"
num="xQuechua"
></exampleRef
></wrd
></line
><line
><wrd
><langData
lang="lQuechua"
>rika-yka:-ma:-na-yki-paq</langData
></wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>to.see-Imp-1Obj-Nom-2Pos-Pur</gloss
></wrd
></line
></lineGroup
><free
>‘in order that you might be seeing me’</free
></interlinear
></example
><p
>At least under one analysis, the verb root meaning ‘to see’ has the imperfective aspect marker added, followed by the first person object marker, yielding ‘to see me.’ We thus have a verb stem inflected with an aspect and an object marker. To this inflected form, the nominalizer derivational affix is attached, resulting in a noun meaning ‘seeing me.’ The noun form then has the second person possessive marker and the purpose marker added, finally giving ‘in order that you might be seeing me.’ That is, the resulting noun stem is now inflected by a possessive and a (kind of) case marker. We could diagram this process as in <exampleRef
equal="no"
letterOnly="no"
num="xQuechuaWordTree"
></exampleRef
>.</p
><example
num="xQuechuaWordTree"
><tree
><img
src="rikaykaamaanaykipaq.png"
></img
></tree
></example
><p
>In <exampleRef
equal="no"
letterOnly="no"
num="xQuechuaWordTree"
></exampleRef
> the <object
type="TreeNT"
>Infl</object
> nodes represent inflected forms. Note how the derivational suffix ‑<langData
lang="lQuechua"
>na</langData
> changes the inflected verb into a noun stem (<object
type="TreeNT"
>Stem[n]</object
>). This stem is then inflected.</p
><p
>It turns out that while the <object
type="TreeNT"
>Infl[n]</object
> node is a fully inflected noun, the <object
type="TreeNT"
>Infl[v]</object
> is actually only a partially inflected verb: It lacks a required subject suffix. That is, a form such as <langData
lang="lQuechua"
>rikaykaamaa</langData
> with the analysis of <gloss
lang="lGloss"
>to.see‑Imp‑1Obj</gloss
> is ill-formed. Thus, the verbal <indexedItem
term="iInflectionalTemplate"
></indexedItem
>inflectional template given in <exampleRef
equal="no"
letterOnly="no"
num="xQuechuaNonfinalInflTemplate"
></exampleRef
> is a special kind of template. It does not represent a fully inflected form. Rather, it requires that there be a derivational affix attached outside of the template in order for the word to be well-formed. When you have such templates, you will need to mark them as requiring additional derivation. The default situation is for the <object
type="WordWorks"
></object
> to assume that an inflectional template does not require additional derivation outside of the template.</p
><example
num="xQuechuaNonfinalInflTemplate"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Stem</th
><th
align="left"
valign="top"
>Aspect</th
><th
align="left"
valign="top"
>Object</th
></tr
><tr
><td
> </td
><td
align="left"
valign="top"
> </td
><td
align="left"
valign="top"
> </td
></tr
></table
></example
><p
>How does one handle such derivation outside of inflection in <object
type="WordWorks"
></object
>? One needs to perform the following steps:</p
><example
num="xDerviationOutsideInflectionHowTo"
><chart
type="HowTo"
><ol
><li
>Add all the inflectional and derivational affix entries.</li
><li
>Create the "inside" inflectional template and mark it specially as a template that requires additional derivation. Please note that this template <object
type="Bold"
>must</object
> have at least one slot that is required. If all of the slots are marked as being optional, the <object
type="WordWorks"
></object
> parser will arbitrarily treat them as if they are all required. The reason is that when all slots are optional, the implication is that the template is not needed. It also results in invalid instructions for the parser.</li
><li
>Create the "outside" inflectional template.</li
></ol
></chart
></example
></section3
><section3
id="sDerivationVsInflection"
><secTitle
>Derivation versus Inflection</secTitle
><p
><indexedItem
main="yes"
term="iDerivationVsInflection"
></indexedItem
>Determining if a given affix is derivational or inflectional can sometimes be quite a challenge. Arguably, the range from derivational to inflectional is a continuum and there are some affixes which seem to “float” somewhere in the middle. Nonetheless, there are recognized criteria one can use to try and help one figure out which kind a given affix might be. These are not hard and fast rules, however.</p
><p
>Albert Bickford offers the following guidelines in helping one to decide (taken from <citation
author="yes"
page="139"
paren="none"
ref="rBickford"
></citation
>, including the note on productivity).</p
><example
num="xDerivationVsInflection"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Characteristic</th
><th
align="left"
valign="top"
>Inflectional</th
><th
align="left"
valign="top"
>Derivational</th
></tr
><tr
><td
align="left"
valign="top"
>Changes one lexical entry into another</td
><td
align="left"
valign="top"
>no</td
><td
align="left"
valign="top"
>yes</td
></tr
><tr
><td
align="left"
valign="top"
>Changes syntactic category</td
><td
align="left"
valign="top"
>no</td
><td
align="left"
valign="top"
>often</td
></tr
><tr
><td
align="left"
valign="top"
>Productivity</td
><td
align="left"
valign="top"
>virtually total<endnote
id="nBickfordProductivity"
><p
>Although some words may be inflected irregularly, they will almost always have some form for every position in the inflectional paradigm. On rare occasions, there may be words whose paradigms are defective, or missing certain forms, such as English <langData
lang="lEng"
>troops</langData
> ‘<gloss
lang="lGloss"
>soldiers</gloss
>’, a noun which has only a plural form with no singular.</p
></endnote
></td
><td
align="left"
valign="top"
>partial at best</td
></tr
><tr
><td
align="left"
valign="top"
>Organized in paradigms</td
><td
align="left"
valign="top"
>yes</td
><td
align="left"
valign="top"
>no</td
></tr
><tr
><td
align="left"
valign="top"
>Distance from root</td
><td
align="left"
valign="top"
>farther</td
><td
align="left"
valign="top"
>closer</td
></tr
><tr
><td
align="left"
valign="top"
>Type of meaning</td
><td
align="left"
valign="top"
>grammatical</td
><td
align="left"
valign="top"
>usually lexical</td
></tr
><tr
><td
align="left"
valign="top"
>Meaning predictable from parts<endnote
id="nConventionalizedSemantics"
><p
><citation
author="yes"
page="138"
ref="rBickford"
></citation
> uses the term “Conventionalized semantics” and explains this term as follows:</p
><blockquote
>In semantics, when the meaning of the whole is not fully predictable from the meaning of its parts, we say that the meaning is conventionalized. One characteristic of derivational morphology is that its meaning is often conventionalized, while the meaning of inflectional morphology is almost always fully predictable.</blockquote
><pc
>Here in this table, I've chosen to use “meaning predictable from parts” instead in order to avoid a double negative.</pc
></endnote
></td
><td
align="left"
valign="top"
>usually yes</td
><td
align="left"
valign="top"
>often not</td
></tr
><tr
><td
align="left"
valign="top"
>Relevant to syntax</td
><td
align="left"
valign="top"
>yes</td
><td
align="left"
valign="top"
>no<indexedRangeEnd
begin="bDerivationalAffix"
></indexedRangeEnd
><indexedRangeEnd
begin="bDerivation"
></indexedRangeEnd
></td
></tr
></table
></example
><p
>Tom Payne also has some suggestions about characteristics of derivational affixes. The following quote is taken from <citation
page="42"
ref="rTPayne1997"
></citation
>:</p
><blockquote
>According to Bybee (1985) derivational operations tend to be more RELEVANT to the situation expressed in the root than do inflectional operations. Derivational operations consist primarily of the following: <ol
><li
>Operations that change the grammatical category of a root, e.g., denominalization (changing a noun into some other category) and nominalization (changing a form of any grammatical category into a noun...).</li
><li
>Operations that change the valence (transitivity) of a verb root, e.g., detransitivization, causativization and desiderative...</li
><li
>Operations which in other ways significantly change the basic concept expressed by the root, e.g., distributive, diminutive...</li
></ol
><p
>Characteristics of derivational operations include:</p
><ol
><li
>They are 'non-obligatory' insofar as they are employed in order to adjust the basic semantic content of roots and are not themselves determined by some other operation or element in the syntactic structure.</li
><li
>They tend to be idiosyncratic and non-productive.</li
><li
>They tend not to occur in well-defined paradigms.</li
></ol
></blockquote
></section3
><section3
id="sProductivityRestrictions"
><secTitle
>Exception “Features”</secTitle
><p
><indexedItem
term="iExceptionFeatures"
></indexedItem
>Even when one has correctly classified the affixes in a language as being derivational or inflectional, sometimes a morphological parser will find combinations of stem and affix that are simply incorrect. This may be due to historical or some other seemingly arbitrary reasons.</p
><p
>For example, consider the following <indexedItem
term="iOrizabaNahuatl"
></indexedItem
>Orizaba Nahuatl data:</p
><example
num="xOrizabaDerivTl"
><table
border="1"
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>nitlakuika</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>ni-tlakuika</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>1SgSubj-to.sing</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘I sing’</gloss
></td
></tr
></table
></td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>tlakuikatl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>tlakuika-tl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>to.sing-Abs</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘song’</gloss
></td
></tr
></table
></td
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>kiavi</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>kiavi</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>to.rain</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘it rains’</gloss
></td
></tr
></table
></td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>kiavitl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>kiavi-tl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>to.rain-Abs</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘rain’</gloss
></td
></tr
></table
></td
></tr
></table
></example
><p
>Notice that in this data, the “Absolutive” suffix (which normally goes on singular, unpossessed nouns) appears to derive a noun from a verb. When one models this, one may find that other nouns which have the absolutive suffix now analyze as derived nouns. For example, one might get these:</p
><example
num="xOrizabaDerivTlBad"
><table
border="1"
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>komitl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>kom-itl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>jug-Abs</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘jug’</gloss
></td
></tr
></table
></td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>komitl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>*kom-i-tl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>*jug-to.drink-Abs</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
> </gloss
></td
></tr
></table
></td
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>kakavatl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>kakava-tl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>peanut-Abs</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘peanut’</gloss
></td
></tr
></table
></td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>kakavatl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>*ka-kava-tl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>*Redup-to.leave-Abs</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
> </gloss
></td
></tr
></table
></td
></tr
></table
></example
><p
>The <object
type="WordWorks"
></object
> parser allows one to rule out such incorrect combinations via what have sometimes been called exception “features.”<endnote
id="nExceptionFeatureDefn"
><p
>The way we have implemented these in <object
type="WordWorks"
></object
> is to create a separate list for these objects. Technically, these are not true features. Internally, we are calling these “<indexedItem
term="iAffixNonproductive"
></indexedItem
>productivity restrictions” because they restrict the productivity of an affix. Another way of looking at them is as restricting the distribution of an affix.</p
></endnote
> The basic idea is to tag the affix with an exception “feature.”  The only time the <object
type="WordWorks"
></object
> parser will then allow this affix to occur is when the stem to which it attaches also has been tagged with the same exception “feature.” Thus you can restrict the <indexedItem
term="iAffixNonproductive"
></indexedItem
>productivity of the affix to only occur on certain stems. Note that this is only possible for affixes which have been fully classified as either being derivational or inflectional. Exception “features” are not available for <indexedItem
term="iAffixUnclassified"
></indexedItem
>unclassified affixes.</p
><p
>If a given affix has two or more exception “features,” then the stem to which it attaches must be tagged with all of the exception “features” that the affix has. Note that if an affix does not have any exception “features” but the stem to which it is being attached does have one or more exception “features,”  then the affix will still be allowed to attach (as far as the exception “features” are concerned).</p
><p
>To tag affixes and stems with exception “features,”  do the following:</p
><example
num="xExceptionFeaturesHowTo"
><chart
type="HowTo"
><ol
><li
>If necessary, create the exception “feature.” We recommend you give as meaningful a description as you are able. For example, if you happen to know that there are historical reasons for this situation, then go ahead and say what they are.</li
><li
>Tag the affix with that exception “feature” (in the from exception "feature" field).</li
><li
>For each root or stem to which the affix may attach, tag the root with the exception “feature.<indexedRangeEnd
begin="bAffixes"
></indexedRangeEnd
>”</li
></ol
></chart
></example
></section3
></section2
><section2
id="sCompounding"
><secTitle
>Stem Compounding</secTitle
><p
><indexedRangeBegin
id="bCompounding"
main="yes"
term="iCompounding"
></indexedRangeBegin
>This section relates to the compounding of two or more stems within a single orthographic word.<endnote
id="nMultiWordCopounds"
><p
><indexedItem
term="iCompounding"
></indexedItem
>Compounds involving more than one orthographic word (e.g. <langData
lang="lEng"
>student film society</langData
>) are not dealt with here since they are properly outside the realm of morphology.</p
></endnote
></p
><p
>There are two basic kinds of compounds: headed compounds (section <sectionRef
sec="sCompoundsEndocentric"
></sectionRef
>) and non-headed compounds (section <sectionRef
sec="sCompoundsExocentric"
></sectionRef
>). We also discuss issues relating to incorporation (section <sectionRef
sec="sCompoundIncorporation"
></sectionRef
>), issues relating to compounding when stems contain affixes (section <sectionRef
sec="sCompoundInterfixes"
></sectionRef
>), and issues relating to the organization of categories (section <sectionRef
sec="sCompoundPOS"
></sectionRef
>).</p
><section3
id="sCompoundsEndocentric"
><secTitle
>Headed Compounds</secTitle
><p
><indexedItem
main="yes"
term="iCompHeaded"
></indexedItem
>Consider the following <indexedItem
term="iOrizabaNahuatl"
></indexedItem
>Orizaba Nahuatl data:<endnote
id="nNahuatlCompounds"
><p
>The data are taken from <citation
author="yes"
page="76-77"
ref="rTuggyCurso"
></citation
>. The abbreviations used in the <indexedItem
term="iOrizabaNahuatl"
></indexedItem
>Nahuatl data are:</p
><table
border="1"
type="LessSpaceBeforeTable"
><tr
><th
align="left"
valign="top"
>Abbreviation</th
><th
align="left"
valign="top"
>Meaning</th
></tr
><tr
><td
align="left"
valign="top"
>Adj</td
><td
align="left"
valign="top"
>adjectival ending</td
></tr
><tr
><td
align="left"
valign="top"
>Abs</td
><td
align="left"
valign="top"
>absolutive</td
></tr
><tr
><td
align="left"
valign="top"
>1SgPoss</td
><td
align="left"
valign="top"
>1st person singular possessive</td
></tr
></table
></endnote
></p
><example
num="xNahuatlCompoundAdjNoun"
><table
border="1"
><tr
><th
align="left"
valign="top"
><object
type="category"
>adjective</object
></th
><th
align="left"
valign="top"
><object
type="category"
>noun</object
></th
><th
align="left"
valign="top"
>Compound</th
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>tliltik</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>tlil-tik</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>black-Adj</gloss
></td
></tr
></table
></td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>kowatl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>kowa-tl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>snake-Abs</gloss
></td
></tr
></table
></td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>tlilkowatl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>tlil-kowa-tl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>black-snake-Abs</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘black snake’</gloss
></td
></tr
></table
></td
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>weyi</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>weyi</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>big</gloss
></td
></tr
></table
></td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>atl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>a-tl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>water-Abs</gloss
></td
></tr
></table
></td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>weyatl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>wey-a-tl</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>big-water-Abs</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘river’</gloss
></td
></tr
></table
></td
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>weyi</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>weyi</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>big</gloss
></td
></tr
></table
></td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>ohtli</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>oh-tli</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>road-Abs</gloss
></td
></tr
></table
></td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>wéyohtli</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>wéy-oh-tli</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>big-road-Abs</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘highway’</gloss
></td
></tr
></table
></td
></tr
></table
></example
><p
>What are the categories of the two members of the compound? The left one is an adjective and the right one is a noun. What is the category of the compound? It is a noun. Thus the examples in <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlCompoundAdjNoun"
></exampleRef
> show an adjective compounding with a noun where the result is the right member of the compound. Thus, we can say that the “head” of the compound is the right member of the compound.</p
><p
>Now consider the following Orizaba Nahuatl data:</p
><example
num="xNahuatlCompoundNounAdj"
><table
border="1"
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>tlaxkálsolli</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>tlaxkál-sol-li</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>tortilla-old-Abs</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘tortilla from the day before’</gloss
></td
></tr
></table
></td
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>nomahpilweyi</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>no-mah-pil-weyi</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>1SgPoss-hand-projection-big</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‘my thumb’</gloss
></td
></tr
></table
></td
></tr
></table
></example
><p
>In <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlCompoundNounAdj"
></exampleRef
> the left member is a noun and the rightmost member is an adjective. Like in <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlCompoundAdjNoun"
></exampleRef
>, the result is a noun. Thus the “head” of the compound is the left member in the cases in <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlCompoundNounAdj"
></exampleRef
>.</p
><p
>Both of these are instances of headed compounds. Either the left or the right member of the compound is the head of the compound. That is, the category of the resulting compound is the same as either the left or the right member of the compound.</p
><p
>How do we model these kinds of rules for <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
>?</p
><example
num="xCompoundEndoHowTo"
><chart
type="HowTo"
><ol
><li
>Create a headed compound rule.</li
><li
>Indicate what the left member's category is.</li
><li
>Indicate what the right member's category is.</li
><li
>Indicate whether the resulting compound is left-headed or right-headed.</li
></ol
></chart
></example
></section3
><section3
id="sCompoundsExocentric"
><secTitle
>Non-headed Compounds</secTitle
><p
><indexedItem
term="iCompNonheaded"
></indexedItem
>Now consider the following <indexedItem
term="iSpanish"
></indexedItem
>Spanish data:</p
><example
num="xSpanishExoCompounds"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Word</th
><th
align="left"
valign="top"
>Meaning</th
><th
align="left"
valign="top"
>Source</th
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lSpanish"
>paracaidas</langData
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>parachute (masculine; ambiguous for number)</gloss
></td
><td
align="left"
valign="top"
>from the third person singular present indicative verb <langData
lang="lSpanish"
>para</langData
> ‘<gloss
lang="lGloss"
>stops</gloss
>’ and the feminine plural noun <langData
lang="lSpanish"
>caidas</langData
>  ‘<gloss
lang="lGloss"
>falls</gloss
>’</td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lSpanish"
>sacamuelas</langData
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>dentist (masculine or feminine; singular)</gloss
></td
><td
align="left"
valign="top"
>from the third person singular present indicative verb <langData
lang="lSpanish"
>saca</langData
> ‘<gloss
lang="lGloss"
>removes</gloss
>’ and the feminine plural noun <langData
lang="lSpanish"
>muelas</langData
>  ‘<gloss
lang="lGloss"
>teeth</gloss
>’</td
></tr
></table
></example
><p
>Which member of the compound is the head? Clearly it is not the left member since the resulting compound in both cases is a noun and the left member is a verb. But is the head really the right member of the compound? While the right member is a noun, this noun is not inflected for the correct gender and/or number. Thus, these examples show the need for the other kind of compound rule: non-headed compounds. In non-headed compounds, the category and/or agreement features of the resulting stem are not merely the same as the head. Instead, the new stem may be something different.</p
><p
>To model this in <object
type="WordWorks"
></object
>, we do the following:</p
><example
num="xCompoundExoHowTo"
><chart
type="HowTo"
><ol
><li
>Create a non-headed compound rule.</li
><li
>Indicate what the left member's category is.</li
><li
>Indicate what the right member's category is.</li
><li
>Indicate what the category of the resulting compound is.</li
><li
>If the language you are modeling has inflection classes (see <sectionRef
sec="sInflAffixInflectionClasses"
></sectionRef
>) and the resulting category has inflection classes, then also indicate the inflection class of the resulting category.</li
></ol
></chart
></example
></section3
><section3
id="sCompoundIncorporation"
><secTitle
>Incorporation</secTitle
><p
><indexedRangeBegin
id="bIncorporation"
term="iCompIncorporation"
></indexedRangeBegin
>Some languages allow the incorporation of lexical roots within the stem. The resulting stem may or may not differ from the non-incorporated stem in terms of category and/or features. This means that if the language you are modeling has incorporation, you will need to consider whether to use a headed or a non-headed compound rule for it.</p
><section4
id="sCompoundIncorporationEndo"
><secTitle
>Incorporation as a Simple Headed Compound</secTitle
><p
><indexedItem
term="iCompHeaded"
></indexedItem
>Consider the following <indexedItem
term="iYalalagZapotec"
></indexedItem
>Yalálag Zapotec data:<endnote
id="nYalalagAdverb"
><p
>The data are from <citation
author="yes"
ref="rYalalagVerbBook"
></citation
>. The abbreviations used in the <indexedItem
term="iYalalagZapotec"
></indexedItem
>Yalálag Zapotec data are:</p
><table
border="1"
type="LessSpaceBeforeTable"
><tr
><th
align="left"
valign="top"
>Abbreviation</th
><th
align="left"
valign="top"
>Meaning</th
></tr
><tr
><td
align="left"
valign="top"
>S</td
><td
align="left"
valign="top"
>stative</td
></tr
><tr
><td
align="left"
valign="top"
>3fam</td
><td
align="left"
valign="top"
>3rd person familiar pronominal clitic</td
></tr
><tr
><td
align="left"
valign="top"
>Pres</td
><td
align="left"
valign="top"
>present</td
></tr
><tr
><td
align="left"
valign="top"
>3resp</td
><td
align="left"
valign="top"
>3rd person respect pronominal clitic</td
></tr
></table
><p
>The orthography used here is slightly different from what is used in <citation
author="yes"
ref="rYalalagVerbBook"
></citation
>. In particular, fortis consonants are preceded by a colon (<langData
lang="lYalalag"
>:</langData
>). Lenis consonants are not (and use the voiceless equivalent instead of the voiced one).</p
></endnote
></p
><example
num="xYalalagAdverbIncorp1"
><listInterlinear
letter="xYalalagAdverbIncorp1a"
><lineGroup
><line
><wrd
><langData
lang="lYalalag"
>sejpe'</langData
></wrd
></line
><line
><wrd
lang="lYalalag"
>s-ej-pe'</wrd
></line
><line
><wrd
lang="lGloss"
>S-to.go-3fam</wrd
></line
></lineGroup
><free
>He left.</free
></listInterlinear
><listInterlinear
letter="xYalalagAdverbIncorp1b"
><lineGroup
><line
><wrd
><langData
lang="lYalalag"
>sejtope'</langData
></wrd
></line
><line
><wrd
lang="lYalalag"
>s-ej-<object
type="InFocus"
>to</object
>-pe'</wrd
></line
><line
><wrd
lang="lGloss"
>S-to.go-<object
type="InFocus"
>rapidly</object
>-3fam</wrd
></line
></lineGroup
><free
>He left quickly.</free
></listInterlinear
></example
><example
num="xYalalagAdverbIncorp2"
><listInterlinear
letter="xYalalagAdverbIncorp2a"
><lineGroup
><line
><wrd
lang="lYalalag"
>chpipe'</wrd
></line
><line
><wrd
lang="lYalalag"
>ch-pip-e'</wrd
></line
><line
><wrd
lang="lGloss"
>Pres-to.bite-3resp</wrd
></line
></lineGroup
><free
>He bites.</free
></listInterlinear
><listInterlinear
letter="xYalalagAdverbIncorp2b"
><lineGroup
><line
><wrd
><langData
lang="lYalalag"
>chpip:cha:che'</langData
></wrd
></line
><line
><wrd
lang="lYalalag"
>ch-pip-<object
type="InFocus"
>:cha:ch</object
>-e'</wrd
></line
><line
><wrd
lang="lGloss"
>Pres-to.bite-<object
type="InFocus"
>repeatedly</object
>-3resp</wrd
></line
></lineGroup
><free
>He bites repeatedly.</free
></listInterlinear
></example
><p
>At least under one analysis, in <exampleRef
equal="no"
letter="xYalalagAdverbIncorp1b"
letterOnly="no"
></exampleRef
> the adverb <langData
lang="lYalalag"
>to</langData
> is incorporated onto the verb <langData
lang="lYalalag"
>ej</langData
>. In <exampleRef
equal="no"
letter="xYalalagAdverbIncorp2b"
letterOnly="no"
></exampleRef
>, a different adverb, <langData
lang="lYalalag"
>:cha:ch</langData
>, is incorporated.</p
><p
>Notice that the resulting stem appears to have all of the characteristics of the verbal stem which is the left member of the compound as indicated by <exampleRef
equal="no"
letter="xYalalagAdverbIncorp1a"
letterOnly="no"
></exampleRef
> and <exampleRef
equal="no"
letter="xYalalagAdverbIncorp2a"
letterOnly="no"
></exampleRef
>. Therefore, this kind of data can be modeled as a left-headed compound rule.</p
></section4
><section4
id="sCompoundIncorporationEndoOverride"
><secTitle
>Incorporation as a Headed Compound with Override</secTitle
><p
><indexedItem
term="iCompHeaded"
></indexedItem
>Now consider the following <indexedItem
term="iOrizabaNahuatl"
></indexedItem
>Orizaba Nahuatl data:<endnote
id="nNahuatlObjectIncorp"
><p
>Data are from <citation
author="yes"
page="77-8"
ref="rTuggyCurso"
></citation
>. The abbreviations used in the <indexedItem
term="iOrizabaNahuatl"
></indexedItem
>Nahuatl data are:</p
><table
border="1"
type="LessSpaceBeforeTable"
><tr
><th
align="left"
valign="top"
>Abbreviation</th
><th
align="left"
valign="top"
>Meaning</th
></tr
><tr
><td
align="left"
valign="top"
>Abs</td
><td
align="left"
valign="top"
>absolutive</td
></tr
><tr
><td
align="left"
valign="top"
>1SgSubj</td
><td
align="left"
valign="top"
>1st person singular subject</td
></tr
><tr
><td
align="left"
valign="top"
>3Obj</td
><td
align="left"
valign="top"
>3rd person object</td
></tr
></table
></endnote
></p
><example
num="xNahuatlNounIncorporation1"
><listInterlinear
letter="xNahuatlNounIncorporation1a"
><lineGroup
><line
><langData
lang="lNahuatl"
>pahtli</langData
></line
><line
><langData
lang="lNahuatl"
>pah-tli</langData
></line
><line
><gloss
lang="lGloss"
>medicine-Abs</gloss
></line
></lineGroup
><free
>‘medicine’</free
></listInterlinear
><listInterlinear
letter="xNahuatlNounIncorporation1b"
><lineGroup
><line
><langData
lang="lNahuatl"
>niktolova</langData
></line
><line
><langData
lang="lNahuatl"
>ni-k-tolova</langData
></line
><line
><gloss
lang="lGloss"
>1SgSubj-3Obj-to.swallow</gloss
></line
></lineGroup
><free
>‘I swallow it’</free
></listInterlinear
><listInterlinear
letter="xNahuatlNounIncorporation1c"
><lineGroup
><line
><wrd
><langData
lang="lNahuatl"
>nipahtolova</langData
></wrd
></line
><line
><wrd
lang="lNahuatl"
>ni-<object
type="InFocus"
>pah</object
>-tolova</wrd
></line
><line
><wrd
lang="lGloss"
>1SgSubj-<object
type="InFocus"
>medicine</object
>-to.swallow</wrd
></line
></lineGroup
><free
>‘I medicine-swallow’</free
></listInterlinear
></example
><example
num="xNahuatlNounIncorporation2"
><listInterlinear
letter="xNahuatlNounIncorporation2a"
><lineGroup
><line
><langData
lang="lNahuatl"
>nakatl</langData
></line
><line
><langData
lang="lNahuatl"
>naka-tl</langData
></line
><line
><gloss
lang="lGloss"
>meat-Abs</gloss
></line
></lineGroup
><free
>‘meat’</free
></listInterlinear
><listInterlinear
letter="xNahuatlNounIncorporation2b"
><lineGroup
><line
><langData
lang="lNahuatl"
>nikkua</langData
></line
><line
><langData
lang="lNahuatl"
>ni-k-kua</langData
></line
><line
><gloss
lang="lGloss"
>1SgSubj-3Obj-to.eat</gloss
></line
></lineGroup
><free
>‘I eat it’</free
></listInterlinear
><listInterlinear
letter="xNahuatlNounIncorporation2c"
><lineGroup
><line
><wrd
><langData
lang="lNahuatl"
>ninakakua</langData
></wrd
></line
><line
><wrd
lang="lNahuatl"
>ni-<object
type="InFocus"
>naka</object
>-kua</wrd
></line
><line
><wrd
lang="lGloss"
>1SgSubj-<object
type="InFocus"
>meat</object
>-to.eat</wrd
></line
></lineGroup
><free
>‘I meat-eat’</free
></listInterlinear
></example
><p
>What is happening here? Notice how the nouns in <exampleRef
equal="no"
letter="xNahuatlNounIncorporation1a"
letterOnly="no"
></exampleRef
> and <exampleRef
equal="no"
letter="xNahuatlNounIncorporation2a"
letterOnly="no"
></exampleRef
> replace the <gloss
lang="lGloss"
>3Obj</gloss
> marker in <exampleRef
equal="no"
letter="xNahuatlNounIncorporation1b"
letterOnly="no"
></exampleRef
> and <exampleRef
equal="no"
letter="xNahuatlNounIncorporation2b"
letterOnly="no"
></exampleRef
> to produce the forms in <exampleRef
equal="no"
letter="xNahuatlNounIncorporation1c"
letterOnly="no"
></exampleRef
> and <exampleRef
equal="no"
letter="xNahuatlNounIncorporation2c"
letterOnly="no"
></exampleRef
>. In particular notice that the resulting stem no longer requires a transitive verb <indexedItem
term="iInflectionalTemplate"
></indexedItem
>inflectional template, but rather an intransitive verb one. We can say that this is because the noun has been incorporated as the object and the result is an intransitive stem. We can model this in <object
type="WordWorks"
></object
> as a headed compound, but override the category of the head stem. We could diagram it something like this (where “[vt]” means a transitive verb stem and “[vi]” means an intransitive verb stem):</p
><example
num="xNahuatlObjectIncorpDiagram"
><table
><tr
><td
align="center"
valign="middle"
><img
src="niktolava.png"
></img
></td
><td
align="center"
valign="middle"
>becomes</td
><td
align="center"
valign="middle"
><img
src="nipahtolava.png"
></img
></td
></tr
></table
></example
><p
>That is, we create a right-headed compound rule and set the “Overriding category” in the rule to be an intransitive verb. The rule will use all the characteristics of the head stem except for the category. It will override the category of the head stem with the specified “Overriding category”<indexedRangeEnd
begin="bIncorporation"
></indexedRangeEnd
>.</p
></section4
></section3
><section3
id="sCompoundInterfixes"
><secTitle
>Affixes Between Roots in Compounds</secTitle
><p
><indexedItem
term="iInterfixes"
></indexedItem
><indexedItem
term="iCompInterfix"
></indexedItem
>Consider the <indexedItem
term="iWancaQuechua"
></indexedItem
>Wanca Quechua form given in <exampleRef
equal="no"
letterOnly="no"
num="xWancaWasin-wasin"
></exampleRef
> below:<endnote
id="nWancaInterfix"
><p
>This data is from Rick Floyd, p.c. The gloss of 3P is for “third person possessive.”</p
></endnote
></p
><example
num="xWancaWasin-wasin"
><interlinear
><lineGroup
><line
><langData
lang="lWanca"
>wasin-wasin</langData
></line
><line
><langData
lang="lWanca"
>wasi-n=wasi-n</langData
></line
><line
><gloss
lang="lGloss"
>house-3P=house-3P</gloss
></line
></lineGroup
><free
>‘from house to house’</free
></interlinear
></example
><p
>Here we have a (reduplicated) compound consisting of a root, a suffix, the same root, and the same suffix. This forms a compound as shown in <exampleRef
equal="no"
letterOnly="no"
num="xWancaInterfixCompoundDiagram"
></exampleRef
>:</p
><example
num="xWancaInterfixCompoundDiagram"
><chart
><img
src="wasin-wasin.png"
></img
></chart
></example
><p
>In <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
>, we must treat suffixes like ‑<langData
lang="lWanca"
>n</langData
> in a special way. Affixes which can appear between roots in compounds we call “interfixes.” In order to tell the Stage 1 <object
type="WordWorks"
></object
> parser that a suffix like ‑<langData
lang="lWanca"
>n</langData
> can appear in compounds like it does in <exampleRef
equal="no"
letterOnly="no"
num="xWancaWasin-wasin"
></exampleRef
>, we must give it a morpheme type of “suffixing interfix”. This tells the Stage 1 <object
type="WordWorks"
></object
> parser that this suffix can appear either as a “regular” suffix (merely after a root) or as a suffix before another root in a compound. Note that it is the leftmost instance of ‑<langData
lang="lWanca"
>n</langData
> that is crucial here.</p
><p
>There are three varieties of interfixes:</p
><table
border="1"
type="leftOffset"
><tr
><th
align="left"
valign="top"
>Type</th
><th
align="left"
valign="top"
>Description</th
></tr
><tr
><td
align="left"
valign="top"
>infixing interfix</td
><td
align="left"
valign="top"
>An infixing interfix is an infix that can occur between two roots or stems.</td
></tr
><tr
><td
align="left"
valign="top"
>prefixing interfix</td
><td
align="left"
valign="top"
>A prefixing interfix is a prefix that can occur between two roots or stems.</td
></tr
><tr
><td
align="left"
valign="top"
>suffixing interfix</td
><td
align="left"
valign="top"
>A suffixing interfix is an suffix that can occur between two roots or stems.</td
></tr
></table
><p
>If the language you are modeling has these kinds of compounds and you want the parser to analyze them via a compound rule, then you will need to mark any affixes which can appear between roots with these special morpheme types.</p
></section3
><section3
id="sCompoundPOS"
><secTitle
>Compound Rules and Categories Considerations</secTitle
><p
><indexedItem
term="iCategoryHierarchy"
></indexedItem
>As we noted in sections <sectionRef
sec="sInflAffixPOSConsiderations"
></sectionRef
>, <sectionRef
sec="sInflAffixInflectionClassesAndCategoryHierarchy"
></sectionRef
> and <sectionRef
sec="sDervAffixPOSConsiderations"
></sectionRef
> above, the categories in <object
type="WordWorks"
></object
> are organized in a hierarchical fashion.</p
><p
>The exact hierarchy one uses can make a difference for how the <object
type="WordWorks"
></object
> parser handles the categories in compound rules. When one indicates the information for a left or right member of a compound, <object
type="WordWorks"
></object
> will consider stems of this category and <object
type="InFocus"
>any of its nested categories</object
> to match. For example, if the main level <object
type="category"
>verb</object
> category has two sub-categories of <object
type="category"
>intransitive verb</object
> and <object
type="category"
>transitive verb</object
>, then if a <object
type="category"
>verb</object
> stem, an <object
type="category"
>intransitive verb</object
> stem, or a <object
type="category"
>transitive verb</object
> stem may be the left member, say, of a compound, you only need to say that the left member must be of category <object
type="category"
>verb</object
>. The <object
type="WordWorks"
></object
> parser will allow the left member to be a <object
type="category"
>verb</object
> stem, an <object
type="category"
>intransitive verb</object
> stem, or a <object
type="category"
>transitive verb</object
> stem. You can thus capture a generalization.</p
><p
>You may well need to keep this in mind as you design your category hierarchy<indexedRangeEnd
begin="bCompounding"
></indexedRangeEnd
>.</p
></section3
></section2
><section2
id="sClitics"
><secTitle
>Clitics</secTitle
><p
><indexedItem
term="iClitic"
></indexedItem
>We turn now to consider clitics. Consider the <indexedItem
term="iShipibo"
></indexedItem
>Shipibo data below<endnote
id="nShipibo"
><p
>Data are from <citation
author="yes"
ref="rShipiboV2"
></citation
>. The abbreviations used in the <indexedItem
term="iShipibo"
></indexedItem
>Shipibo data are:</p
><table
border="1"
type="LessSpaceBeforeTable"
><tr
><th
align="left"
valign="top"
>Abbreviation</th
><th
align="left"
valign="top"
>Meaning</th
></tr
><tr
><td
align="left"
valign="top"
>1Sg</td
><td
align="left"
valign="top"
>1st person singular</td
></tr
><tr
><td
align="left"
valign="top"
>Erg</td
><td
align="left"
valign="top"
>transitive subject marker (ergative case)</td
></tr
><tr
><td
align="left"
valign="top"
>Ind</td
><td
align="left"
valign="top"
>indicative</td
></tr
><tr
><td
align="left"
valign="top"
>Cmpl</td
><td
align="left"
valign="top"
>completive</td
></tr
><tr
><td
align="left"
valign="top"
>Reg</td
><td
align="left"
valign="top"
>regressive</td
></tr
><tr
><td
align="left"
valign="top"
>Past.Today</td
><td
align="left"
valign="top"
>recent past; same day as spoken</td
></tr
><tr
><td
align="left"
valign="top"
>Siml.T.SS</td
><td
align="left"
valign="top"
>simultaneous action, transitive verb in principal clause, same subject</td
></tr
><tr
><td
align="left"
valign="top"
>Emph</td
><td
align="left"
valign="top"
>emphasis</td
></tr
><tr
><td
align="left"
valign="top"
>Inf</td
><td
align="left"
valign="top"
>infinitive</td
></tr
><tr
><td
align="left"
valign="top"
>Cont</td
><td
align="left"
valign="top"
>continuative</td
></tr
></table
></endnote
> and notice the ‑<langData
lang="lShipibo"
>ra</langData
> morpheme. Where does it occur and on what kinds of words does it appear?</p
><example
num="xShipiboIBroughtAguajes"
><interlinear
><lineGroup
><line
><wrd
><langData
lang="lShipibo"
>Enra</langData
></wrd
><wrd
><langData
lang="lShipibo"
>binon</langData
></wrd
><wrd
><langData
lang="lShipibo"
>beque.</langData
></wrd
></line
><line
><wrd
lang="lShipibo"
>e-n-<object
type="InFocus"
>ra</object
></wrd
><wrd
lang="lShipibo"
>binon</wrd
><wrd
lang="lShipibo"
>be-que</wrd
></line
><line
><wrd
lang="lGloss"
>1s-Erg-<object
type="InFocus"
>Ind</object
></wrd
><wrd
lang="lGloss"
>aguaje</wrd
><wrd
lang="lGloss"
>to.bring-Cmpl</wrd
></line
></lineGroup
><free
>‘I brought aguajes.’</free
></interlinear
></example
><example
num="xShipiboAguajesIBrought"
><interlinear
><lineGroup
><line
><wrd
><langData
lang="lShipibo"
>Binonra</langData
></wrd
><wrd
><langData
lang="lShipibo"
>en</langData
></wrd
><wrd
><langData
lang="lShipibo"
>beque.</langData
></wrd
></line
><line
><wrd
lang="lShipibo"
>binon-<object
type="InFocus"
>ra</object
></wrd
><wrd
lang="lShipibo"
>e-n</wrd
><wrd
lang="lShipibo"
>be-que</wrd
></line
><line
><wrd
lang="lGloss"
>aguaje-<object
type="InFocus"
>Ind</object
></wrd
><wrd
lang="lGloss"
>1s-Erg</wrd
><wrd
lang="lGloss"
>to.bring-Cmpl</wrd
></line
></lineGroup
><free
>‘Aguajes I brought.’</free
></interlinear
></example
><p
>In both <exampleRef
equal="no"
letterOnly="no"
num="xShipiboIBroughtAguajes"
></exampleRef
> and <exampleRef
equal="no"
letterOnly="no"
num="xShipiboAguajesIBrought"
></exampleRef
>, the indicative ‑<langData
lang="lShipibo"
>ra</langData
> morpheme appears at the end of the first word. In <exampleRef
equal="no"
letterOnly="no"
num="xShipiboIBroughtAguajes"
></exampleRef
> it attaches to a subject and in <exampleRef
equal="no"
letterOnly="no"
num="xShipiboAguajesIBrought"
></exampleRef
> it attaches to the object.</p
><p
>This morpheme can also attach to other categories as the following examples demonstrate:</p
><example
num="xShipiboTheTwoArmadillosHaveEaten"
><interlinear
><lineGroup
><line
><wrd
><langData
lang="lShipibo"
>Yahuish</langData
></wrd
><wrd
><langData
lang="lShipibo"
>rabecanra</langData
></wrd
><wrd
><langData
lang="lShipibo"
>pique.</langData
></wrd
></line
><line
><wrd
lang="lShipibo"
>yahuish</wrd
><wrd
lang="lShipibo"
>rabe-can-<object
type="InFocus"
>ra</object
></wrd
><wrd
lang="lShipibo"
>pi-que</wrd
></line
><line
><wrd
lang="lGloss"
>armadillo</wrd
><wrd
lang="lGloss"
>two-Erg-<object
type="InFocus"
>Ind</object
></wrd
><wrd
lang="lGloss"
>to.eat-Cmpl</wrd
></line
></lineGroup
><free
>‘The two armadillos have eaten.’</free
></interlinear
></example
><example
num="xShipiboIWentIntoTheForestToday"
><interlinear
><lineGroup
><line
><wrd
><langData
lang="lShipibo"
>Nii</langData
></wrd
><wrd
><langData
lang="lShipibo"
>meranra</langData
></wrd
><wrd
><langData
lang="lShipibo"
>ea</langData
></wrd
><wrd
><langData
lang="lShipibo"
>catanhuanque.</langData
></wrd
></line
><line
><wrd
lang="lShipibo"
>nii</wrd
><wrd
lang="lShipibo"
>meran-<object
type="InFocus"
>ra</object
></wrd
><wrd
lang="lShipibo"
>ea</wrd
><wrd
lang="lShipibo"
>ca-tan-huan-que</wrd
></line
><line
><wrd
lang="lGloss"
>forest</wrd
><wrd
lang="lGloss"
>in-<object
type="InFocus"
>Ind</object
></wrd
><wrd
lang="lGloss"
>1s</wrd
><wrd
lang="lGloss"
>to.go-Reg-Past.Today-Cmpl</wrd
></line
></lineGroup
><free
>‘I went into the forest today (and have come back).’</free
></interlinear
></example
><example
num="xShipiboWhenICameIAte"
><interlinear
><lineGroup
><line
><wrd
><langData
lang="lShipibo"
>Caquinra</langData
></wrd
><wrd
><langData
lang="lShipibo"
>en</langData
></wrd
><wrd
><langData
lang="lShipibo"
>pique.</langData
></wrd
></line
><line
><wrd
lang="lShipibo"
>ca-quin-<object
type="InFocus"
>ra</object
></wrd
><wrd
lang="lShipibo"
>e-n</wrd
><wrd
lang="lShipibo"
>pi-que</wrd
></line
><line
><wrd
lang="lGloss"
>to.go-Siml.T.SS-<object
type="InFocus"
>Ind</object
></wrd
><wrd
lang="lGloss"
>1Sg-Erg</wrd
><wrd
lang="lGloss"
>to.eat-Cmpl</wrd
></line
></lineGroup
><free
>‘When I came, I ate.’</free
></interlinear
></example
><example
num="xShipiboNowImThinkingOfFinishingIt"
><interlinear
><lineGroup
><line
><wrd
><langData
lang="lShipibo"
>Ramabira</langData
></wrd
><wrd
><langData
lang="lShipibo"
>en</langData
></wrd
><wrd
><langData
lang="lShipibo"
>janquenhati</langData
></wrd
><wrd
><langData
lang="lShipibo"
>shinanai.</langData
></wrd
></line
><line
><wrd
lang="lShipibo"
>rama-bi-<object
type="InFocus"
>ra</object
></wrd
><wrd
lang="lShipibo"
>e-n</wrd
><wrd
lang="lShipibo"
>janquenha-ti</wrd
><wrd
lang="lShipibo"
>shinan-ai</wrd
></line
><line
><wrd
lang="lGloss"
>now-Emph-<object
type="InFocus"
>Ind</object
></wrd
><wrd
lang="lGloss"
>1s-Erg</wrd
><wrd
lang="lGloss"
>to.finish-Inf</wrd
><wrd
lang="lGloss"
>to.think-Cont</wrd
></line
></lineGroup
><free
>‘Now I'm thinking of finishing it.’</free
></interlinear
></example
><p
>The ‑<langData
lang="lShipibo"
>ra</langData
> morpheme attaches to an adjective in <exampleRef
equal="no"
letterOnly="no"
num="xShipiboTheTwoArmadillosHaveEaten"
></exampleRef
>, a postposition in <exampleRef
equal="no"
letterOnly="no"
num="xShipiboIWentIntoTheForestToday"
></exampleRef
>, a verb in <exampleRef
equal="no"
letterOnly="no"
num="xShipiboWhenICameIAte"
></exampleRef
>, and an adverb in <exampleRef
equal="no"
letterOnly="no"
num="xShipiboNowImThinkingOfFinishingIt"
></exampleRef
>. Notice that it actually appears at the end of the first constituent (a noun phrase in <exampleRef
equal="no"
letterOnly="no"
num="xShipiboTheTwoArmadillosHaveEaten"
></exampleRef
> and a postposition phrase in <exampleRef
equal="no"
letterOnly="no"
num="xShipiboIWentIntoTheForestToday"
></exampleRef
>).</p
><p
>Morphemes like this are often analyzed as being clitics. Orthographically, such clitics may be written attached to another word (like in Shipibo) or they may be written independently. In my experience, orthographic conventions vary on this point. If the clitic is written as attached, then it should be classified as a <object
type="MorphemeType"
>proclitic</object
> if it “prefixes” and as an <object
type="MorphemeType"
>enclitic</object
> if it “suffixes.” If the clitic is written as an independent word, then one may classify it as a <object
type="MorphemeType"
>clitic</object
>. Some orthographic conventions are such that what the analyst considers to be a proclitic or enclitic is also written as an independent word. In such cases, one may still give these a morpheme type of <object
type="MorphemeType"
>proclitic</object
> or <object
type="MorphemeType"
>enclitic</object
>. The <object
type="WordWorks"
></object
> parser will correctly handle a clitic that is labeled as being either a <object
type="MorphemeType"
>proclitic</object
> or <object
type="MorphemeType"
>enclitic</object
> whether it is written attached or as a separate word.</p
><p
>How do we model such clitics in <object
type="WordWorks"
></object
>?</p
><example
num="xCliticHowTo"
><chart
type="HowTo"
><ol
><li
>Create the clitic lexical entry and mark it as being a <object
type="MorphemeType"
>clitic</object
>, <object
type="MorphemeType"
>proclitic</object
> or <object
type="MorphemeType"
>enclitic</object
> as appropriate.</li
><li
>Give it the category that is appropriate for the clitic itself.</li
><li
>If the clitic is written attached and can go on only certain sets of categories, then enter these sets of categories in the “Attaches to Categories” field. As with other items that refer to categories, <object
type="WordWorks"
></object
> will allow such clitics to attach to any word whose category or sub-category is in one of the sets listed in this field. That is, the category hierarchy is taken into account. Thus, if the clitic can attach to any kind of verb, you can just list the top verb category and <object
type="WordWorks"
></object
> will allow the clitic to attach to any of the sub-categories of verb.</li
><li
>If the clitic is written attached and can go on any category, merely leave the “Attaches to Categories” field blank.</li
></ol
></chart
></example
><p
><object
type="WordWorks"
></object
> will do the rest: such morphemes will be allowed to appear at the end (for enclitics which attach) or at the beginning (for proclitics which attach) of words. More than one clitic may appear on a single word. There is no ordering restriction between sequences of attached clitics (other than ad hoc rules; see sections <sectionRef
sec="sAdhocMorphProhibitions"
></sectionRef
> and <sectionRef
sec="sAdhocAlloProhibitions"
></sectionRef
>).</p
><p
>A final note: if your orthographic convention permits several clitics to be written together as a single word (where every morpheme in that orthographic word is a clitic of some kind), then only one of the clitics may be marked as <object
type="MorphemeType"
>clitic</object
>. The others must be marked as <object
type="MorphemeType"
>proclitic</object
> or <object
type="MorphemeType"
>enclitic</object
> and these must be in the proper order (<object
type="MorphemeType"
>proclitics</object
> before the <object
type="MorphemeType"
>clitic</object
> and <object
type="MorphemeType"
>enclitics</object
> after the <object
type="MorphemeType"
>clitic</object
>).</p
></section2
><section2
id="sAdhocMorphProhibitions"
><secTitle
>Ad hoc Morpheme-oriented Rules</secTitle
><p
><indexedRangeBegin
id="bMorphemeAdhoc"
term="iAdhocMorph"
></indexedRangeBegin
><indexedItem
term="iAdhocConstraints"
></indexedItem
>When one uses a <indexedItem
term="iMorphologicalParser"
></indexedItem
>morphological parser, it is not unusual for the parser to sometimes return a parse that is simply incorrect. These are sometimes due to allomorphs matching in places one would not have expected them to match. When one has used all the mechanisms provided by the parser to the best of one's ability and such incorrect parses continue to surface, one may well wish for some kind of mechanism to rule them out. <object
type="WordWorks"
></object
> provides “Ad hoc Rules” for such situations. Note that it may well be the case that later stages of <object
type="WordWorks"
></object
> will provide more well-motivated means to rule out these infelicitous parses, but for now, these ad hoc solutions may have to do.</p
><section3
id="sAdhocMorphProhibitionsCreating"
><secTitle
>Creating Morpheme-oriented Ad hoc Rules</secTitle
><p
>There are two main types of ad hoc rules: morpheme-oriented ones and allomorph-oriented ones. This section deals with morpheme-oriented ones (see section <sectionRef
sec="sAdhocAlloProhibitions"
></sectionRef
> for allomorph-oriented ones). The basic idea is to list a <indexedItem
term="iAdhocKeyMorpheme"
></indexedItem
>key morpheme and then to list one or more <indexedItem
term="iAdhocOtherMorphemes"
></indexedItem
>other morphemes that cannot co-occur with the key one. One can constrain these other morphemes to never occur in one of the following ways with respect to the key morpheme:</p
><example
num="xAdhocMorphAdjacency"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Manner</th
><th
align="left"
valign="top"
>Meaning</th
></tr
><tr
><td
align="left"
valign="top"
>Anywhere</td
><td
align="left"
valign="top"
>The morphemes in question are constrained from appearing anywhere together in the same word.</td
></tr
><tr
><td
align="left"
valign="top"
>Somewhere before</td
><td
align="left"
valign="top"
>The key morpheme is constrained from appearing anywhere in the word before the other morphemes.</td
></tr
><tr
><td
align="left"
valign="top"
>Somewhere after</td
><td
align="left"
valign="top"
>The key morpheme is constrained from appearing anywhere in the word after the other morphemes.</td
></tr
><tr
><td
align="left"
valign="top"
>Adjacent before</td
><td
align="left"
valign="top"
>The key morpheme is constrained from appearing immediately before the other morphemes in the same word.</td
></tr
><tr
><td
align="left"
valign="top"
>Adjacent after</td
><td
align="left"
valign="top"
>The key morpheme is constrained from appearing immediately after the other morphemes in the same word.</td
></tr
></table
></example
><p
>Note that when there are two or more morphemes listed for “other morphemes,” the rule only applies when all of them co-occur in the same word with the key morpheme.  In addition, their relative order is significant. They should be listed in the same linear order they occur in a word.</p
><p
>How does one create a morpheme-oriented ad hoc rule in <object
type="WordWorks"
></object
>?</p
><example
num="xAdhocMorphHowTo"
><chart
type="HowTo"
><ol
><li
>Determine the morphemes involved.</li
><li
>Determine the most appropriate way to constrain them (see <exampleRef
equal="no"
letterOnly="no"
num="xAdhocMorphAdjacency"
></exampleRef
>).<endnote
id="nAdhocMorphHowTo"
><p
>One approach to this is to strive to make the tightest constraint possible (i.e. use one of the adjacency ways first if possible; if not, then try the somewhere case; if that does not work, then try the anywhere case). That way, should you encounter another case involving these particular morphemes, then you will now know more: it is now clear that you need looser constraints. You can then add some comments/annotations to document what you have learned (or put the information in the description).</p
></endnote
></li
><li
>Create a morpheme-oriented ad hoc rule.<ol
><li
>Indicate the key morpheme involved.</li
><li
>Indicate the way or manner in which to constrain this morpheme (see <exampleRef
equal="no"
letterOnly="no"
num="xAdhocMorphAdjacency"
></exampleRef
>).</li
><li
>Indicate the non-key morpheme(s) involved.</li
></ol
></li
></ol
></chart
></example
></section3
><section3
id="sAdhocMorphProhibitionsGroups"
><secTitle
>Grouping Ad hoc Morpheme Rules</secTitle
><p
><indexedItem
term="iAdhocGroup"
></indexedItem
>Occasionally one finds a situation where a set of ad hoc constraints have a common theme. Perhaps they all relate to a particular morpheme or to particular morphemes of a certain variety. This may be a hint as to what is really happening and may lead you to discover a linguistically-motivated way to model them. Or it could be that the <object
type="WordWorks"
></object
> model (or the currently implemented <indexedItem
term="iStages"
></indexedItem
>stage of <object
type="WordWorks"
></object
>) just does not happen to provide the appropriate linguistic mechanism to model the phenomenon correctly.</p
><p
><indexedItem
term="iYalalagZapotec"
></indexedItem
>Yalálag Zapotec dependent pronominal suffixes exemplify such a situation (see <citation
author="yes"
page="9"
paren="none"
ref="rYalalagVerbBook"
></citation
>). In Yalálag Zapotec, a verb may have both a subject and an object person suffix on it. Being a VSO language, the subject occurs before the object. What is different here is that there is a <indexedItem
term="iPronominalHierarchy"
></indexedItem
>pronominal hierarchy among these dependent pronominal suffixes. Given the subject suffix, the only dependent object suffixes which may follow are those that are lower down on the person hierarchy. This is illustrated in <exampleRef
equal="no"
letterOnly="no"
num="xYalalagPronominalHierarchy"
></exampleRef
>.</p
><example
num="xYalalagPronominalHierarchy"
><table
border="1"
><caption
align="center"
valign="top"
>Subject and Object Dependent Suffix Co-occurrence</caption
><tr
><td
align="left"
colspan="2"
rowspan="2"
valign="top"
> </td
><td
align="center"
colspan="5"
type="Bold"
valign="top"
>OBJECT</td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>1st, 2nd person</gloss
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>3rd respect</gloss
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>3rd familiar</gloss
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>3rd animate</gloss
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>3rd thing</gloss
></td
></tr
><tr
><td
align="center"
rowspan="5"
type="Bold"
valign="middle"
>S<br
></br
>U<br
></br
>B<br
></br
>J<br
></br
>E<br
></br
>C<br
></br
>T<br
></br
></td
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>1st, 2nd person</gloss
></td
><td
align="left"
valign="top"
>No</td
><td
align="left"
valign="top"
>YES</td
><td
align="left"
valign="top"
>YES</td
><td
align="left"
valign="top"
>YES</td
><td
align="left"
valign="top"
>YES</td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>3rd respect</gloss
></td
><td
align="left"
valign="top"
>No</td
><td
align="left"
valign="top"
>No</td
><td
align="left"
valign="top"
>YES</td
><td
align="left"
valign="top"
>YES</td
><td
align="left"
valign="top"
>YES</td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>3rd familiar</gloss
></td
><td
align="left"
valign="top"
>No</td
><td
align="left"
valign="top"
>No</td
><td
align="left"
valign="top"
>No</td
><td
align="left"
valign="top"
>YES</td
><td
align="left"
valign="top"
>YES</td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>3rd animate</gloss
></td
><td
align="left"
valign="top"
>No</td
><td
align="left"
valign="top"
>No</td
><td
align="left"
valign="top"
>No</td
><td
align="left"
valign="top"
>No</td
><td
align="left"
valign="top"
>YES</td
></tr
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>3rd thing</gloss
></td
><td
align="left"
valign="top"
>No</td
><td
align="left"
valign="top"
>No</td
><td
align="left"
valign="top"
>No</td
><td
align="left"
valign="top"
>No</td
><td
align="left"
valign="top"
>No</td
></tr
></table
></example
><p
>How would one model such a hierarchy in <object
type="WordWorks"
></object
>? Well, one could create a number of different transitive verb inflectional templates in order to force the hierarchy to come out. But this does not really capture the facts all that well and also complicates and obscures what is common in the transitive verb template. (By the way, neither the subject nor the object is required to be filled by a suffix.) Probably the better approach is to create a morpheme ad hoc rule group and place the set of appropriate ad hoc rules for the hierarchy in that group. This way one can document the fact of the hierarchy and have it all in one place. It also documents the fact that the <object
type="WordWorks"
></object
> model does not have an overt mechanism to deal with such a hierarchy.</p
><p
>How does one create such a group?</p
><example
num="xAdhocMorphGroupHowTo"
><chart
type="HowTo"
><ol
><li
>Create an ad hoc rule group.</li
><li
>For each ad hoc morpheme rule in the group:<ol
><li
>Create the ad hoc morpheme rule (see <exampleRef
equal="no"
letterOnly="no"
num="xAdhocMorphHowTo"
></exampleRef
>) and include it in the group.</li
></ol
></li
></ol
></chart
></example
><p
>Finally, note that <object
type="WordWorks"
></object
> allows one to group both allomorph and morpheme ad hoc rules together. Please be sure to only do so if these rules truly do have something in common<indexedRangeEnd
begin="bMorphemeAdhoc"
></indexedRangeEnd
><indexedRangeEnd
begin="bMorphotactics"
></indexedRangeEnd
>.</p
></section3
></section2
></section1
><section1
id="sMorphophonemics"
><secTitle
>Morphophonemics</secTitle
><p
><indexedRangeBegin
id="bMorphophonemics"
main="yes"
term="iMorphophonemics"
></indexedRangeBegin
>Besides constraining the overall positions where morphemes can occur (i.e. deal with morphotactics), we need to be able to account for the surface forms that the morphemes have and the particular environments where an allomorph is legitimate.</p
><section2
id="sMorphoPhonemicsOverview"
><secTitle
>Overview</secTitle
><p
>Consider the following <indexedItem
term="iOrizabaNahuatl"
></indexedItem
>Orizaba Nahuatl data:</p
><example
num="xNahuatlSubjectPrefixAllos"
><table
border="1"
><tr
><th
align="left"
valign="top"
>1st Singular Subject</th
><th
align="left"
valign="top"
>2nd Singular Subject</th
></tr
><tr
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><wrd
lang="lNahuatl"
><object
type="InFocus"
>ni</object
>-miki</wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>1SgSubj-to.die</gloss
></wrd
></line
></lineGroup
></interlinear
></td
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><wrd
lang="lNahuatl"
><object
type="InFocus"
>ti</object
>-miki</wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>2SgSubj-to.die</gloss
></wrd
></line
></lineGroup
></interlinear
></td
></tr
><tr
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><wrd
lang="lNahuatl"
><object
type="InFocus"
>n</object
>-ahsi</wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>1SgSubj-to.arrive</gloss
></wrd
></line
></lineGroup
></interlinear
></td
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><wrd
lang="lNahuatl"
><object
type="InFocus"
>t</object
>-ahsi</wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>2SgSubj-to.arrive</gloss
></wrd
></line
></lineGroup
></interlinear
></td
></tr
></table
></example
><p
>What are the shapes of the <gloss
lang="lGloss"
>1SgSubj</gloss
> and the <gloss
lang="lGloss"
>2SgSubj</gloss
> allomorphs? The first person singular subject marker appears to be <langData
lang="lNahuatl"
>ni</langData
>‑ before consonants and <langData
lang="lNahuatl"
>n</langData
>‑ before vowels. Similarly, the second person singular subject marker alternates between <langData
lang="lNahuatl"
>ti</langData
>‑ and <langData
lang="lNahuatl"
>t</langData
>‑.</p
><p
>How can we encode this information? There are at least two ways to deal with such phonological information:</p
><ol
><li
>Give the underlying form along with a set of rules to create the surface forms; or</li
><li
>List the surface allomorphs and condition each one to appear in the appropriate surface environment.</li
></ol
><p
>Generative phonology uses the first approach (also known as the <indexedItem
term="iItemAndProcess"
></indexedItem
>item and process approach, <citation
author="yes"
ref="rHockett"
></citation
>). For example, given the data in <exampleRef
letter="xNahuatlSubjectPrefixAllos"
num="xNahuatlSubjectPrefixAllos"
></exampleRef
>, one might consider the underlying forms of the two subject prefixes would be <langData
lang="lNahuatl"
>ni</langData
> and <langData
lang="lNahuatl"
>ti</langData
>, respectively. We would then write a phonological rule to delete the first vowel when it is followed by a second vowel.</p
><p
><indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
>, however, chooses the second approach (also known as the <indexedItem
term="iItemAndArrangement"
></indexedItem
>item and arrangement approach, <citation
author="yes"
ref="rHockett"
></citation
>). For example, once again considering the data in <exampleRef
letter="xNahuatlSubjectPrefixAllos"
num="xNahuatlSubjectPrefixAllos"
></exampleRef
>, we would need two forms for each subject prefix entry. We could make the Lexical Form be the longer one (<langData
lang="lNahuatl"
>ni</langData
> and <langData
lang="lNahuatl"
>ti</langData
>, respectively) and have an allomorph for the shorter one (<langData
lang="lNahuatl"
>n</langData
> and <langData
lang="lNahuatl"
>t</langData
>, respectively) that would be conditioned to have an environment saying that it must be followed by a vowel.</p
><p
>Plans for <indexedItem
term="iStage2"
></indexedItem
>Stages 2 and <indexedItem
term="iStage3"
></indexedItem
>3 of <object
type="WordWorks"
></object
> include also allowing the first.<endnote
id="nStage1NonGenerativePhonology"
><p
>One main reason why <indexedItem
term="iStage1"
></indexedItem
>Stage 1 does not allow for phonological rules is that we could then use a <indexedItem
term="iXAmple"
></indexedItem
>modified form of an existing SIL tool (AMPLE) and not have to spend any time building a special phonological processor.</p
></endnote
> As noted in section <sectionRef
sec="sIntro"
></sectionRef
>, we now also have the new <indexedItem
term="iHermitCrab"
></indexedItem
><object
type="HermitCrab"
></object
> which allows for both item and arrangement and item and process. See appendix <appendixRef
app="aHermitCrab"
></appendixRef
> for more.</p
><p
>For Stage 1 of <object
type="WordWorks"
></object
>, then, the basic mechanism available is to list surface allomorphs and then have the option to constrain individual surface allomorphs by their environment. To define an environment, one may well want to use natural classes of segments (e.g. consonant, vowels, voiceless stops, nasals, etc.). To define such natural classes, we need to know what the possible segments are.</p
><section3
id="sPhonemeSets"
><secTitle
>Phoneme Sets</secTitle
><p
><indexedItem
term="iPhonemes"
></indexedItem
>In order to use <indexedItem
term="iAlloEnvironments"
></indexedItem
>environments which refer to phonemes or which have natural classes, you need to create a list of all the phonemes in your language. For each phoneme, you need to indicate one or more <indexedItem
term="iPhonemeRepresentation"
></indexedItem
>representations that represent them. For example, in Greek, the /s/ phoneme has two such representations: <langData
lang="lGreek"
>ς</langData
> (which is used word finally) and <langData
lang="lGreek"
>σ</langData
> (which is used everywhere else).</p
><p
>In addition to these phonemes, you may also need to refer to <indexedItem
term="iWordBoundary"
></indexedItem
>word boundaries in an environment. For this reason, <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
> comes with a predefined word boundary marker: the <object
type="TT"
>#</object
> symbol.</p
><p
>Stage 1 of <object
type="WordWorks"
></object
> also comes with a potential set of phonemes already defined. That is, you do not need to start from scratch when building the list of phonemes for your language. However, you may well need to edit the list of phonemes initially included for a new language project. This initial set of phonemes is given in <exampleRef
equal="no"
letterOnly="no"
num="xInitialSetOfPhonemes"
></exampleRef
> below.</p
><example
num="xInitialSetOfPhonemes"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Name</th
><th
align="left"
valign="top"
>Description</th
><th
align="left"
valign="top"
>Representation</th
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>i</langData
></td
><td
align="left"
valign="top"
>high front unrounded vowel</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>i</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>e</langData
></td
><td
align="left"
valign="top"
>mid front unrounded vowel</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>e</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>a</langData
></td
><td
align="left"
valign="top"
>low central unrounded vowel</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>a</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>o</langData
></td
><td
align="left"
valign="top"
>mid back rounded vowel</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>o</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>u</langData
></td
><td
align="left"
valign="top"
>high back rounded vowel</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>u</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>p</langData
></td
><td
align="left"
valign="top"
>voiceless bilabial stop</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>p</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>b</langData
></td
><td
align="left"
valign="top"
>voiced bilabial stop</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>b</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>t</langData
></td
><td
align="left"
valign="top"
>voiceless alveolar stop</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>t</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>d</langData
></td
><td
align="left"
valign="top"
>voiced alveolar stop</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>d</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>k</langData
></td
><td
align="left"
valign="top"
>voiceless velar stop</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>k</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>g</langData
></td
><td
align="left"
valign="top"
>voiced velar stop</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>g</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>f</langData
></td
><td
align="left"
valign="top"
>voiceless labiodental fricative</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>f</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>v</langData
></td
><td
align="left"
valign="top"
>voiced labiodental fricative</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>v</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>s</langData
></td
><td
align="left"
valign="top"
>voiceless alveolar fricative</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>s</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>z</langData
></td
><td
align="left"
valign="top"
>voiced alveolar fricative</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>z</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>x</langData
></td
><td
align="left"
valign="top"
>voiceless velar fricative</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>x</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>m</langData
></td
><td
align="left"
valign="top"
>bilabial nasal</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>m</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>n</langData
></td
><td
align="left"
valign="top"
>alveolar nasal</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>n</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>ŋ</langData
></td
><td
align="left"
valign="top"
>velar nasal</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>ŋ</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>l</langData
></td
><td
align="left"
valign="top"
>alveolar lateral</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>l</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>r</langData
></td
><td
align="left"
valign="top"
>alveolar flap</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>r</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>w</langData
></td
><td
align="left"
valign="top"
>labiovelar approximant</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>w</langData
></td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lEng"
>j</langData
></td
><td
align="left"
valign="top"
>palatal approximant</td
><td
align="left"
valign="top"
><langData
lang="lEng"
>j</langData
></td
></tr
></table
></example
><p
>To define the set of phonemes for the language you are modeling, do what is shown in the following:</p
><example
num="xPhonemesHowTo"
><chart
type="HowTo"
><ol
><li
>Determine the phonemes in your language.</li
><li
>Remove any phonemes in the list given in <exampleRef
letter="xInitialSetOfPhonemes"
num="xInitialSetOfPhonemes"
></exampleRef
> above that you do not need.</li
><li
>For each phoneme not already in the list given in <exampleRef
equal="no"
letterOnly="no"
num="xInitialSetOfPhonemes"
></exampleRef
> above,<ol
><li
>Create a phoneme entry.</li
><li
>For each symbol or sequence of symbols that represent that phoneme, create a representation (in newer versions these are called graphemes).</li
></ol
></li
><li
>For each phoneme in the list given in <exampleRef
equal="no"
letterOnly="no"
num="xInitialSetOfPhonemes"
></exampleRef
>,<ol
><li
>Edit the name (or "Refer to as"), description, and representation/grapheme if need be.</li
><li
>Add any new representations/ graphemes needed.</li
></ol
></li
></ol
></chart
></example
><section4
id="sPhonemeSetsDigraphs"
><secTitle
>Digraphs</secTitle
><p
>If you have orthographic digraphs (or trigraphs) as phonemes, you follow the same basic steps outlined in <exampleRef
letter="xPhonemesHowTo"
num="xPhonemesHowTo"
></exampleRef
> steps 3 and 4. Merely use the appropriate digraph for the phoneme and also use the digraph as the representation/grapheme. For example, if you have an aspirated voiceless alveolar stop written as <object
type="TT"
>th</object
>, then use <langData
lang="lEng"
>th</langData
> for the information.</p
></section4
><section4
id="sPhonemeSetsTones"
><secTitle
>Tones</secTitle
><p
><indexedRangeBegin
id="bTonePhoneme"
term="iTone"
></indexedRangeBegin
>While many languages have tones, not all mark the tone in the practical orthography. If the language you are modeling includes tone symbols marked on vowels as accents, say, then you need to decide which of several ways to go in indicating tone.</p
><section5
id="sPhonemeSetsTonesNoConditioning"
><secTitle
>No Forms Conditioned by Tone</secTitle
><p
>This is the simplest case where no forms are ever conditioned by surrounding tone. For example, it is never the case that you have an affix which must be preceded or followed by a high tone (or low tone). Because of this, you never need to write an environment that refers to tone, only to natural classes of segments.</p
><p
>If this is the situation you have, then for each vowel that bears tone, add a distinct representation for how that vowel with tone is written. For example, when the vowel <langData
lang="lEng"
>a</langData
> has high tone, it is written as <langData
lang="lEng"
>á</langData
>, then you need to add <langData
lang="lEng"
>á</langData
> to the list of representations/graphemes for the vowel <langData
lang="lEng"
>a</langData
>.</p
></section5
><section5
id="sPhonemeSetsTonesConditioning"
><secTitle
>Forms Conditioned by Tone</secTitle
><p
>The second situation is more complicated. This is where there are forms in your language that must be conditioned by surrounding tone. For example, there is an affix form which is licit only if it is preceded or followed by a particular tone (high, say). This means that you will need to be able to write an environment that contains all phonemes that bear high tone. To do this, there are two options.</p
><p
>The first option is to have distinct phonemes for each high toned vowel, say. If this is your case, then you need to make distinct phonemes for each vowel that bears different tones. For example, if a low tone <langData
lang="lEng"
>a</langData
> is written as <langData
lang="lEng"
>a</langData
> while a high tone <langData
lang="lEng"
>a</langData
> is written as <langData
lang="lEng"
>á</langData
>, then you will need two phonemes: one for the low toned <langData
lang="lEng"
>a</langData
> and one for the high toned <langData
lang="lEng"
>a</langData
>. You can then create a natural class that contains all high-toned phonemes and write your environment in terms of this natural class.</p
><p
>The second option is to create phonemes that consist merely of the tone diacritic itself. Since <object
type="WordWorks"
></object
> always stores its data in “decomposed” form (NFD), any accent marks or other diacritics will be stored after the main symbol. Thus, <object
type="TT"
>á</object
> is stored as two characters <object
type="TT"
>aˊ</object
>, the /a/ and then the acute accent. Taking advantage of this, you could create a phoneme that is for the acute accent <langData
lang="lEng"
>ˊ</langData
> and call it something like “High tone.” You could then condition the forms to occur only when followed by this acute accent phoneme.<indexedRangeEnd
begin="bTonePhoneme"
></indexedRangeEnd
></p
></section5
></section4
></section3
><section3
id="sNatClasses"
><secTitle
>Natural Classes</secTitle
><p
><indexedItem
main="yes"
term="iNaturalClass"
></indexedItem
>Once you have the phonemes defined, then you can create natural classes of phonemes. Some common ones include such things as consonants, vowels, voiceless stops, back vowels, etc. To do this in <object
type="WordWorks"
></object
> do the following:</p
><example
num="xNaturalClassesHowTo"
><chart
type="HowTo"
><ol
><li
>Determine the natural classes you need.</li
><li
>If any of the phonemes in any of these natural classes are not already in your list of phonemes, add them to the list of phonemes. See <exampleRef
letter="xPhonemesHowTo"
num="xPhonemesHowTo"
></exampleRef
>.</li
><li
>Create each one, giving them a name, description, abbreviation and indicating all the phonemes which belong to the class.</li
></ol
></chart
></example
><p
>We highly recommend that you seek to give unique <indexedItem
main="yes"
term="iNatClassAbbreviations"
></indexedItem
>abbreviations for these. While it is possible to have two or more natural classes with abbreviations spelled exactly the same way, we do not recommend that you do so on purpose. Having two or more natural classes with the same abbreviation will not confuse <object
type="WordWorks"
></object
> because <object
type="WordWorks"
></object
> uniquely identifies every natural class internally. That does not imply, however, that either you or a reader of your grammar will not be confused as a result.</p
></section3
><section3
id="sEnvironments"
><secTitle
>Allomorph Environments</secTitle
><p
><indexedItem
term="iAlloEnvironments"
></indexedItem
>Once the set of phonemes and natural classes are defined for the language you are modeling, you can define environments for allomorphs. You can add them either in the environment editor or with a given lexeme form or allomorph.</p
><p
>In <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
>, you key these environments using a special notation. This notation is one that is reminiscent of what is used in many generative-style rules. The basic rules of thumb are:</p
><example
num="xEnvironmentsHowTo"
><chart
type="HowTo"
><ol
><li
>Begin each environment with the forward slash character <object
type="TT"
>/</object
></li
><li
>The location of the allomorph itself is indicated by an underscore character <object
type="TT"
>_</object
></li
><li
>Any phonemes or natural classes that must come before the allomorph are typed in before this underscore character. Type them in the order in which they must appear.</li
><li
>Any phonemes or natural classes that must come after the allomorph are typed in after this underscore character. Type them in the order in which they must appear.</li
><li
>Any phoneme is indicated by typing in the representation/grapheme of the phoneme.</li
><li
>Any natural classes are indicated by<ol
><li
>typing a left square bracket <object
type="TT"
>[</object
>,</li
><li
>typing the <indexedItem
term="iNatClassAbbreviations"
></indexedItem
>abbreviation of the natural class,<endnote
id="nNatClassName"
><p
>This is another reason why you should use unique abbreviations for natural classes. If you have two or more natural classes with the same abbreviation, it is not clear which one you mean. <object
type="WordWorks"
></object
> will automatically select one, but it may not be the one you intended.</p
></endnote
> and</li
><li
>then typing a right square bracket <object
type="TT"
>]</object
></li
></ol
></li
><li
>Optional phonemes or natural classes are indicated by<ol
><li
>typing an opening parenthesis <object
type="TT"
>(</object
>,</li
><li
>typing the phoneme or natural class as above, and</li
><li
>then typing a closing parenthesis <object
type="TT"
>)</object
></li
><li
>Note that one should not nest optional items. The <object
type="WordWorks"
></object
> parser will not handle these properly. You must enter each optional item after the other.</li
></ol
></li
></ol
></chart
></example
><p
>Example <exampleRef
equal="no"
letterOnly="no"
num="xEnvironmentExamples"
></exampleRef
> gives some sample environments along with what they mean.</p
><example
num="xEnvironmentExamples"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Environment    </th
><th
align="left"
valign="top"
>Meaning</th
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ m _</object
></td
><td
align="left"
valign="top"
>after an <object
type="TT"
>m</object
> phoneme</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ [V] _</object
></td
><td
align="left"
valign="top"
>after a vowel (assuming there is a natural class of vowels called <object
type="TT"
>V</object
>)</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ # i _</object
></td
><td
align="left"
valign="top"
>after a word initial <object
type="TT"
>i</object
> phoneme</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ # [V] _</object
></td
><td
align="left"
valign="top"
>after a word initial vowel (assuming there is a natural class of vowels called <object
type="TT"
>V</object
>)</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ [V] y _</object
></td
><td
align="left"
valign="top"
>after a vowel (assuming there is a natural class of vowels called <object
type="TT"
>V</object
>) and a <object
type="TT"
>y</object
> phoneme</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ _ i</object
></td
><td
align="left"
valign="top"
>before an <object
type="TT"
>i</object
> phoneme</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ _ [C]</object
></td
><td
align="left"
valign="top"
>before a consonant (assuming there is a natural class of consonants called <object
type="TT"
>C</object
>)</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ _ y #</object
></td
><td
align="left"
valign="top"
>before a <object
type="TT"
>y</object
> phoneme which is word final</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ _ [C] #</object
></td
><td
align="left"
valign="top"
>before a word final consonant (assuming there is a natural class of consonants called <object
type="TT"
>C</object
>)</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ m _ w</object
></td
><td
align="left"
valign="top"
>between an <object
type="TT"
>m</object
> and an <object
type="TT"
>w</object
> phoneme</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ [C] _ [C]</object
></td
><td
align="left"
valign="top"
>between two consonants (assuming there is a natural class of consonants called <object
type="TT"
>C</object
>)</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ ai _</object
></td
><td
align="left"
valign="top"
>after an <object
type="TT"
>a</object
> and an <object
type="TT"
>i</object
> phoneme</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ _ ai</object
></td
><td
align="left"
valign="top"
>before an <object
type="TT"
>a</object
> and an <object
type="TT"
>i</object
> phoneme</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ _ (a)i</object
></td
><td
align="left"
valign="top"
>before an optional <object
type="TT"
>a</object
> and an <object
type="TT"
>i</object
> phoneme; that is, either before <object
type="TT"
>ai</object
> or before <object
type="TT"
>i</object
></td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ _ ([C]) #</object
></td
><td
align="left"
valign="top"
>before an optional word final consonant (assuming there is a natural class of consonants called <object
type="TT"
>C</object
>); that is, either before a word final consonant or word finally</td
></tr
></table
></example
><pc
>For a similar table for right-to-left scripts, see this endnote.<endnote
id="nRTLAlloEnvirons"
><p
>The following table gives some sample environments along with what they mean using a right-to-left script.</p
><table
border="1"
><tr
><th
align="left"
valign="top"
>Meaning</th
><th
align="right"
valign="top"
>        Environment</th
></tr
><tr
><td
align="left"
valign="top"
>after a <object
type="TTRTL"
>מ</object
> phoneme</td
><td
align="right"
direction="rtl"
type="TTRTL"
valign="top"
><object
type="TTRTL"
>/ מ _</object
></td
></tr
><tr
><td
align="left"
valign="top"
>after a vowel (assuming there is a natural class of vowels called <object
type="TTRTL"
>V</object
>)</td
><td
align="right"
direction="rtl"
type="TTRTL"
valign="top"
><object
type="TTRTL"
>/ [V] _</object
></td
></tr
><tr
><td
align="left"
valign="top"
>after a word initial <object
type="TTRTL"
>ָ</object
> phoneme</td
><td
align="right"
direction="rtl"
valign="top"
><object
type="TTRTL"
>/ # ָ _</object
></td
></tr
><tr
><td
align="left"
valign="top"
>after a word initial vowel (assuming there is a natural class of vowels called <object
type="TTRTL"
>V</object
>)</td
><td
align="right"
direction="rtl"
valign="top"
><object
type="TTRTL"
>/ # [V] _</object
></td
></tr
><tr
><td
align="left"
valign="top"
>after a vowel (assuming there is a natural class of vowels called <object
type="TTRTL"
>V</object
>) and a <object
type="TTRTL"
>י</object
> phoneme</td
><td
align="right"
direction="rtl"
valign="top"
><object
type="TTRTL"
>/ [V] י _</object
></td
></tr
><tr
><td
align="left"
valign="top"
>before a <object
type="TTRTL"
>ָ</object
> phoneme</td
><td
align="right"
direction="rtl"
valign="top"
><object
type="TTRTL"
>/ _ ָ</object
></td
></tr
><tr
><td
align="left"
valign="top"
>before a consonant (assuming there is a natural class of consonants called <object
type="TTRTL"
>C</object
>)</td
><td
align="right"
direction="rtl"
valign="top"
><object
type="TTRTL"
>/ _ [C]</object
></td
></tr
><tr
><td
align="left"
valign="top"
>before a <object
type="TTRTL"
>י</object
> phoneme which is word final</td
><td
align="right"
direction="rtl"
valign="top"
><object
type="TTRTL"
>/ _ י #</object
></td
></tr
><tr
><td
align="left"
valign="top"
>before a word final consonant (assuming there is a natural class of consonants called <object
type="TTRTL"
>C</object
>)</td
><td
align="right"
direction="rtl"
valign="top"
><object
type="TTRTL"
>/ _ [C] #</object
></td
></tr
><tr
><td
align="left"
valign="top"
>between a <object
type="TTRTL"
>מ</object
> and a <object
type="TTRTL"
>ו</object
> phoneme</td
><td
align="right"
direction="rtl"
valign="top"
><object
type="TTRTL"
>/ ם _ו</object
></td
></tr
><tr
><td
align="left"
valign="top"
>between two consonants (assuming there is a natural class of consonants called <object
type="TTRTL"
>C</object
>)</td
><td
align="right"
direction="rtl"
valign="top"
><object
type="TTRTL"
>/ [C] _ [C]</object
></td
></tr
><tr
><td
align="left"
valign="top"
>after a <object
type="TTRTL"
>ֵ</object
> and a י phoneme</td
><td
align="right"
direction="rtl"
valign="top"
><object
type="TTRTL"
>/ ֵי _</object
></td
></tr
><tr
><td
align="left"
valign="top"
>before a <object
type="TTRTL"
>ֵ</object
> and a <object
type="TTRTL"
>י</object
> phoneme</td
><td
align="right"
direction="rtl"
valign="top"
><object
type="TTRTL"
>/ _ ֵי</object
></td
></tr
><tr
><td
align="left"
valign="top"
>before an optional <object
type="TTRTL"
>ֵ</object
> and a <object
type="TTRTL"
>י</object
> phoneme; that is, either before <object
type="TTRTL"
>ֵ</object
> followed by <object
type="TTRTL"
>י</object
> or before <object
type="TTRTL"
>י</object
></td
><td
align="right"
direction="rtl"
valign="top"
><object
type="TTRTL"
>/ _ (ֵ)י</object
></td
></tr
><tr
><td
align="left"
valign="top"
>before an optional word final consonant (assuming there is a natural class of consonants called <object
type="TTRTL"
>C</object
>); that is, either before a word final consonant or word finally</td
><td
align="right"
direction="rtl"
valign="top"
><object
type="TTRTL"
>/ _ ([C]) #</object
></td
></tr
></table
></endnote
></pc
><p
>A given allomorph may have more than one environment, in which case the various environments are logically ORed with each other. That is, if any one of the environments for the allomorph are found, then the allomorph is considered to be valid (as far as its environments are concerned). For example, if a given allomorph can appear either before a consonant or word finally, then you can list both an environment for “before a consonant” and one for “before a word boundary.” Example <exampleRef
equal="no"
letterOnly="no"
num="xSyllableFinalEnvironment"
></exampleRef
> shows what this might look like, assuming that you have a natural class of consonants with an abbreviation of <object
type="TT"
>C</object
>.</p
><example
num="xSyllableFinalEnvironment"
><table
border="1"
><tr
><td
align="left"
valign="top"
><object
type="TT"
>  / _ [C]  </object
></td
><td
align="left"
valign="top"
><object
type="TT"
> / _ #  </object
></td
></tr
></table
></example
><p
><indexedRangeBegin
id="bEnvAndInflClasses"
term="iInflClassEnvironments"
></indexedRangeBegin
>Finally, if an affix entry has inflection classes as well as at least some allomorphs with environments, you should be careful to tag all allomorphs in the entry with the inflection class(es) they go on. Otherwise, some allomorphs without environments may be incorrectly constrained.<indexedRangeEnd
begin="bEnvAndInflClasses"
></indexedRangeEnd
></p
></section3
><section3
id="sAllomorphOrdering"
><secTitle
>Allomorph Ordering</secTitle
><p
><indexedItem
term="iAllomorphOrder"
></indexedItem
><indexedItem
term="iAlloEnvironments"
></indexedItem
>It is crucial to note that allomorphs are ordered in the sense that their respective environments are disjunctively ordered. For example, for the <indexedItem
term="iOrizabaNahuatl"
></indexedItem
>Nahuatl <gloss
lang="lGloss"
>1SgSubj</gloss
> allomorphs above in example <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlSubjectPrefixAllos"
></exampleRef
>, we could list the two allomorphs in any of the ways shown in <exampleRef
equal="no"
letterOnly="no"
num="xAlloOrderOvert1"
></exampleRef
>-<exampleRef
equal="no"
letterOnly="no"
num="xAlloOrderImplicit2"
></exampleRef
>.</p
><example
num="xAlloOrderOvert1"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Overt 1</th
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>ni</langData
> / _ [C]</td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>n</langData
> / _ [V]</td
></tr
></table
></td
></tr
></table
></example
><example
num="xAlloOrderOvert2"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Overt 2</th
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>n</langData
> / _ [V]</td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>ni</langData
> / _ [C]</td
></tr
></table
></td
></tr
></table
></example
><example
num="xAlloOrderImplicit1"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Implicit 1</th
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>ni</langData
> / _ [C]</td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>n</langData
></td
></tr
></table
></td
></tr
></table
></example
><example
num="xAlloOrderImplicit2"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Implicit 2</th
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>n</langData
> / _ [V]</td
></tr
><tr
><td
align="left"
valign="top"
><langData
lang="lNahuatl"
>ni</langData
></td
></tr
></table
></td
></tr
></table
></example
><p
>Note in particular that for the two implicit methods, one does not have to overtly state the environment for the last allomorph. This is because each allomorph automatically inherits the negation of the environments of any preceding allomorphs. Thus, for the Implicit 1 method, the <langData
lang="lNahuatl"
>n</langData
> is automatically treated as having an environment of "not before a consonant." Similarly, for the Implicit 2 method, the <langData
lang="lNahuatl"
>ni</langData
> is automatically treated as having an environment of "not before a vowel." For more on this, see section <sectionRef
sec="sAllomorphOrder"
></sectionRef
>.</p
><section4
id="sAllomorphOrderingFreeFluctuation"
><secTitle
>Free Fluctuation</secTitle
><p
><indexedItem
term="iAlloFreeFluctuation"
></indexedItem
>Sometimes a language has free fluctuation between two allomorphs of a morpheme. In such cases, one should create both allomorphs and condition them exactly the same way (in terms of environments and inflection classes). One should also order them one after the other. The <object
type="WordWorks"
></object
> default parser will try both forms in such cases.</p
></section4
></section3
></section2
><section2
id="sReduplication"
><secTitle
>Reduplication</secTitle
><p
>In the next five sections, we will address five issues brought up in section <sectionRef
sec="sKeyIssues"
></sectionRef
>. First, we deal with <indexedRangeBegin
id="bReduplication"
main="yes"
term="iReduplication"
></indexedRangeBegin
>reduplication.</p
><section3
id="sReduplicationFull"
><secTitle
>Full Reduplication</secTitle
><p
><indexedRangeBegin
id="bFullReduplication"
term="iRedupFull"
></indexedRangeBegin
>Consider the following data from <indexedItem
term="iBahasaIndonesia"
></indexedItem
>Bahasa Indonesia:<endnote
id="nFullRedupData"
><p
>The data are from Howard Shelden, p.c. and Jonathan Coombs, p.c.</p
></endnote
></p
><example
num="xIndonesianRedup1"
><listWord
letter="xIndonesianRedup1a"
><langData
lang="lBahasaIndonesia"
>pel</langData
><gloss
lang="lGloss"
>‘mop’</gloss
></listWord
><listWord
letter="xIndonesianRedup1b"
><langData
lang="lBahasaIndonesia"
>pel-pel</langData
><gloss
lang="lGloss"
>‘mops’</gloss
></listWord
></example
><example
num="xIndonesianRedup2"
><listWord
letter="xIndonesianRedup2a"
><langData
lang="lBahasaIndonesia"
>buku</langData
><gloss
lang="lGloss"
>‘book’</gloss
></listWord
><listWord
letter="xIndonesianRedup2b"
><langData
lang="lBahasaIndonesia"
>buku-buku</langData
><gloss
lang="lGloss"
>‘books’</gloss
></listWord
></example
><example
num="xIndonesianRedup3"
><listWord
letter="xIndonesianRedup3a"
><langData
lang="lBahasaIndonesia"
>komik</langData
><gloss
lang="lGloss"
>‘clown’</gloss
></listWord
><listWord
letter="xIndonesianRedup3b"
><langData
lang="lBahasaIndonesia"
>komik-komik</langData
><gloss
lang="lGloss"
>‘clowns’</gloss
></listWord
></example
><example
num="xIndonesianRedup4"
><listWord
letter="xIndonesianRedup4a"
><langData
lang="lBahasaIndonesia"
>orang</langData
><gloss
lang="lGloss"
>‘person’</gloss
></listWord
><listWord
letter="xIndonesianRedup4b"
><langData
lang="lBahasaIndonesia"
>orang-orang</langData
><gloss
lang="lGloss"
>‘people’</gloss
></listWord
></example
><example
num="xIndonesianRedup6"
><listWord
letter="xIndonesianRedup6a"
><langData
lang="lBahasaIndonesia"
>perpustakaan</langData
><gloss
lang="lGloss"
>‘library’</gloss
></listWord
><listWord
letter="xIndonesianRedup6b"
><langData
lang="lBahasaIndonesia"
>perpustakaan-perpustakaan</langData
><gloss
lang="lGloss"
>‘libraries’</gloss
></listWord
></example
><p
>In examples <exampleRef
equal="no"
letterOnly="no"
num="xIndonesianRedup1"
></exampleRef
>-<exampleRef
equal="no"
letterOnly="no"
num="xIndonesianRedup6"
></exampleRef
> note that the entire word is reduplicated, no matter what its <indexedItem
term="iSyllable"
></indexedItem
>syllabic shape might be. This is what is often called <object
type="Definition"
>full reduplication</object
>.<endnote
id="nFullRedupTerm"
><p
>It is also called <object
type="Definition"
>total reduplication</object
> and sometimes <object
type="Definition"
>general reduplication</object
>.</p
></endnote
></p
><p
>In examples like <exampleRef
equal="no"
letterOnly="no"
num="xIndonesianRedup1"
></exampleRef
>-<exampleRef
equal="no"
letterOnly="no"
num="xIndonesianRedup6"
></exampleRef
>, one cannot tell whether the reduplication morpheme is a prefix or a suffix. However, sometimes a stem will reduplicate and other affixes may be adjoined. For example, consider <exampleRef
equal="no"
letterOnly="no"
num="xIndonesianRedup5"
></exampleRef
>‑<exampleRef
equal="no"
letterOnly="no"
num="xIndonesianRedup7"
></exampleRef
>:</p
><example
num="xIndonesianRedup5"
><listWord
letter="xIndonesianRedup5a"
><langData
lang="lBahasaIndonesia"
>tangan</langData
><gloss
lang="lGloss"
>‘hand’</gloss
></listWord
><listWord
letter="xIndonesianRedup5b"
><langData
lang="lBahasaIndonesia"
>tangan-tangannya</langData
><gloss
lang="lGloss"
>‘his hands’</gloss
></listWord
></example
><example
num="xIndonesianRedup7"
><listWord
letter="xIndonesianRedup7a"
><langData
lang="lBahasaIndonesia"
>perpustakaan</langData
><gloss
lang="lGloss"
>‘library’</gloss
></listWord
><listWord
letter="xIndonesianRedup7b"
><langData
lang="lBahasaIndonesia"
>perpustakaan-perpustakaannya</langData
><gloss
lang="lGloss"
>‘his libraries’</gloss
></listWord
></example
><p
>Notice the ‑<langData
lang="lBahasaIndonesia"
>nya</langData
> suffix which comes after the reduplicated stem. The way we are modeling full reduplication in <object
type="WordWorks"
></object
>, the root must be at one end and then any affixes (including the reduplication morpheme) must either be all prefixes or be all suffixes.<endnote
id="nFullRedup"
><p
>There is a technical reason for this. The parser matches the entire rest of the word (for a prefix) or the entire beginning of the word (for a suffix). It cannot match if there is additional material.</p
></endnote
> Thus, in modeling examples <exampleRef
equal="no"
letterOnly="no"
num="xIndonesianRedup5"
></exampleRef
>‑<exampleRef
equal="no"
letterOnly="no"
num="xIndonesianRedup7"
></exampleRef
>, we would make the reduplication morpheme be a suffix.</p
><section4
id="sReduplicationFullPatternStage1"
><secTitle
>Writing the Pattern for Full Reduplication (for Stage 1 of <object
type="WordWorks"
></object
>)</secTitle
><p
>How do we indicate full reduplication for <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
>? (See <appendixRef
app="sHCRedupFull"
></appendixRef
> for how to write an affix process for full reduplication using the new <object
type="HermitCrab"
></object
>.)</p
><example
num="xFulllReduplicationHowTo"
><chart
type="HowTo"
><ol
><li
>Determine that the reduplication is indeed full reduplication. <indexedItem
term="iRedupPartial"
></indexedItem
>Note that if both prefixes and suffixes attach to a reduplicated sequence, then you will need to use partial reduplication (see section <sectionRef
sec="sReduplicationPartial"
></sectionRef
>).</li
><li
>Determine whether the reduplication morpheme is derivational or inflectional.</li
><li
>Determine if the reduplication affix is a prefix or a suffix:<ol
><li
>If you do get either prefixes or suffixes (but not both) on a fully reduplicated stem, make the affix type be the same as the additional material. That is, if it can take additional prefixes, make the reduplicant morpheme also be a prefix. If it can take suffixes, make the reduplicant morpheme also be a suffix.</li
><li
>If it is not clear, we suggest making it be a suffix (this will probably be more efficient for the parser).</li
></ol
></li
><li
>Create a lexical entry for the reduplication morpheme.<ol
><li
>Mark it as derivational or inflectional according to what you determined.</li
><li
>Add a form which contains the special full reduplication sequence indicator: <object
type="TT"
>[...]</object
> (that's a left square bracket, three periods, and a right square bracket)<endnote
id="nFullRedupNotation"
><p
>This is the same notation as used in Shoebox and Toolbox. AMPLE uses <object
type="TT"
>&lt;...&gt;</object
>.</p
></endnote
> in the lexeme form or an allomorph form. If there is constant segmental material that precedes or follows the reduplicated material, put that segmental material before or after the full reduplication pattern indicator. For example, for the Bahasa Indonesia data above, we would include a hyphen before the indicator<indexedRangeEnd
begin="bFullReduplication"
></indexedRangeEnd
>.<endnote
id="nFullExample"
><p
>Thus, it would be keyed as <object
type="TT"
>-[...]</object
> where we would put the hyphen before the indicator because the hyphen would be part of the suffix. You can put anything before or after the indicator. <indexedItem
term="iBahasaIndonesia"
></indexedItem
>For example, if you used <object
type="TT"
>t[...]-</object
> and made it be a prefix, then this would match a full reduplication morpheme in a form such as <langData
lang="lBahasaIndonesia"
>tabrak-menabrak</langData
>  ‘<gloss
lang="lGloss"
>keep on running into</gloss
>,’  where we would model the <langData
lang="lBahasaIndonesia"
>men</langData
> as an infix and the <langData
lang="lBahasaIndonesia"
>abrak</langData
> would be the truncated allomorph of the stem <langData
lang="lBahasaIndonesia"
>tabrak</langData
>  ‘<gloss
lang="lGloss"
>to.collide</gloss
>.’</p
></endnote
></li
><li
>Optionally label the morpheme using the Citation Form field (e.g., <object
type="TT"
>RDP-</object
> or <object
type="TT"
>CVC-</object
>).</li
></ol
></li
></ol
></chart
></example
></section4
></section3
><section3
id="sReduplicationPartial"
><secTitle
>Partial Reduplication</secTitle
><p
><indexedRangeBegin
id="bPartialReduplication"
main="yes"
term="iRedupPartial"
></indexedRangeBegin
>As we saw in the <indexedItem
term="iTagalog"
></indexedItem
>Tagalog data from <exampleRef
equal="no"
letterOnly="no"
num="xTagalogReduplication"
></exampleRef
> from section <sectionRef
sec="sIssueReduplication"
></sectionRef
>, it is not always the case that the entire stem is reduplicated. The Tagalog data is repeated here.</p
><example
num="xTagalogReduplication2"
><listWord
letter="xSusulat2"
><langData
lang="lTagalog"
>susulat</langData
><gloss
lang="lGloss"
>‘to write (imperfective)’</gloss
><gloss
lang="lGloss"
><exampleRef
equal="yes"
letter="xTagalogReduplication"
num="xTagalogReduplication"
></exampleRef
></gloss
></listWord
><listWord
letter="xMagpasulat2"
><langData
lang="lTagalog"
>magpasulat</langData
><gloss
lang="lGloss"
>‘to make someone write (perfective)’</gloss
></listWord
><listWord
letter="xMagpapasulat2"
><langData
lang="lTagalog"
>magpapasulat</langData
><gloss
lang="lGloss"
>‘to make someone write (imperfective)’</gloss
></listWord
></example
><p
>Recall that we saw that this is a case where the imperfective aspect is realized by reduplicating the first <indexedItem
term="iSyllable"
></indexedItem
>CV syllable of the stem to which it attaches. (The <langData
lang="lTagalog"
>mag</langData
>- prefix is what some call actor focus or actor voice.)</p
><p
>Now consider the following <indexedItem
term="iOrizabaNahuatl"
></indexedItem
>Orizaba Nahuatl data:<endnote
id="nNahuatlRedup"
><p
>Data are from <citation
author="yes"
page="41"
ref="rTuggyCurso"
></citation
>. The hyphens are not part of the orthography but are included to clarify the relevant morphemes involved.</p
></endnote
></p
><example
num="xNahuatlRedup1"
><listWord
letter="xNahuatlRedup1a"
><langData
lang="lNahuatl"
>tone</langData
><gloss
lang="lGloss"
>(the sun) shines</gloss
></listWord
><listWord
letter="xNahuatlRedup1b"
><langData
lang="lNahuatl"
>toh-tone</langData
><gloss
lang="lGloss"
>(the sun) burns</gloss
></listWord
></example
><example
num="xNahuatlRedup2"
><listWord
letter="xNahuatlRedup2a"
><langData
lang="lNahuatl"
>chipin-tok</langData
><gloss
lang="lGloss"
>it is dripping</gloss
></listWord
><listWord
letter="xNahuatlRedup2b"
><langData
lang="lNahuatl"
>chih-chipin-tok</langData
><gloss
lang="lGloss"
>it is dripping and dripping</gloss
></listWord
></example
><p
>What is the reduplication pattern here? It is the initial CV of the stem followed by an <langData
lang="lNahuatl"
>h</langData
>. Thus we see that in this Nahuatl case of reduplication, there is not only the copied material, but also some fixed segmental material.</p
><p
>The kind of reduplication illustrated in <exampleRef
equal="no"
letterOnly="no"
num="xTagalogReduplication2"
></exampleRef
>-<exampleRef
equal="no"
letterOnly="no"
num="xNahuatlRedup2"
></exampleRef
> above is often referred to as <object
type="Definition"
>partial reduplication</object
>. How do we model such partial reduplication in <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
>? (See <appendixRef
app="sHCRedupPartial"
></appendixRef
> for how to write an affix process for partial reduplication using the new <object
type="HermitCrab"
></object
>.)</p
><example
num="xPartialReduplicationHowTo"
><chart
type="HowTo"
><ol
><li
>Determine whether the reduplication morpheme is derivational or inflectional.</li
><li
>Determine what the reduplication pattern is (see section <sectionRef
sec="sReduplicationPartialPatternStage1"
></sectionRef
>).</li
><li
>Create any needed natural classes of segments that are in the pattern (see section <sectionRef
sec="sNatClasses"
></sectionRef
>).</li
><li
>Create an environment that has the reduplication pattern either before or after the reduplication morpheme (depending, of course, on whether what is reduplicated comes after or before the “stem”). See section <sectionRef
sec="sEnvironments"
></sectionRef
>.</li
><li
>Create a lexical entry for the reduplication morpheme.<ol
><li
>Mark it as derivational or inflectional according to what you determined.</li
><li
>In lexeme form (or in an allomorph form), type in the reduplication pattern.</li
><li
>Condition that allomorph to use the environment you created above.</li
><li
>Optionally label the morpheme using the Citation Form field (e.g., <object
type="TT"
>RDP-</object
> or <object
type="TT"
>CVC-</object
>).</li
></ol
></li
></ol
></chart
></example
><section4
id="sReduplicationPartialPatternStage1"
><secTitle
>Writing the Pattern for Partial Reduplication (for Stage 1 of <object
type="WordWorks"
></object
>)</secTitle
><p
><indexedItem
term="iEnvReduplication"
></indexedItem
>For <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
>, we use a special notation to indicate a partial reduplication pattern.<endnote
id="nRedupPattern"
><p
>It is the same notation as used in <indexedItem
term="iXAmple"
></indexedItem
>AMPLE.</p
></endnote
> The idea is to list a sequence of specially marked natural class names. The special marking consists of the following:</p
><example
num="xRedupPatternSchema"
><chart
><ol
><li
><object
type="TT"
>[</object
> (i.e. a left square bracket)</li
><li
>the abbreviation of the natural class</li
><li
><object
type="TT"
>^</object
> (i.e. the caret character - a shift-6 on many keyboards)</li
><li
>a positive integer number (usually <object
type="TT"
>1</object
>, <object
type="TT"
>2</object
>, or <object
type="TT"
>3</object
>) which is an index indicating matching items between the allomorph and the environment</li
><li
><object
type="TT"
>]</object
> (i.e. a right square bracket)</li
></ol
></chart
></example
><p
>Suppose we have a natural class for consonants with an abbreviation of <object
type="TT"
>C</object
> and one for vowels abbreviated as <object
type="TT"
>V</object
>. Then the reduplication patterns for our Tagalog and Orizaba Nahuatl reduplication examples above in <exampleRef
equal="no"
letterOnly="no"
num="xTagalogReduplication2"
></exampleRef
> and <exampleRef
equal="no"
letterOnly="no"
num="xNahuatlRedup1"
></exampleRef
>‑<exampleRef
equal="no"
letterOnly="no"
num="xNahuatlRedup2"
></exampleRef
> would be as in <exampleRef
equal="no"
letterOnly="no"
num="xRedupPatternExamples"
></exampleRef
>.</p
><example
num="xRedupPatternExamples"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Language</th
><th
align="left"
valign="top"
>Allomorph</th
><th
align="left"
valign="top"
>Environment</th
></tr
><tr
><td
align="left"
valign="top"
>Tagalog</td
><td
align="left"
valign="top"
><object
type="TT"
>[C^1][V^1]</object
></td
><td
align="left"
valign="top"
><object
type="TT"
>/ _ [C^1][V^1]</object
></td
></tr
><tr
><td
align="left"
valign="top"
>Orizaba Nahuatl</td
><td
align="left"
valign="top"
><object
type="TT"
>[C^1][V^1]h</object
></td
><td
align="left"
valign="top"
><object
type="TT"
>/ _ [C^1][V^1]</object
></td
></tr
></table
></example
><p
>For the Orizaba Nahuatl case, notice the use of the <langData
lang="lNahuatl"
>h</langData
> (the fixed segmental material) in the allomorph pattern. It is not included in the environment pattern for the simple reason that the <langData
lang="lNahuatl"
>h</langData
> does not show up in the environment.</p
><p
>Note that if a language has a CVC reduplication pattern, then one would want to use a pattern of <object
type="TT"
>[C^1][V^1][C^2]</object
>, where the distinct indices on the consonant natural classes makes it clear that they can be different<indexedRangeEnd
begin="bPartialReduplication"
></indexedRangeEnd
><indexedRangeEnd
begin="bReduplication"
></indexedRangeEnd
>.</p
></section4
></section3
></section2
><section2
id="sInfixation"
><secTitle
>Infixation</secTitle
><p
><indexedRangeBegin
id="bInfixation"
main="yes"
term="iInfixation"
></indexedRangeBegin
>We now address another issue from section <sectionRef
sec="sKeyIssues"
></sectionRef
>: infixation. We repeat here the <indexedItem
term="iTagalog"
></indexedItem
>Tagalog data from example <exampleRef
equal="no"
letterOnly="no"
num="xTagalogInfixation"
></exampleRef
> in section <sectionRef
sec="sIssueInfixation"
></sectionRef
>.</p
><example
num="xTagalogInfixation2"
><listWord
letter="xSulat2"
><langData
lang="lTagalog"
>sulat</langData
><gloss
lang="lGloss"
>‘to write or writing (infinitive form)’</gloss
><gloss
lang="lGloss"
><exampleRef
equal="yes"
letter="xTagalogInfixation"
num="xTagalogInfixation"
></exampleRef
></gloss
></listWord
><listWord
letter="xSumulat2"
><langData
lang="lTagalog"
>sumulat</langData
><gloss
lang="lGloss"
>‘to write (with actor focus)’</gloss
></listWord
><listWord
letter="xSinulat2"
><langData
lang="lTagalog"
>sinulat</langData
><gloss
lang="lGloss"
>‘to write (with object focus)’</gloss
></listWord
></example
><p
>Recall that there are two focus morphemes here, ‑<langData
lang="lTagalog"
>um</langData
>‑ and ‑<langData
lang="lTagalog"
>in</langData
>‑, both of which are infixes.</p
><p
>How does one create such infixes in <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
>? (See <appendixRef
app="sHermitCrabInfixation"
></appendixRef
> for how to write an affix process for infixation using the new <object
type="HermitCrab"
></object
>.)</p
><example
num="xInfixHowTo"
><chart
type="HowTo"
><ol
><li
>Determine the environment(s) of the infix with respect to the stem in which it infixes (see <sectionRef
sec="sInfixationEnvironments"
></sectionRef
>) below.</li
><li
>Add the environment(s) if needed (and any natural classes, too) in the Grammar area.</li
><li
>Create the lexical entry and its allomorph.</li
><li
>Mark the allomorph as being an infix.</li
><li
>Set the infix position to the environment(s).</li
></ol
></chart
></example
><p
>Note that infix allomorphs may be conditioned by <indexedItem
term="iAlloEnvironments"
></indexedItem
>regular environments just like any other allomorph. See section <sectionRef
sec="sEnvironments"
></sectionRef
>. With the Stage 1 parser, these environments should be with respect to what the environment is <object
type="InFocus"
>before</object
> the infix has been pulled out of the stem.</p
><section3
id="sInfixationEnvironments"
><secTitle
>Writing the Infixation environment (for Stage 1 of <object
type="WordWorks"
></object
>)</secTitle
><p
><indexedItem
term="iEnvInfix"
></indexedItem
>Infix environments describe the location within the sequence of characters where the infix is to go.<endnote
id="nInfixEnvironments"
><p
>The notation used for these infix environments is the same notation as used for infixes in <indexedItem
term="iXAmple"
></indexedItem
>AMPLE.</p
></endnote
> For example, in <exampleRef
equal="no"
letterOnly="no"
num="xTagalogInfixation2"
></exampleRef
>, it would be within <langData
lang="lTagalog"
>sulat</langData
> between the initial <langData
lang="lTagalog"
>s</langData
> and <langData
lang="lTagalog"
>ulat</langData
>. The environment would then be <object
type="TT"
>/ # [C] _ [V]</object
> where <object
type="TT"
>#</object
> indicates the beginning of the sequence within the stem, <object
type="TT"
>[C]</object
> is the natural class of consonants and <object
type="TT"
>[V]</object
> is the natural class of vowels.  Note that with the infixation environment, the <object
type="TT"
>#</object
> does not indicate word boundary, but rather the beginning of the stem.</p
></section3
><section3
id="sInfixationRootAndPattern"
><secTitle
>Infixation and Root and Pattern Morphology</secTitle
><p
><indexedItem
main="yes"
term="iRootAndPatternMorphology"
></indexedItem
><indexedItem
term="iSemitic"
></indexedItem
>In section <sectionRef
sec="sIssueRootAndPatternMorphology"
></sectionRef
> we noted the <indexedItem
term="iSilti"
></indexedItem
>Silt'i data repeated here from <exampleRef
equal="no"
letterOnly="no"
num="xSilti"
></exampleRef
>:<endnoteRef
note="nSilti"
></endnoteRef
></p
><example
num="xSilti2"
><interlinear
><lineGroup
><line
><wrd
><langData
lang="lSilti"
>wakaba</langData
></wrd
><wrd
><exampleRef
equal="yes"
letter="xSilti"
num="xSilti"
></exampleRef
></wrd
></line
><line
><wrd
><langData
lang="lSilti"
>a-a-wkb-a</langData
></wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>PERF-buy-3rdSgPERF</gloss
></wrd
></line
></lineGroup
><free
>‘he bought’</free
></interlinear
></example
><p
>We noted that such Semitic languages have roots composed of three consonants, as exemplified in the Silt'i data in <exampleRef
equal="no"
letterOnly="no"
num="xSilti2"
></exampleRef
>, where ‘buy’ is the root <langData
lang="lSilti"
>wkb</langData
>. The aspect markers are composed of vowel patterns that fit between or around the root consonants, such as the <langData
lang="lSilti"
>a-a</langData
> vowel pattern indicating the perfective aspect shown in <exampleRef
equal="no"
letterOnly="no"
num="xSilti2"
></exampleRef
>.</p
><p
>How does one model this in <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
>? (See <appendixRef
app="sInfixationRootAndPatternAsProcess"
></appendixRef
> for how to write an affix process for this using the new <object
type="HermitCrab"
></object
>.)The basic idea is to treat each vowel as an infix.</p
><example
num="xInfixationRootAndPatternHowTo"
><chart
type="HowTo"
><ol
><li
>One needs to model each vowel as a separate infix. Thus, the perfective aspect has to be treated as two parts: The first ‑<langData
lang="lSilti"
>a</langData
>‑ is part one and the second ‑<langData
lang="lSilti"
>a</langData
>‑ is part two. The result would then “pull out” the infixes in front of the root. That is, the resulting analysis would look something like what is in <exampleRef
equal="no"
letterOnly="no"
num="xSiltiAnalysis"
></exampleRef
>.</li
><li
>Assuming that perfective aspect is inflectional, then one would build an <indexedItem
term="iInflectionalTemplate"
></indexedItem
>inflectional template that had both parts as slots in the template. The template might look like the one in <exampleRef
equal="no"
letterOnly="no"
num="xSiltiTemplate"
></exampleRef
>.</li
></ol
></chart
></example
><example
num="xSiltiAnalysis"
><interlinear
><lineGroup
><line
><langData
lang="lSilti"
>wakaba</langData
></line
><line
><langData
lang="lSilti"
>a-a-wkb-a</langData
></line
><line
><gloss
lang="lGloss"
>Perf1-Perf2-buy-3rdSgPerf</gloss
></line
></lineGroup
></interlinear
></example
><example
num="xSiltiTemplate"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Aspect 1</th
><th
align="left"
valign="top"
>Aspect 2</th
><th
align="left"
valign="top"
>Stem</th
><th
align="left"
valign="top"
>Subject</th
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‑Perf1‑</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
>etc.</td
></tr
></table
></td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‑Perf2‑</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
>etc.</td
></tr
></table
></td
><td
> </td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‑3rdSgPerf</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
>etc.<indexedRangeEnd
begin="bInfixation"
></indexedRangeEnd
></td
></tr
></table
></td
></tr
></table
></example
></section3
></section2
><section2
id="sEpenthesis"
><secTitle
>Epenthesis</secTitle
><p
><indexedItem
term="iEpenthesis"
></indexedItem
>In section <sectionRef
sec="sIssueEpenthesis"
></sectionRef
> we noted the <indexedItem
term="iCaquinte"
></indexedItem
>Caquinte data repeated here from <exampleRef
equal="no"
letterOnly="no"
num="xEpenthesis"
></exampleRef
>.<endnoteRef
note="nEpenthesis"
></endnoteRef
></p
><example
num="xEpenthesis2"
><interlinear
><lineGroup
><line
><wrd
><langData
lang="lCaquinte"
>itsavetakohitiro</langData
></wrd
><wrd
><exampleRef
equal="yes"
letter="xEpenthesis"
num="xEpenthesis"
></exampleRef
></wrd
></line
><line
><wrd
><langData
lang="lCaquinte"
>i-tsave-(t)-ako-hi-(t)-i-ro</langData
></wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>3M-tell- -DAT-PAS- -NF-3FO</gloss
></wrd
></line
></lineGroup
><free
>‘she is told about’</free
></interlinear
></example
><p
>Recall that this is an instance of epenthesis. Many languages have certain <indexedItem
term="iSyllable"
></indexedItem
>syllable well-formedness constraints that require the insertion of either a vowel or a consonant to preserve syllable structure (see <citation
author="yes"
paren="none"
ref="rIto1989"
></citation
> for an interesting discussion). In the data above it is a consonant <langData
lang="lCaquinte"
>t</langData
>.</p
><p
>How can one model such epenthetic segments within <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
>? There are at least two ways:</p
><example
num="xEpenthesisHowTo"
><chart
type="HowTo"
><ol
><li
>The first method is to treat the epenthetic segment as a kind of pseudo morpheme.</li
><li
>The second is to create extra allomorphs containing the epenthetic segment(s) for every morpheme that might possibly be involved with epenthesis and using environments to condition them appropriately.</li
></ol
></chart
></example
><p
>The advisability of the use of the first method is debatable. If the epenthetic segment is rather common, then one might want to model it as a pseudo-morpheme. Such an approach allows you to use the output of <object
type="WordWorks"
></object
> to explore where it occurs and perhaps glean some insights about its true nature. The second approach captures the fact that epenthesis has no meaning whatsoever (as one would expect with a true morpheme) but it misses the generalization that the presence of the segment is due to syllabification considerations (by adding otherwise unnecessary allomorphs to many dictionary entries). <indexedItem
term="iStage1"
></indexedItem
><indexedItem
main="yes"
term="iSyllable"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
> does not model syllables.</p
></section2
><section2
id="sMetathesis"
><secTitle
>Metathesis</secTitle
><p
><indexedItem
main="yes"
term="iMetathesis"
></indexedItem
>Another morphophonemic issue we noted in section <sectionRef
sec="sKeyIssues"
></sectionRef
> was metathesis. We repeat the <indexedItem
term="iCaquinte"
></indexedItem
>Caquinte word in <exampleRef
equal="no"
letterOnly="no"
num="xCaquinteMetathesis"
></exampleRef
> given in section <sectionRef
sec="sIssuesMetathesis"
></sectionRef
>.</p
><example
num="xCaquinteMetathesis2"
><interlinear
><lineGroup
><line
><wrd
lang="lCaquinte"
>ihikeke<object
type="InFocus"
>ha</object
>i</wrd
><wrd
><exampleRef
equal="yes"
letter="xCaquinteMetathesis"
num="xCaquinteMetathesis"
></exampleRef
></wrd
></line
><line
><wrd
lang="lCaquinte"
>i-hi-k-e-ke<object
type="InFocus"
>a-h</object
>i</wrd
></line
><line
><wrd
lang="lGloss"
>3M-to.think.mistakenly-PROG-NF-FOC-NEG</wrd
></line
></lineGroup
><free
>‘he thought mistakenly’</free
></interlinear
></example
><p
>Recall that the <langData
lang="lCaquinte"
>h</langData
> and <langData
lang="lCaquinte"
>a</langData
> in the final two morphemes switch positions.</p
><p
>How does one model such metathesis processes in <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
>? Since Stage 1 does not have any way to model processes, one must use allomorphy. For data like that in Caquinte, one would</p
><example
num="xMetathesisHowTo"
><chart
type="HowTo"
><ol
><li
>In the lexical entry for <langData
lang="lCaquinte"
>kea</langData
>, create an allomorph of <langData
lang="lCaquinte"
>keh</langData
> and condition it to be followed by an <langData
lang="lCaquinte"
>a</langData
> (i.e. write an environment of <object
type="TT"
>/ _ a</object
>).</li
><li
>In the lexical entry for <langData
lang="lCaquinte"
>hi</langData
>, create an allomorph of <langData
lang="lCaquinte"
>ai</langData
> and condition it to be preceded by a <langData
lang="lCaquinte"
>h</langData
> (i.e. write an environment of <object
type="TT"
>/ h _ </object
>).</li
></ol
></chart
></example
></section2
><section2
id="sMorphemeNotSurface"
><secTitle
>Morphemes that May Be Null</secTitle
><p
><indexedItem
term="iNullAllomorph"
></indexedItem
>Recall that in section <sectionRef
sec="sIssuesMorphemeNotSurface"
></sectionRef
> we noted some other <indexedItem
term="iCaquinte"
></indexedItem
>Caquinte data in <exampleRef
equal="no"
letterOnly="no"
num="xCaquintePrefix"
></exampleRef
> repeated here (you do not need to understand all the morpheme glosses here; just concentrate on the initial subject prefixes):</p
><example
num="xCaquintePrefix2"
><listInterlinear
letter="xCaquintePrefix2A"
><lineGroup
><line
><wrd
lang="lCaquinte"
><object
type="InFocus"
>a</object
>nehero</wrd
><wrd
><exampleRef
equal="yes"
letter="xCaquintePrefix"
num="xCaquintePrefix"
></exampleRef
></wrd
></line
><line
><wrd
lang="lCaquinte"
><object
type="InFocus"
>a</object
>-0-neh-e-ro</wrd
></line
><line
><wrd
lang="lGloss"
><object
type="InFocus"
>1I</object
>-FUT-see-F-3FO</wrd
></line
></lineGroup
><free
>‘we will see her’</free
></listInterlinear
><listInterlinear
letter="xCaquintePrefix2O"
><lineGroup
><line
><wrd
lang="lCaquinte"
><object
type="InFocus"
>o</object
>keekake</wrd
></line
><line
><wrd
lang="lCaquinte"
><object
type="InFocus"
>o</object
>-keek-ak-e</wrd
></line
><line
><wrd
lang="lGloss"
><object
type="InFocus"
>3F</object
>-dig-PERF-NF</wrd
></line
></lineGroup
><free
>‘she had dug’</free
></listInterlinear
><listInterlinear
letter="xCaquintePrefix20"
><lineGroup
><line
><wrd
><langData
lang="lCaquinte"
>oasanomahakemparime</langData
></wrd
></line
><line
><wrd
lang="lCaquinte"
><object
type="InFocus"
>0</object
>-0-o-(a)-sano-maha-k-e-Npa-ri-me</wrd
></line
><line
><wrd
lang="lGloss"
><object
type="InFocus"
>1I</object
>-FUT-eat- -VERI.M-VERI-PROG-F-R-3MO-CNTR</wrd
></line
><line
><wrd
lang="lGloss"
><object
type="InFocus"
>3F</object
>-FUT-eat- -VERI.M-VERI-PROG-F-R-3MO-CNTR</wrd
></line
></lineGroup
><free
>‘we/she will not really be eating it’</free
></listInterlinear
></example
><p
>What is the issue with the subject prefixes? In <exampleRef
equal="no"
letter="xCaquintePrefix2A"
letterOnly="no"
></exampleRef
> we see that the first person inclusive subject marker is <langData
lang="lCaquinte"
>a</langData
>‑, and in <exampleRef
equal="no"
letter="xCaquintePrefix2O"
letterOnly="no"
></exampleRef
> the third person feminine subject marker is <langData
lang="lCaquinte"
>o</langData
>‑. Yet, in <exampleRef
equal="no"
letter="xCaquintePrefix20"
letterOnly="no"
></exampleRef
>, the gloss shows ambiguity between ‘we’ and ‘she’ as the subject, and both of these are represented as null. This is because both subject prefixes are vowels and the stem in <exampleRef
equal="no"
letter="xCaquintePrefix20"
letterOnly="no"
></exampleRef
> is vowel-initial, yielding two vowels together. Recall from <exampleRef
equal="no"
letterOnly="no"
num="xEpenthesis2"
></exampleRef
> that Caquinte generally does not allow vowel clusters, and therefore adds an epenthetic ‑<langData
lang="lCaquinte"
>t</langData
>‑ when necessary to avoid such clusters. It turns out that epenthesis is only used in the suffixes. Within the prefixes, the initial vowel of a cluster deletes, causing the ambiguity seen in <exampleRef
equal="no"
letter="xCaquintePrefix20"
letterOnly="no"
></exampleRef
>.</p
><p
>How does one model such allomorphy in <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
>?</p
><example
num="xMorphemeNotSurfaceHowTo"
><chart
type="HowTo"
><ol
><li
>Ensure that you have a natural class for vowels.</li
><li
>Create or check that you have an environment that is before a vowel.</li
><li
>Create the lexical entries for the two prefixes.</li
><li
>In each one, create two forms:<ol
><li
>Create one for the null allomorph (see section <sectionRef
sec="sAllomorphsNull"
></sectionRef
>) and condition it as occurring before a vowel (i.e. use the “before a vowel” environment). This should be in an allomorph form.</li
><li
>Create one for the overt form (<langData
lang="lCaquinte"
>a</langData
> or <langData
lang="lCaquinte"
>o</langData
>) in the lexeme form. It does not need to be conditioned by an environment if it is in the lexeme form because it will be the “elsewhere” allomorph.</li
></ol
></li
></ol
></chart
></example
></section2
><section2
id="sNonPhonologicallyConditionedAllomorphy"
><secTitle
>Non-phonologically Conditioned Allomorphy</secTitle
><p
>Sometimes there is unpredictable allomorphy in either stems or in affixes. How does one deal with these? We have already seen how to deal with affix allomorphy determined by inflection classes in section <sectionRef
sec="sInflAffixInflectionClasses"
></sectionRef
>. The following two subsections explain how to use morpho-syntactic features to control both stem allomorphy and affix allomorphy.</p
><section3
id="sStemNames"
><secTitle
>Stem Allomorphs Conditioned by Morpho-syntactic Features</secTitle
><p
><indexedItem
term="iStemNames"
></indexedItem
><indexedItem
term="iInflFeatAllomorphy"
></indexedItem
><indexedItem
term="iInflFeatRuleOutParses"
></indexedItem
>The next morphophonemic issue we address relates to dealing with various inflectional stems which can appear in word paradigms. For example, consider the following data from <indexedItem
term="iOrizabaNahuatl"
></indexedItem
>Orizaba Nahuatl.<endnote
id="nNahuatlStemName"
><p
>Data are from <citation
page="102"
ref="rTuggyCurso"
></citation
>. The abbreviations used in the <indexedItem
term="iOrizabaNahuatl"
></indexedItem
>Nahuatl data are:</p
><table
border="1"
type="LessSpaceBeforeTable"
><tr
><th
align="left"
valign="top"
>Abbreviation</th
><th
align="left"
valign="top"
>Meaning</th
></tr
><tr
><td
align="left"
valign="top"
>1SgSubj</td
><td
align="left"
valign="top"
>1st person singular subject</td
></tr
><tr
><td
align="left"
valign="top"
>1PlSubj</td
><td
align="left"
valign="top"
>1st person plural subject</td
></tr
><tr
><td
align="left"
valign="top"
>3Obj</td
><td
align="left"
valign="top"
>3rd person object</td
></tr
><tr
><td
align="left"
valign="top"
>ImpfvPl</td
><td
align="left"
valign="top"
>plural imperfective</td
></tr
><tr
><td
align="left"
valign="top"
>PerfvPl</td
><td
align="left"
valign="top"
>plural perfective</td
></tr
></table
></endnote
></p
><example
num="xNahuatlStemName"
><table
border="1"
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>to.want</gloss
></td
><td
align="left"
valign="top"
>1st Person Singular Subject</td
><td
align="left"
valign="top"
>1st Person Plural Subject</td
></tr
><tr
><td
align="left"
valign="top"
>Present tense</td
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>nikneki</langData
></line
><line
><langData
lang="lNahuatl"
>ni-k-neki</langData
></line
><line
><gloss
lang="lGloss"
>1SgSubj-3Obj-to.want</gloss
></line
></lineGroup
></interlinear
></td
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>tiknekih</langData
></line
><line
><langData
lang="lNahuatl"
>ti-k-neki-h</langData
></line
><line
><gloss
lang="lGloss"
>1PlSubj-3Obj-to.want-ImpfvPl</gloss
></line
></lineGroup
></interlinear
></td
></tr
><tr
><td
align="left"
valign="top"
>Past tense</td
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>oniknek</langData
></line
><line
><langData
lang="lNahuatl"
>o-ni-k-nek</langData
></line
><line
><gloss
lang="lGloss"
>Past-1SgSubj-3Obj-to.want</gloss
></line
></lineGroup
></interlinear
></td
><td
align="left"
valign="top"
><interlinear
><lineGroup
><line
><langData
lang="lNahuatl"
>otiknekkeh</langData
></line
><line
><langData
lang="lNahuatl"
>o-ti-k-nek-keh</langData
></line
><line
><gloss
lang="lGloss"
>Past-1PlSubj-3Obj-to.want-PerfvPl</gloss
></line
></lineGroup
></interlinear
></td
></tr
></table
></example
><p
>Notice the shape of the root. It is <langData
lang="lNahuatl"
>neki</langData
> in present tense, but merely <langData
lang="lNahuatl"
>nek</langData
> in the past tense. A more complete look at the rest of the verbal paradigm would show that the shorter <langData
lang="lNahuatl"
>nek</langData
> form also occurs with the pluperfect, the durative, and some special aspectuals. The longer <langData
lang="lNahuatl"
>neki</langData
> form occurs everywhere else in the verbal paradigm.<endnote
id="nNahuatlStemNameInflClass"
><p
>This variation of stem shape illustrated in <exampleRef
letter="xNahuatlStemName"
num="xNahuatlStemName"
></exampleRef
> occurs only for verbs in inflection class II. Verbs in inflection class III also have a similar, but slightly different, allomorphy that occurs in different parts of the verbal paradigm. Verbs in classes I and IV do not have any such allomorphy. See <citation
page="102-104"
ref="rTuggyCurso"
></citation
> for examples.</p
></endnote
></p
><p
>Further note that this truncation of the final vowel does not appear to be phonologically conditioned. Rather, it is conditioned by the <indexedItem
term="iInflectionFeature"
></indexedItem
>inflectional features of the word itself. If the word is in past tense (or is pluperfect or is durative or has one of the special aspectuals), then the truncated allomorph of the root is used. Otherwise, the longer form of the root is used.</p
><p
>So what we would need is “something” that allows us to define the sets of inflection features that must be present in order for a particular stem allomorph to be licit. We would then associate that particular stem allomorph with that “something” so that we and the parser both know that the allomorph can only occur when one of those feature sets is present. <indexedItem
term="iCategoryInflectableFeatures"
></indexedItem
>Further, since we are talking about inflection features, this “something” should be associated with the appropriate category which can inflect for the features contained in these sets. In the Nahuatl case, this would be the verb category.</p
><p
>So what is this “something” in <object
type="WordWorks"
></object
>? It is what we call Stem Names. Each Stem Name is defined in a particular category. Each Stem Name has one or more sets of inflection features associated with it. Whenever a stem allomorph is tagged with such a Stem Name, then the <object
type="WordWorks"
></object
> parser will only allow that allomorph to be valid if one of the sets of inflection features is present.</p
><p
>For example, for the Nahuatl case in <exampleRef
letter="xNahuatlStemName"
num="xNahuatlStemName"
></exampleRef
>, we could define a Stem Name of, say, <object
type="TT"
>Truncates</object
> and then make at least one feature set. But how many feature sets would we need? Remember that the truncated allomorph occurs whenever the word is past tense, pluperfect, durative, or has one of the special aspectuals. Suppose we made one feature set and put all four of these features in it. This would mean that the truncated allomorph would only be valid when the word had all four features. But that never happens because some of these features are mutually exclusive. This means we would need as many feature sets as there are mutually exclusive features. In this Nahuatl case, we would need to give it four feature sets, one each for the past tense, pluperfect, durative, and the special aspectuals. Then in the lexical entry for <langData
lang="lNahuatl"
>neki</langData
> we would add an allomorph of <langData
lang="lNahuatl"
>nek</langData
> and tag it as belonging to the Stem Name <object
type="TT"
>Truncates</object
>.</p
><p
>In this example, what should we do with the <langData
lang="lNahuatl"
>neki</langData
> allomorph? We have tagged the <langData
lang="lNahuatl"
>nek</langData
> allomorph with the <object
type="TT"
>Truncates</object
> Stem Name so we do not need to do anything to tag the <langData
lang="lNahuatl"
>neki</langData
> allomorph. The <object
type="WordWorks"
></object
> parser will automatically constrain the <langData
lang="lNahuatl"
>neki</langData
> allomorph so that it will not occur with any of the inflection features defined in the <object
type="TT"
>Truncates</object
> Stem Name. Similarly, if a lexical entry has three allomorphs, two of which need to be tagged with distinct Stem Names, then the third, untagged, one will automatically be constrained to never occur with any of the feature sets defined for the other two Stem Names associated with the other two allomorphs in that entry.</p
><p
>How does one create and use a Stem Name in <object
type="WordWorks"
></object
>?<comment
>Note: this is mostly repeated above in the xInflectionFeaturesHowTo example. Some of it is also repeated in the xDerivAffixInflectionFeaturesHowTo example.</comment
></p
><example
num="xStemNamesHowTo"
><chart
type="HowTo"
><ol
><li
>Unless you have already done so, set up the needed inflection features as follows: (this is repeated from <exampleRef
letter="xInflectionFeaturesHowTo"
num="xInflectionFeaturesHowTo"
></exampleRef
>).<ol
><li
>Determine the inflection feature involved, including its type,<endnoteRef
note="nInflectionFeature"
></endnoteRef
> name, and possible values. (You may want to look at <exampleRef
letter="xInflectionFeatures"
num="xInflectionFeatures"
></exampleRef
> or possibly check with a linguistic consultant.)<ol
><li
>Try using the Inflection Feature Catalog<endnoteRef
note="nInflectionFeatureCatalog"
></endnoteRef
> to see if the feature is already in the catalog. If so, add the feature via the catalog (it's much easier this way).</li
><li
>If the feature is not in the catalog, then<ol
><li
>If the feature type does not yet exist, add it to the feature types.</li
><li
>Create the feature and its values in the features section.</li
></ol
></li
></ol
></li
><li
>For each category which will use the feature, add the feature to the category's set of inflectable features.</li
><li
>For each inflectional affix needing the feature, add the feature and its appropriate value to the inflectional affix's grammatical information details.</li
></ol
></li
><li
>Create a Stem Name in the appropriate category (<indexedItem
term="iCategoryHierarchy"
></indexedItem
>sub-categories will inherit any Stem Names which their parent categories have, so you will probably want to create the Stem Name on the highest level category).<ol
><li
>Give the Stem Name a name, abbreviation, and description.</li
><li
>Create the sets of inflection features that are relevant to this Stem Name. That is, create one feature set for each mutually exclusive set of features that go on words in which this allomorph occurs.</li
></ol
></li
><li
>Tag all appropriate stem allomorphs with the Stem Name. Note that you may need to Show Hidden Fields to see the Stem Name field. (Remember that you do not need to tag the other allomorphs unless they, too, have a limited set of inflection features. In this latter case, you will need to define yet another Stem Name for them.)</li
><li
>Make sure that you have at least one <indexedItem
term="iInflectionalTemplate"
></indexedItem
>inflectional template defined for the category (or categories) that use stem names.<endnote
id="nStemNamesNeedInflectionalTemplate"
><p
>The <object
type="WordWorks"
></object
> parser will only be able to correctly constrain stem allomorphs tagged with a stem name if an <indexedItem
term="iInflectionalTemplate"
></indexedItem
>inflectional template has been defined which has <indexedItem
term="iInflectionalSlot"
></indexedItem
>slots containing the inflectional affixes which bear the appropriate inflection features. For example, if you have verbal stems which have one shape when inflected in the past tense and another shape in all other tenses, then you will need to have at least one verbal inflectional template that has one or more slots containing these tense inflectional affixes. And, of course, these inflectional affixes will have to be overtly tagged with the appropriate tense feature (e.g. past tense, present tense, etc.).</p
></endnote
> See section <sectionRef
sec="sInflectionalAffixes"
></sectionRef
> for more on inflectional templates.</li
></ol
></chart
></example
><p
>To summarize, one should use Stem Names to control stem allomorphy that is dependent not on phonological issues, but on the presence of certain inflection features. Note that Stem Names can only be used for stem allomorphs (not affix allomorphs).</p
><p
>Finally, note that <indexedItem
term="iDerivationalAffix"
></indexedItem
>derivational affixes may also be constrained to only occur with a particular Stem Name.<endnote
id="nStemNamesDerivAffix"
><p
>I do not have any data examples for this (yet), but our conceptual model allows for it. If you find it in your data, please let me know.</p
></endnote
></p
></section3
><section3
id="sAffixAlloFeats"
><secTitle
>Affix Allomorphs Conditioned by Morpho-syntactic Features</secTitle
><p
><indexedItem
term="iAffixAlloFeats"
></indexedItem
><indexedItem
term="iInflFeatAllomorphy"
></indexedItem
><indexedItem
term="iInflFeatRuleOutParses"
></indexedItem
>In section <sectionRef
sec="sStemNames"
></sectionRef
> we discuss how to control stem allomorphy based on sets of morpho-syntactic (inflection) features.<endnote
id="nMSFeatNotPhonfeat"
><p
>These kinds of features are to be contrasted with phonological features.</p
></endnote
> This section deals with something similar, but for affixes, not for stems. For example, consider the following data from <indexedItem
term="iAxinincaCampa"
></indexedItem
>Axininca Campa.<endnote
id="nAxinincaCampa"
><p
>The Axininca Campa data are from <citation
page="234"
ref="rAxinincaCampa"
></citation
> (see also page 36). The abbreviations used in the Axininca Campa data are:</p
><table
border="1"
><tr
><th
>Abbreviation</th
><th
>Meaning</th
></tr
><tr
><td
>1</td
><td
>first person</td
></tr
><tr
><td
>2</td
><td
>second person</td
></tr
><tr
><td
>3</td
><td
>third person</td
></tr
><tr
><td
>f</td
><td
>feminine</td
></tr
><tr
><td
>m</td
><td
>masculine</td
></tr
><tr
><td
>nf</td
><td
>non-future</td
></tr
><tr
><td
>obj</td
><td
>object</td
></tr
><tr
><td
>prf</td
><td
>perfect</td
></tr
></table
></endnote
></p
><table
border="1"
><tr
><td
><example
num="xAxinincaCutNonFuture"
><listInterlinear
letter="xAxinincaCutNonFuture1Obj"
><lineGroup
><line
><wrd
><langData
lang="lAxinincaCampa"
>itʃʰikana</langData
></wrd
></line
><line
><wrd
><langData
lang="lAxinincaCampa"
>i-tʃʰik-<object
type="Bold"
>a</object
>-na</langData
></wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>3m-cut-nf-1obj</gloss
></wrd
></line
></lineGroup
><free
>“he cut me”</free
></listInterlinear
><listInterlinear
letter="xAxinincaCutNonFuture2Obj"
><lineGroup
><line
><wrd
><langData
lang="lAxinincaCampa"
>itʃʰikimi</langData
></wrd
></line
><line
><wrd
><langData
lang="lAxinincaCampa"
>i-tʃʰik-<object
type="Bold"
>i</object
>-mi</langData
></wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>3m-cut-nf-2obj</gloss
></wrd
></line
></lineGroup
><free
>“he cut you”</free
></listInterlinear
><listInterlinear
letter="xAxinincaCutNonFuture3mObj"
><lineGroup
><line
><wrd
lang="lAxinincaCampa"
>itʃʰikiri</wrd
></line
><line
><wrd
lang="lAxinincaCampa"
>i-tʃʰik-<object
type="Bold"
>i</object
>-ri</wrd
></line
><line
><wrd
lang="lGloss"
>3m-cut-nf-3mobj</wrd
></line
></lineGroup
><free
>“he cut him”</free
></listInterlinear
><listInterlinear
letter="xAxinincaCutNonFuture3fObj"
><lineGroup
><line
><wrd
lang="lAxinincaCampa"
>itʃʰikiro</wrd
></line
><line
><wrd
lang="lAxinincaCampa"
>i-tʃʰik-<object
type="Bold"
>i</object
>-ro</wrd
></line
><line
><wrd
lang="lGloss"
>3m-cut-nf-3fobj</wrd
></line
></lineGroup
><free
>“he cut her”</free
></listInterlinear
></example
></td
><td
><example
num="xAxinincaCutNonFuturePerf"
><listInterlinear
letter="xAxinincaCutNonFuturePerf1Obj"
><lineGroup
><line
><wrd
><langData
lang="lAxinincaCampa"
>itʃʰikakina</langData
></wrd
></line
><line
><wrd
><langData
lang="lAxinincaCampa"
>i-tʃʰik-ak-<object
type="Bold"
>i</object
>-na</langData
></wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>3m-cut-prf-nf-1obj</gloss
></wrd
></line
></lineGroup
><free
>“he has cut me”</free
></listInterlinear
><listInterlinear
letter="xAxinincaCutNonFuturePerf2Obj"
><lineGroup
><line
><wrd
><langData
lang="lAxinincaCampa"
>itʃʰikakimi</langData
></wrd
></line
><line
><wrd
><langData
lang="lAxinincaCampa"
>i-tʃʰik-ak-<object
type="Bold"
>i</object
>-mi</langData
></wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>3m-cut-prf-nf-2obj</gloss
></wrd
></line
></lineGroup
><free
>“he has cut you”</free
></listInterlinear
><listInterlinear
letter="xAxinincaCutNonFuturePerf3mObj"
><lineGroup
><line
><wrd
><langData
lang="lAxinincaCampa"
>itʃʰikakiri</langData
></wrd
></line
><line
><wrd
><langData
lang="lAxinincaCampa"
>i-tʃʰik-ak-<object
type="Bold"
>i</object
>-ri</langData
></wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>3m-cut-prf-nf-3mobj</gloss
></wrd
></line
></lineGroup
><free
>“he has cut him”</free
></listInterlinear
><listInterlinear
letter="xAxinincaCutNonFuturePerf3fObj"
><lineGroup
><line
><wrd
><langData
lang="lAxinincaCampa"
>itʃʰikakiro</langData
></wrd
></line
><line
><wrd
><langData
lang="lAxinincaCampa"
>i-tʃʰik-ak-<object
type="Bold"
>i</object
>-ro</langData
></wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>3m-cut-prf-nf-3fobj</gloss
></wrd
></line
></lineGroup
><free
>“he has cut her”</free
></listInterlinear
></example
></td
></tr
></table
><p
>Notice that in <exampleRef
letter="xAxinincaCutNonFuture"
num="xAxinincaCutNonFuture"
></exampleRef
>, the non-future suffix is ‑<langData
lang="lAxinincaCampa"
>i</langData
> except when it comes before the first person object marker ‑<langData
lang="lAxinincaCampa"
>na</langData
> where the non-future is ‑<langData
lang="lAxinincaCampa"
>a</langData
> <exampleRef
letter="xAxinincaCutNonFuture1Obj"
num="xAxinincaCutNonFuture1Obj"
></exampleRef
>. Example <exampleRef
letter="xAxinincaCutNonFuturePerf"
num="xAxinincaCutNonFuturePerf"
></exampleRef
> shows that when the non-future follows the perfect suffix, it is ‑<langData
lang="lAxinincaCampa"
>i</langData
> even when it comes before the first person object <exampleRef
letter="xAxinincaCutNonFuturePerf1Obj"
num="xAxinincaCutNonFuturePerf1Obj"
></exampleRef
>.</p
><p
>How does one model such allomorphy in <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
>? Since only allomorphy is available, one must create allomorphs for both forms of the non-future suffix and condition them to co-occur with the appropriate set of features.<endnote
id="nAffixAlloFeatsEnvironments"
><p
>In cases like Axininca Campa, merely using environments (see section <sectionRef
sec="sEnvironments"
></sectionRef
>) will not work properly due to the fact that one must identify the exact morpheme, not merely its surface form. Other morphemes may well share the same form, but the allomorphy of the non-future does not occur with them. It is only with the perfect suffix and the first person object suffix.</p
></endnote
></p
><example
num="xAffixAlloFeats"
><chart
type="HowTo"
><ol
><li
>Add the appropriate inflectional features.</li
><li
>Create the appropriate inflectional template.</li
><li
>Create an entry for each morpheme (assigning the inflectional affixes to the appropriate slots in the template).</li
><li
>Assign the appropriate inflectional features to those affixes which bear them.</li
><li
>For those entries with allomorphy, create the Allomorph Form(s).</li
><li
>For each Allomorph Form,<ol
><li
>In the “Required Features” field, set the inflectional features that this allomorph must have in order to be licit.</li
><li
>You can leave the Lexeme Form without any “Required Features” if it is the "elsewhere" case.</li
></ol
></li
></ol
></chart
></example
><p
>For the Axininca Campa data above, the verbal inflection features are for perfect aspect and for first person object agreement. We would need to create the appropriate inflectional suffixes and assign perfect aspect to the perfect ‑<langData
lang="lAxinincaCampa"
>ak</langData
> suffix and first person object agreement to the first person object ‑<langData
lang="lAxinincaCampa"
>na</langData
> suffix. For the non-future suffix, we would make the Lexeme Form be ‑<langData
lang="lAxinincaCampa"
>i</langData
> and we would create an Allomorph Form of ‑<langData
lang="lAxinincaCampa"
>a</langData
>. We would set the “Required Features” field of the ‑<langData
lang="lAxinincaCampa"
>a</langData
> allomorph to be for first person object agreement. One implication of this is that the default form ‑<langData
lang="lAxinincaCampa"
>i</langData
> of the Lexeme Form will automatically be conditioned to not occur when the first person object agreement feature is present. This means that a form like <exampleRef
letter="xAxinincaCutNonFuturePerf1Obj"
num="xAxinincaCutNonFuturePerf1Obj"
></exampleRef
> will fail to analyze correctly. Currently, a way to compensate for this is to add another Allomorph Form for ‑<langData
lang="lAxinincaCampa"
>i</langData
>, setting its “Required Features” field to be for both first person object agreement and perfect aspect.<endnote
id="nAffixAlloFeatsDefaultFeatures"
><p
>When default inflection features are implemented, we will be able to use default inflection features to overcome this work-around. For the Axininca Campa case, the idea would be to assign a default aspect feature of, say, imperfect to the Verb category. The ‑<langData
lang="lAxinincaCampa"
>a</langData
> allomorph of the non-future suffix would then be constrained to occur with both imperfect aspect and with first person object agreement. There will then be no need for a second ‑<langData
lang="lAxinincaCampa"
>i</langData
> allomorph.</p
><p
>Of course, a way to currently get something like a default imperfect aspect would be to create a null imperfect aspect suffix, add it to the aspect slot of the inflectional template, and make this aspect slot be obligatory.</p
></endnote
></p
><p
>While this example is for inflectional affixes, <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of the <object
type="WordWorks"
></object
> parser also allows constraining allomorphs of derivational affixes. The process is similar: create the allomorph and constrain it via the “Required Features” field.</p
></section3
></section2
><section2
id="sIrregInflForms"
><secTitle
>Irregularly Inflected Forms</secTitle
><p
><indexedItem
term="iIrrInflForms"
></indexedItem
><indexedItem
term="iTurka"
></indexedItem
>Next consider the following small set of data for Turka, a language spoken in Burkina Faso.<endnote
id="nTurka"
><p
>The data are from Colin Suggett, personal communication. The abbreviation ‘PL’ means “plural.”</p
></endnote
></p
><example
num="xTurkaNounPlurals"
><listWord
letter="xTurkaNounPluralduu"
><langData
lang="lTurka"
>duu</langData
><gloss
lang="lGloss"
>‘house’</gloss
></listWord
><listWord
letter="xTurkaNounPluraldon"
><langData
lang="lTurka"
>don</langData
><gloss
lang="lGloss"
>‘house.PL’</gloss
></listWord
><listWord
letter="xTurkaNounPluralfuga"
><langData
lang="lTurka"
>fuga</langData
><gloss
lang="lGloss"
>‘field’</gloss
></listWord
><listWord
letter="xTurkaNounPluralfugas"
><langData
lang="lTurka"
>fugasǝ</langData
><gloss
lang="lGloss"
>‘field.PL’</gloss
></listWord
><listWord
letter="xTurkaNounPluralgbafl"
><langData
lang="lTurka"
>gbaflǝ</langData
><gloss
lang="lGloss"
>‘pot’</gloss
></listWord
><listWord
letter="xTurkaNounPluralgbafi"
><langData
lang="lTurka"
>gbafiɛ</langData
><gloss
lang="lGloss"
>‘pot.PL’</gloss
></listWord
><listWord
letter="xTurkaNounPluralkuu"
><langData
lang="lTurka"
>kuu</langData
><gloss
lang="lGloss"
>‘idol’</gloss
></listWord
><listWord
letter="xTurkaNounPluralkii"
><langData
lang="lTurka"
>kii</langData
><gloss
lang="lGloss"
>‘idol.PL’</gloss
></listWord
></example
><p
>Notice that there is not an obvious way that plurals are formed. That is, the plural forms appear to be portmanteau morphemes: a combination of the singular morpheme plus plural.</p
><p
>At least one way to deal with this is to create irregularly inflected form variants for each of the plural forms, tagging them as being the plural variant type, and linking them to their respective singular form. If you make sure that the plural variant type<endnote
id="nIrrVariantType"
><p
>At the time of writing, irregularly inflected variant types are located in the “Lists” area under “Variant Types.”</p
></endnote
> has its “Append to Gloss” field set to ‘.pl’(if you are going to use small caps) or ‘.PL’ (if you are not), then the <object
type="WordWorks"
></object
> parser will parse these plural variant forms, using the gloss of the singular form plus what is in the “Append to Gloss” field. When you use this method, the irregularly inflected form must have no sense information or it will not work as intended.</p
><p
>You can also set the “Inflection Features” field of the irregularly inflected variant type to those inflection features borne by the variant. The <object
type="WordWorks"
></object
> parser will then prevent parses where the indicated inflection features conflict with similar inflection features of other affixes that have different values.</p
><p
>Suppose, now, that there are some inflectional templates that have required slots and that the irregularly inflected form portmanteau morpheme has in it the information needed to fill one or more of those required slots. What will happen? Since the <object
type="WordWorks"
></object
> parser requires these slots to be filled, the parse will fail when it should not.</p
><p
>The solution is to set the “Slots” field of the irregularly inflected variant type to refer to all required slots in templates that it is taking the place of. The <object
type="WordWorks"
></object
> parser will then correctly parse such forms.<endnote
id="nNullAffixForSlot"
><p
>This works by creating a null prefix (for required slots that occur before the stem) or a null suffix (for required slots that occur after the stem) and giving it the inflection features of the variant type.</p
></endnote
> In addition, it will prevent parses where the indicated slots are filled by some other affix.</p
></section2
><section2
id="sCoalescence"
><secTitle
>Coalescence</secTitle
><p
><indexedRangeBegin
id="bCoalescence"
term="iCoalescence"
></indexedRangeBegin
>Another morphophonemic phenomenon can be illustrated by the following data from <indexedItem
term="iMenya"
></indexedItem
>Menya. <endnote
id="nMenya"
><p
>The data are from <citation
ref="rMenyaGrammar"
></citation
>. The abbreviations used in the Menya data are:</p
><table
border="1"
><tr
><th
>Abbreviation</th
><th
>Meaning</th
></tr
><tr
><td
><object
type="SmallCaps"
>1p/irr</object
></td
><td
>first person plural, irrealis</td
></tr
><tr
><td
><object
type="SmallCaps"
>23p/irr</object
></td
><td
>second or third person plural, irrealis</td
></tr
><tr
><td
><object
type="SmallCaps"
>goal</object
></td
><td
>goal</td
></tr
><tr
><td
><object
type="SmallCaps"
>ind</object
></td
><td
>indicative</td
></tr
></table
></endnote
></p
><example
num="xMenyaCoalescence1"
><listInterlinear
letter="xMenyaMa"
><lineGroup
><line
><wrd
><langData
lang="lMenya"
><object
type="Underscore"
>ma</object
>pŋque</langData
></wrd
></line
><line
><wrd
><langData
lang="lMenya"
>ma-p=ŋqä=i</langData
></wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>get-<object
type="SmallCaps"
>23p/irr=goal=ind</object
></gloss
></wrd
></line
></lineGroup
><free
>‘they're going to get’</free
></listInterlinear
><listInterlinear
letter="xMenyaMe"
><lineGroup
><line
><wrd
><langData
lang="lMenya"
><object
type="Underscore"
>me</object
>tuŋque</langData
></wrd
></line
><line
><wrd
><langData
lang="lMenya"
>ma-atu=ŋqä=i</langData
></wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>get-<object
type="SmallCaps"
>1p/irr=goal=ind</object
></gloss
></wrd
></line
></lineGroup
><free
>‘we're going to get’</free
></listInterlinear
></example
><example
num="xMenyaCoalescence2"
><listInterlinear
letter="xMenyaIka"
><lineGroup
><line
><wrd
><langData
lang="lMenya"
><object
type="Underscore"
>ikä</object
>pŋque</langData
></wrd
></line
><line
><wrd
><langData
lang="lMenya"
>ikä-p=ŋqä=i</langData
></wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>tour-<object
type="SmallCaps"
>23p/irr=goal=ind</object
></gloss
></wrd
></line
></lineGroup
><free
>‘they're going to tour’</free
></listInterlinear
><listInterlinear
letter="xMenyaIki"
><lineGroup
><line
><wrd
><langData
lang="lMenya"
><object
type="Underscore"
>iki</object
>tuŋque</langData
></wrd
></line
><line
><wrd
><langData
lang="lMenya"
>ikä-atu=ŋqä=i</langData
></wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>tour-<object
type="SmallCaps"
>1p/irr=goal=ind</object
></gloss
></wrd
></line
></lineGroup
><free
>‘we're going to tour’</free
></listInterlinear
></example
><p
>In example <exampleRef
letter="xMenyaCoalescence1"
num="xMenyaCoalescence1"
></exampleRef
>, the root is <langData
lang="lMenya"
>ma</langData
>, but when this vowel-final root is followed by a vowel initial suffix as in <exampleRef
letter="xMenyaMe"
num="xMenyaMe"
></exampleRef
>, the two vowels coalesce so it surfaces as <langData
lang="lMenya"
>me</langData
>. In this case, the coalesced vowel also changes quality. A similar coalescence occurs in <exampleRef
letter="xMenyaIki"
num="xMenyaIki"
></exampleRef
> for the vowel-final root <langData
lang="lMenya"
>ikä</langData
>.</p
><p
>How does one model such allomorphy in <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
>? Since only allomorphy is available, one must create allomorphs for both the root and the suffixes and condition them to have the correct environments.<endnote
id="nStemAllomorphyAsStemName"
><p
>It may be the case that the stem allomorphy will depend on the morphosyntactic features of the affixes. If so, you may be able to use stem names. See section <sectionRef
sec="sStemNames"
></sectionRef
>.</p
></endnote
></p
><example
num="xCoalescence"
><chart
type="HowTo"
><ol
><li
>Create an entry for each morpheme.</li
><li
>For those entries with allomorphy, create the Allomrph Forms.</li
><li
>For each Allomorph Form,<ol
><li
>Create or check that you have an <indexedItem
term="iAlloEnvironments"
></indexedItem
>environment that is correct for the form.</li
><li
>Assign the correct environment for the form.<indexedRangeEnd
begin="bCoalescence"
></indexedRangeEnd
></li
></ol
></li
></ol
></chart
></example
></section2
><section2
id="sAdhocAlloProhibitions"
><secTitle
>Ad hoc Allomorph-oriented Rules</secTitle
><p
><indexedRangeBegin
id="bAllomorphAdhoc"
term="iAdhocAllo"
></indexedRangeBegin
><indexedItem
term="iAdhocConstraints"
></indexedItem
>When one uses a <indexedItem
term="iMorphologicalParser"
></indexedItem
>morphological parser, it is not unusual for the parser to sometimes return a parse that is simply incorrect. These are sometimes due to allomorphs matching in places one would not have expected them to match. When one has used all the mechanisms provided by the parser to the best of one's ability and such incorrect parses continue to surface, one may well wish for some kind of mechanism to rule them out. <object
type="WordWorks"
></object
> provides “Ad hoc Rules” for such situations. Note that it may well be the case that later stages of <object
type="WordWorks"
></object
> will provide more well-motivated means to rule out these infelicitous parses, but for now, these ad hoc solutions may have to do.</p
><section3
id="sAdhocAlloProhibitionsCreating"
><secTitle
>Creating Ad hoc Allomorph-oriented Rules</secTitle
><p
>There are two main types of ad hoc rules: morpheme-oriented ones and allomorph-oriented ones. This section deals with allomorph-oriented ones (see section <sectionRef
sec="sAdhocMorphProhibitions"
></sectionRef
> for morpheme-oriented ones). The basic idea is to list a <indexedItem
term="iAdhocKeyAllo"
></indexedItem
>key allomorph and then to list one or more <indexedItem
term="iAdhocOtherAllomorphs"
></indexedItem
>other allomorphs that cannot co-occur with the key one. One can constrain these other allomorphs to never occur in one of the following ways with respect to the key allomorph:</p
><example
num="xAdhocAlloAdjacency"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Manner</th
><th
align="left"
valign="top"
>Meaning</th
></tr
><tr
><td
align="left"
valign="top"
>Anywhere</td
><td
align="left"
valign="top"
>The allomorphs in question are constrained from appearing anywhere together in the same word.</td
></tr
><tr
><td
align="left"
valign="top"
>Somewhere before</td
><td
align="left"
valign="top"
>The key allomorph is constrained from appearing anywhere in the word before the other allomorphs.</td
></tr
><tr
><td
align="left"
valign="top"
>Somewhere after</td
><td
align="left"
valign="top"
>The key allomorph is constrained from appearing anywhere in the word after the other allomorphs.</td
></tr
><tr
><td
align="left"
valign="top"
>Adjacent before</td
><td
align="left"
valign="top"
>The key allomorph is constrained from appearing immediately before the other allomorphs in the same word.</td
></tr
><tr
><td
align="left"
valign="top"
>Adjacent after</td
><td
align="left"
valign="top"
>The key allomorph is constrained from appearing immediately after the other allomorphs in the same word.</td
></tr
></table
></example
><p
>Note that when there are two or more allomorphs listed for “other allomorphs,” the rule only applies when all of them co-occur in the same word with the key allomorph.  In addition, their relative order is significant. They should be listed in the same linear order they occur in a word.</p
><p
>The <indexedItem
term="iEnglish"
></indexedItem
>English plurals in <exampleRef
equal="no"
letterOnly="no"
num="xEnglishExceptionalPlurals"
></exampleRef
> show some cases where we might choose to use an allomorph ad hoc rule for <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
>.<endnote
id="nEnglishExceptionalPlurals"
><p
>Admittedly, this is not the greatest example. One could use inflection classes for these or, perhaps better, one could merely use an environment to constrain the exceptional allomorphs for the roots to which they attach.</p
></endnote
></p
><example
num="xEnglishExceptionalPlurals"
><listWord
letter="xEnglishExceptionalPluralsBooks"
><langData
lang="lEng"
>book-s</langData
></listWord
><listWord
letter="xEnglishExceptionalPluralsDogs"
><langData
lang="lEng"
>dog-s</langData
></listWord
><listWord
letter="xEnglishExceptionalPluralsOxen"
><langData
lang="lEng"
>ox-en</langData
></listWord
></example
><p
>The exceptional case, of course, is the ‑<langData
lang="lEng"
>en</langData
> allomorph (there are other exceptional plurals in English, but this one will do for our example here). Suppose you have these allomorphs in your dictionary and that you also have the noun <langData
lang="lEng"
>molt</langData
> as well as the verb <langData
lang="lEng"
>molt</langData
> in your dictionary. Then the word form <langData
lang="lEng"
>molten</langData
> would be parsed at least two ways as shown in <exampleRef
equal="no"
letterOnly="no"
num="xEnglishExceptionalPluralsMolten"
></exampleRef
>.</p
><example
num="xEnglishExceptionalPluralsMolten"
><listInterlinear
letter="xEnglishExceptionalPluralsMoltenV"
><lineGroup
><line
><langData
lang="lEng"
>molt-en</langData
></line
><line
><gloss
lang="lGloss"
>to.molt-PastParticiple</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xEnglishExceptionalPluralsMoltenN"
><lineGroup
><line
><langData
lang="lEng"
>molt-en</langData
></line
><line
><gloss
lang="lGloss"
>molt-Plural</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>The parse in <exampleRef
equal="no"
letter="xEnglishExceptionalPluralsMoltenN"
letterOnly="no"
></exampleRef
>, of course, is incorrect. To rule out this incorrect parse, one could create an allomorph ad hoc rule for the <langData
lang="lEng"
>en</langData
> allomorph of the plural with the <langData
lang="lEng"
>molt</langData
> allomorph of the noun <langData
lang="lEng"
>molt</langData
>.</p
><p
>How does one create an allomorph-oriented ad hoc rule in <object
type="WordWorks"
></object
>?</p
><example
num="xAdhocAlloHowTo"
><chart
type="HowTo"
><ol
><li
>Determine the allomorphs involved.</li
><li
>Determine the most appropriate way to constrain them (see <exampleRef
equal="no"
letterOnly="no"
num="xAdhocAlloAdjacency"
></exampleRef
>).<endnote
id="nAdhocAlloHowTo"
><p
>One approach to this is to strive to make the tightest constraint possible (i.e. use one of the adjacency ways first if possible; if not, then try the somewhere case; if that does not work, then try the anywhere case). That way, should you encounter another case involving these particular allomorphs, then you will now know more: it is now clear that you need looser constraints. You can then add some comments/annotations to document what you have learned (or put the information in the description).</p
></endnote
></li
><li
>Create an allomorph-oriented ad hoc rule.<ol
><li
>Indicate the key allomorph involved.</li
><li
>Indicate the way or manner in which to constrain this allomorph (see <exampleRef
equal="no"
letterOnly="no"
num="xAdhocAlloAdjacency"
></exampleRef
>).</li
><li
>Indicate the non-key allomorph(s) involved.</li
></ol
></li
></ol
></chart
></example
><p
>By the way, when you are indicating the allomorph, be sure that the particular allomorph is for the correct morpheme, too. <object
type="WordWorks"
></object
> maintains a distinction between identically shaped allomorphs; only those for the particular morpheme will actually be constrained.</p
></section3
><section3
id="sAdhocAlloProhibitionsGroups"
><secTitle
>Grouping Ad hoc Allomorph Rules</secTitle
><p
><indexedItem
term="iAdhocGroup"
></indexedItem
>Occasionally one finds a situation where a set of ad hoc constraints have a common theme. Perhaps they all relate to a particular allomorph or to particular allomorphs of a certain variety. This may be a hint as to what is really happening and may lead you to discover a linguistically-motivated way to model them. Or it could be that the <object
type="WordWorks"
></object
> model just does not happen to provide the appropriate linguistic mechanism to model the phenomenon correctly.</p
><p
>One can group such ad hoc rules together. How does one create such a group?</p
><example
num="xAdhocAlloGroupHowTo"
><chart
type="HowTo"
><ol
><li
>Create an ad hoc rule group.</li
><li
>For each ad hoc allomorph rule in the group:<ol
><li
>Create the ad hoc allomorph rule (see <exampleRef
equal="no"
letterOnly="no"
num="xAdhocAlloHowTo"
></exampleRef
>) and include it in the group.</li
></ol
></li
></ol
></chart
></example
><p
>Finally, note that <object
type="WordWorks"
></object
> allows one to group both allomorph and morpheme ad hoc rules together. Please be sure to only do so if these rules truly do have something in common<indexedRangeEnd
begin="bAllomorphAdhoc"
></indexedRangeEnd
><indexedRangeEnd
begin="bMorphophonemics"
></indexedRangeEnd
>.</p
></section3
></section2
></section1
><section1
id="sLexEntries"
><secTitle
>Lexical Entry Considerations</secTitle
><p
>This section lists a few items that one should keep in mind while adding lexical entries.</p
><section2
id="sAllomorphs"
><secTitle
>Allomorphs</secTitle
><p
><indexedItem
term="iAllomorphy"
></indexedItem
>There are two things to keep in mind while keying Lexeme Forms and Allomorph Forms.</p
><section3
id="sAllomorphsNull"
><secTitle
>Null Allomorphs</secTitle
><p
><indexedItem
main="yes"
term="iNullAllomorph"
></indexedItem
>Generally speaking, one wants to avoid having null allomorphs if for no other reason than that they can make the <indexedItem
term="iMorphologicalParser"
></indexedItem
>parser run rather slowly. If having a null allomorph is indeed the best analysis, then please keep the following in mind:</p
><example
num="xNullAllomorphsHowTo"
><chart
type="HowTo"
><ol
><li
>One indicates a null in the allomorph's form field by typing either <object
type="TT"
>^0</object
> (a caret - shift-6 on many keyboards - followed by the zero character), <object
type="TT"
>&amp;0</object
> (an ampersand followed by the zero character), <object
type="TT"
>*0</object
> (an asterisk followed by the zero character), or <indexedItem
term="iEmptySetSymbol"
></indexedItem
>the empty set character (if the font you are using has it).<endnote
id="nEmptySet"
><p
><indexedItem
term="iEmptySetSymbol"
></indexedItem
>The empty set character is Unicode hex code 2205.</p
></endnote
> Ideally, we would always just use the empty set character. Unfortunately, many fonts do not happen to include it, so we offer these other ways. Note that if you happen to use an asterisk (or caret or ampersand) as a leading or trailing token for some morpheme type, then there is a potential conflict between indicating the morpheme type and indicating a null. If you discover such a conflict, try using a different alternative for indicating a null (or change the leading or trailing token for the morpheme type).</li
><li
>Attempt to constrain the null with as specific an environment as possible. This is to avoid having it show up in undesired places in incorrect parses.</li
><li
>You may also need to adjust the Parser Parameters to allow for more than one null allomorph per word. That is, determine what the maximum number of null allomorphs a legitimate word could have and set the MaxNulls parameter to that number. Remember, that the lower the number, the faster the parser will run.</li
></ol
></chart
></example
></section3
><section3
id="sAllomorphOrder"
><secTitle
>Order of Allomorphs within a Lexical Entry</secTitle
><p
><indexedItem
term="iAlloOrder"
></indexedItem
>In <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
>, the order of Lexeme Forms and Allomorph Forms is quite significant. Consider the following <indexedItem
term="iEnglish"
></indexedItem
>English data.</p
><example
num="xEnglishPluralsNormal"
><listWord
letter="xEnglishPluralsNormalIz"
><langData
lang="lEng"
>pisιz</langData
><gloss
lang="lGloss"
>‘pieces’</gloss
></listWord
><listWord
letter="xEnglishPluralsNormalz"
><langData
lang="lEng"
>dagz</langData
><gloss
lang="lGloss"
>‘dogs’</gloss
></listWord
><listWord
letter="xEnglishPluralsNormals"
><langData
lang="lEng"
>kaιts</langData
><gloss
lang="lGloss"
>‘kites’</gloss
></listWord
></example
><p
>Under one possible analysis, we can say that the allomorphs for the English plural are:</p
><ol
><li
>‑<langData
lang="lEng"
>ιz</langData
> after strident segments</li
><li
>‑<langData
lang="lEng"
>z</langData
> after voiced (but non-strident) segments</li
><li
>‑<langData
lang="lEng"
>s</langData
> elsewhere</li
></ol
><p
>If we have a natural class for stridents and one for voiced segments (including stridents) and create two environments (one for “after stridents” and one for “after voiced segments”), then we can order and condition the allomorphs as follows:</p
><ol
><li
><langData
lang="lEng"
>ιz</langData
> to occur after stridents</li
><li
><langData
lang="lEng"
>z</langData
> to occur after voiced segments</li
><li
><langData
lang="lEng"
>s</langData
></li
></ol
><p
>Because of the ordering and the fact that the first two are conditioned, the third (elsewhere) case will automatically be constrained to not occur after stridents as well as to not occur after voiced segments. The second allomorph will be conditioned to not only occur after voiced segments, but also to not occur after stridents.</p
><p
>Do you see how it works? For a given Allomorph Form, <object
type="WordWorks"
></object
> applies the condition of this Allomorph Form and, at the same time, negates the conditions of all preceding Allomorph Forms. This is why the ordering of allomorphs is crucial.</p
><p
>Having said that, please note that the <indexedItem
term="iLexemeForm"
></indexedItem
>Lexeme Form field is always automatically ordered last after all of the Allomorph Forms listed in the <indexedItem
term="iAlternateForms"
></indexedItem
>Allomorphs section of Lexicon Edit.</p
></section3
></section2
><section2
id="sMorphTypes"
><secTitle
>Morpheme Types</secTitle
><p
><indexedItem
term="iMorphemeTypes"
></indexedItem
>Morpheme types are things like “root,” “prefix,” “clitic,” etc. <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
> keys on certain ones of these in order to tell the <indexedItem
term="iMorphologicalParser"
></indexedItem
>parser how to handle the particular form. The types in the following list are significant to the parser.<endnote
id="nMorphTypes"
><p
>Another way of saying this is that the parser recognizes all morpheme types except for discontiguous phrase, simulfix, suprafix, and circumfix. For <indexedItem
term="iCircumfix"
></indexedItem
>circumfix, however, see section <sectionRef
sec="sCircumfixes"
></sectionRef
>.</p
></endnote
></p
><ul
><li
><indexedItem
term="iBoundRoot"
></indexedItem
>bound root</li
><li
><indexedItem
term="iBoundStem"
></indexedItem
>bound stem</li
><li
><indexedItem
term="iCliticEnclitic"
></indexedItem
>enclitic</li
><li
><indexedItem
term="iInfix"
></indexedItem
>infix</li
><li
><indexedItem
term="iInfixinfInterfix"
></indexedItem
>infixing interfix</li
><li
><indexedItem
term="iParticle"
></indexedItem
>particle</li
><li
><indexedItem
term="iPhrase"
></indexedItem
>phrase</li
><li
><indexedItem
term="iPrefix"
></indexedItem
>prefix</li
><li
><indexedItem
term="iPrefixInterfix"
></indexedItem
>prefixing interfix</li
><li
><indexedItem
term="iCliticProclitic"
></indexedItem
>proclitic</li
><li
><indexedItem
term="iRoot"
></indexedItem
>root</li
><li
><indexedItem
term="iStem"
></indexedItem
>stem</li
><li
><indexedItem
term="iSuffix"
></indexedItem
>suffix</li
><li
><indexedItem
term="iSuffixInterfix"
></indexedItem
>suffxing interfix</li
></ul
><p
>One should keep this in mind when applying a type to a form.</p
><p
>In particular, note that if a form is tagged as a <indexedItem
term="iParticle"
></indexedItem
>particle, then it must stand alone (i.e. it will not be allowed to take affixes or to participate in compounds). <indexedItem
term="iClitic"
></indexedItem
>Clitics, though, may attach to a morpheme tagged as a particle.</p
><p
>One may also tag a form as a <indexedItem
term="iPhrase"
></indexedItem
>phrase, although there are limitations. The <object
type="WordWorks"
></object
> parser treats such phrases like a stem. That is, any derivational or inflectional affixes must attach around the phrase, not within it (unless such an affix is an infix, of course). In particular, the <object
type="WordWorks"
></object
> parser cannot handle something like <langData
lang="lEng"
>kicked the bucket</langData
> where the past tense inflection occurs as a suffix on the first word of the phrase.</p
></section2
><section2
id="sCircumfixes"
><secTitle
>Circumfixes</secTitle
><p
><indexedItem
main="yes"
term="iCircumfix"
></indexedItem
>In some languages, there is a special class of affixes. The segmental material represented by these affixes appears at both ends of the stem at the same time. It is as if there are two parts of such an affix: one part is typically a prefix and the other part is a suffix. These are called <object
type="Definition"
>circumfixes</object
>. Consider the following data from <indexedItem
term="iBahasaIndonesia"
></indexedItem
>Bahasa Indonesia.<endnote
id="nBahasaIndonesiaCircumfix"
><p
>The data are from Howard Shelden, p.c. (December 15, 2006 email)</p
></endnote
></p
><example
num="xBahasaIndonesiaCircumfixation"
><interlinear
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>kebangunan</langData
></line
><line
><langData
lang="lBahasaIndonesia"
>ke-bangun-an</langData
></line
><line
><gloss
lang="lGloss"
>NMLZR-to.wake.up-NMLZR</gloss
></line
></lineGroup
><free
>‘awakening’</free
></interlinear
></example
><p
>The <langData
lang="lBahasaIndonesia"
>ke</langData
>‑ prefix and the ‑<langData
lang="lBahasaIndonesia"
>an</langData
> suffix act together to form a single morpheme even though they are on opposite ends of the <langData
lang="lBahasaIndonesia"
>bangun</langData
> stem. Another way of looking at this is to say that the nominalizer (<gloss
lang="lGloss"
>NMLZR</gloss
>) morpheme is realized by a circumfix whose left member is the <langData
lang="lBahasaIndonesia"
>ke</langData
>‑ prefix and whose right member is the ‑<langData
lang="lBahasaIndonesia"
>an</langData
> suffix.</p
><p
>How does one create such circumfixes in <indexedItem
term="iStage1"
></indexedItem
>Stage 1 of <object
type="WordWorks"
></object
>?</p
><example
num="xCircumfixHowTo"
><chart
type="HowTo"
><ol
><li
>Add a new lexical entry for the circumfix.</li
><li
>Indicate the <indexedItem
term="iLexemeForm"
></indexedItem
>lexeme form in such a way that it is clear that it is a circumfix.<ol
><li
>One way is to indicate the prefix portion (with a trailing hyphen), an ellipsis marker (...), and then the suffix portion (with a preceding hyphen).</li
><li
>Another way is to merely separate the prefix and suffix portions by a space (but still using the hyphen to indicate the appropriate type).</li
></ol
></li
><li
>Two allomorphs will be created automatically:<ol
><li
>One is for the left member (the prefix in our example). Its morpheme type defaults to prefix (if yours is an infix, you will need to change the morpheme type by hand).</li
><li
>The other is for the right member (the suffix in our example). Its morpheme type defaults to suffix (if yours is an infix, you will need to change the morpheme type by hand).</li
><li
>If either of these have allomorphs, key those as well.</li
><li
>Include all <indexedItem
term="iAlloEnvironments"
></indexedItem
>environments as appropriate for each member. For example, if a prefix allomorph only occurs before labials, indicate that for that prefix. Remember that the environments for the different members are independent of each other.</li
></ol
></li
></ol
></chart
></example
><p
>Note the following characteristics about circumfix entries created this way:</p
><ol
><li
>The only place this entry is marked as being a circumfix is in the morpheme type field of the lexeme form.</li
><li
>There is at least one allomorph for the prefix member.</li
><li
>There is at least one suffix allomorph for the suffix member.</li
></ol
><p
>When one keys a circumfix in this manner, the <object
type="WordWorks"
></object
> parser will require both the left and right member affixes to appear simultaneously for them to be parsed as an instance of this entry. Circumfixes may be classified as derivational, inflectional, or as unclassified. The <object
type="WordWorks"
></object
> parser handles all three varieties correctly.</p
></section2
><section2
id="sSenses"
><secTitle
>Senses/Glosses</secTitle
><p
>While it is possible to have two or more glosses somewhere in your lexicon spelled exactly the same way, we do not recommend that you do so on purpose. Having two or more morphemes with the same gloss will not confuse <object
type="WordWorks"
></object
> because <object
type="WordWorks"
></object
> uniquely identifies every gloss internally. That does not imply, however, that either you or a reader of your glossed texts will not be confused as a result.</p
></section2
></section1
><section1
id="sOtherConsiderations"
><secTitle
>Other Considerations</secTitle
><p
>The <object
type="WordWorks"
></object
> approach has been purposely designed to allow you to incrementally build up the morphological description piece by piece (with one exception; see <sectionRef
sec="sCompoundRuleExceptionalConsideration"
></sectionRef
> below). For example, you can add inflectional templates as you discover them. It is not the case that once you start to use inflectional templates, you must define inflectional templates for all categories at once. You can define them one by one if you need to or all at once (if you happen to already know what they are).</p
><section2
id="sCompoundRuleExceptionalConsideration"
><secTitle
>Exceptional Case for Compound Rules</secTitle
><p
>The exception to this general case is <indexedItem
term="iCompounding"
></indexedItem
>compound rules. Once you define your first compound rule, the <object
type="WordWorks"
></object
> parser will then only allow compounds for which there are rules. In particular, this means that you may have a number of word forms that will suddenly fail to analyze once you write your first compound rule. To get them to analyze, you will need to define appropriate compound rules for them. We wish we could allow the discovery and development of compound rules to also be incremental, but we have not figured out how to do it.</p
></section2
></section1
><backMatter
><appendix
id="aStages"
><secTitle
>Planned Stages for the Parser</secTitle
><p
><indexedItem
main="yes"
term="iStages"
></indexedItem
>As mentioned in section <sectionRef
sec="sIntro"
></sectionRef
>, the main reason why we have stages in the <object
type="WordWorks"
></object
> development project is to avoid trying to develop tools with all the user interface challenges all in one fell swoop. Doing that would be quite a daunting task and take a long time before any product could be released. Instead, we are staging the development to handle the basic items first. Then we'll add more and more as we go along.</p
><p
>The basic features of each stage are outlined in the following chart:</p
><table
border="1"
type="leftOffset"
><tr
><th
align="left"
valign="top"
>Stage</th
><th
align="left"
valign="top"
>Capabilities</th
></tr
><tr
><td
align="left"
valign="top"
><indexedItem
main="yes"
term="iStage1"
></indexedItem
>Stage 1</td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
>Shoebox Legacy Importer</td
></tr
><tr
><td
align="left"
valign="top"
>LinguaLinks Legacy Importer</td
></tr
><tr
><td
align="left"
valign="top"
>AMPLE Legacy Importer</td
></tr
><tr
><td
align="left"
valign="top"
><indexedItem
term="iXAmple"
></indexedItem
>XAmple as the parsing engine</td
></tr
><tr
><td
align="left"
valign="top"
>Morpheme types</td
></tr
><tr
><td
align="left"
valign="top"
>Basic Categories (Parts of Speech)</td
></tr
><tr
><td
align="left"
valign="top"
>Inflectional templates (categories only)</td
></tr
><tr
><td
align="left"
valign="top"
>Derivational affixes (categories only)</td
></tr
><tr
><td
align="left"
valign="top"
>Compound rules (categories only)</td
></tr
><tr
><td
align="left"
valign="top"
>Inflection classes</td
></tr
><tr
><td
align="left"
valign="top"
>Item and arrangement phonology (i.e. no phonological rules)</td
></tr
><tr
><td
align="left"
valign="top"
>Allomorph ad hoc constraints</td
></tr
><tr
><td
align="left"
valign="top"
>Morpheme ad hoc constraints</td
></tr
><tr
><td
align="left"
valign="top"
>Morphology Sketch Generator</td
></tr
><tr
><td
align="left"
valign="top"
>A Morphosyntactic Glossing Assistant tool</td
></tr
><tr
><td
align="left"
valign="top"
>Simple features (including an editor)</td
></tr
><tr
><td
align="left"
valign="top"
>Categories include features</td
></tr
><tr
><td
align="left"
valign="top"
>Categories include stem names</td
></tr
><tr
><td
align="left"
valign="top"
>Inflectional templates include features</td
></tr
><tr
><td
align="left"
valign="top"
>Derivational affixes include features</td
></tr
><tr
><td
align="left"
valign="top"
>No performance support documentation</td
></tr
></table
></td
></tr
><tr
><td
align="left"
valign="top"
><indexedItem
main="yes"
term="iStage2"
></indexedItem
>Stage 2 has everything in Stage 1, plus:</td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
>XAmple and/or the <indexedItem
term="iXeroxParser"
></indexedItem
>Xerox parser and/or <indexedItem
term="iHermitCrabParser"
></indexedItem
>Hermit Crab as the parsing engine</td
></tr
><tr
><td
align="left"
valign="top"
>Compound rules include features</td
></tr
><tr
><td
align="left"
valign="top"
>Morpheme ad hoc constraints include features</td
></tr
><tr
><td
align="left"
valign="top"
><indexedItem
term="iPhonologicalRules"
></indexedItem
>Phonological rules</td
></tr
><tr
><td
align="left"
valign="top"
><indexedItem
term="iPerformanceSupport"
></indexedItem
>Performance support documentation (answers questions like "Why is this word not parsing?" or "How can I keep this incorrect parse from showing up?"</td
></tr
></table
></td
></tr
><tr
><td
align="left"
valign="top"
><indexedItem
main="yes"
term="iStage3"
></indexedItem
>Stage 3 has everything in Stage 1 and Stage 2, plus:</td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
>Strata</td
></tr
><tr
><td
align="left"
valign="top"
>Full feature structure editor</td
></tr
><tr
><td
align="left"
valign="top"
>Categories include strata</td
></tr
><tr
><td
align="left"
valign="top"
>Inflectional templates include strata</td
></tr
><tr
><td
align="left"
valign="top"
>Derivational affixes include strata</td
></tr
><tr
><td
align="left"
valign="top"
>Compound rules include strata</td
></tr
><tr
><td
align="left"
valign="top"
>Morpheme ad hoc constraints include strata</td
></tr
><tr
><td
align="left"
valign="top"
>A Paradigm tool</td
></tr
></table
></td
></tr
></table
><p
>Note that while we are including the new <object
type="HermitCrab"
></object
> with the current release, we are not yet including the other parts of the planned Stage 2.</p
></appendix
><appendix
id="aHermitCrab"
><secTitle
>The Experimental Phonological Rule-based Parser</secTitle
><p
>As mentioned in section <sectionRef
sec="sIntro"
></sectionRef
>, we are introducing a new <object
type="HermitCrab"
></object
>. This appendix outlines some of its capabilities in section <appendixRef
app="sHermitCrabItemAndProcess"
></appendixRef
>, gives some tips for making it work in section <appendixRef
app="sHermitCrabTips"
></appendixRef
>, and lists some known limitations in section <appendixRef
app="sHermitCrabLimitations"
></appendixRef
>.</p
><section1
id="sHermitCrabItemAndProcess"
><secTitle
>Item and Process</secTitle
><p
>The new <object
type="HermitCrab"
></object
> offers an <indexedItem
term="iItemAndProcess"
></indexedItem
>item and process approach for both affixation and morphophonemics. That is, one can describe affixes as processes (such as infixation or reduplication)<endnote
id="nHCAffixation"
><p
>“Normal” affixation (prefixation and suffixation) are actually also treated as processes internally in the new <object
type="HermitCrab"
></object
>, but the user does not need to do anything special. By merely saying that the affix is a prefix or a suffix, the <object
type="HermitCrab"
></object
> will treat them appropriately.</p
></endnote
> and one can also describe phonological rules. It is also supposed to work with the item and arrangement approach of the default <object
type="WordWorks"
></object
> parser. This means that one is supposed to be able to move from an item and arrangement description to an item and process description as one determines what these processes are. We have not thoroughly tested this, yet, however, so you may find some problems.</p
><p
>When you get to the point of trying this new parser and want to use processes, how might you describe such a process? That is, what are the pieces of a process? The approach we take is to think of what the input pattern is and then what the resulting output of the process should be. Therefore, all process rules will have an input pattern component and an output result component.</p
><p
><indexedItem
term="iPhonRuleGenerative"
></indexedItem
>Further, given the way the new <object
type="HermitCrab"
></object
> works for both affixes and phonology, one needs to think generatively. <indexedItem
term="iPhonologicalRules"
></indexedItem
>For phonological rules, the rules are applied in order from the underlying form to the surface form. For affixation, the word is built from the root out. That is, each affix is attached to what has been built so far during the derivation. Contrast this with how the default <object
type="WordWorks"
></object
> parser works: the default parser searches for surface forms from the beginning of the word to the end of the word; that is, it basically looks for prefixes first, then roots, then suffixes.<endnote
id="nAmpleSearchAlgortihm"
><p
>If there are interfixes (see section <sectionRef
sec="sCompoundInterfixes"
></sectionRef
>), then it will also look for those between roots. In addition, it looks for infixes within prefixes and roots.</p
></endnote
></p
><p
>The rest of this section illustrates these process rules. Examples of how one writes special affix process rules are in section <appendixRef
app="sHermitCrabAffixProcess"
></appendixRef
> and how one writes phonological rules are in section <appendixRef
app="sHermitCrabPhonologicalRules"
></appendixRef
>.</p
><section2
id="sHermitCrabAffixProcess"
><secTitle
>Affix process rules</secTitle
><p
><indexedItem
term="iAffixProcess"
></indexedItem
>With the new <object
type="HermitCrab"
></object
>, one can write an affix process rule that describes what the affix does to the material it “attaches” to. <indexedItem
term="iLexemeForm"
></indexedItem
>Any such affix process rule is entered in the lexical entry for the affix as a special kind of form (e.g. Lexeme Form or Affix Allomorph).<endnote
id="nAffixProcessAndEnvironments"
><p
><indexedItem
term="iAlloEnvironments"
></indexedItem
>Since these special forms include information about the context (the pattern), it does not make sense to also have an environment for an affix process. Therefore, if you are changing an environmentally-conditioned affix form to an affix process, any environments you previously had for this form will no longer be associated with that form.</p
></endnote
> As mentioned above, the rule has the general form of a pattern followed by a result. The pattern describes a sequence of items, where each item in the pattern is assigned an index number (starting with 1 for the left-most item). Then the result indicates how the pattern items are to be arranged and/or how new material is to be added. The following sections have examples of such rules.<endnote
id="nAffixProcessAndXAmple"
><p
>Please be aware that while the new <object
type="HermitCrab"
></object
> is able to handle any entry created for the default parser, the default parser does not know what to do with an affix process. Therefore, you cannot create affix processes and then expect the default parser to use them. This is one area where it is not possible to switch back and forth between the two parsers. The other area is phonological rules since the default parser does not handle phonological rules.</p
></endnote
></p
><section3
id="sHermitCrabReduplication"
><secTitle
>Reduplication as a process</secTitle
><p
><indexedItem
term="iReduplication"
></indexedItem
>Recall from section <sectionRef
sec="sReduplication"
></sectionRef
> that there are two kinds of reduplication: full and partial. The new <object
type="HermitCrab"
></object
> can handle both kinds.</p
><section4
id="sHCRedupFull"
><secTitle
>Full reduplication as a process</secTitle
><p
><indexedItem
term="iBahasaIndonesia"
></indexedItem
><indexedItem
term="iRedupFull"
></indexedItem
>Let's begin with full reduplication. Section <sectionRef
sec="sReduplicationFull"
></sectionRef
> had the following data from Bahasa Indonesia (repeated here from <exampleRef
letter="xIndonesianRedup1"
num="xIndonesianRedup1"
paren="initial"
></exampleRef
>-<exampleRef
letter="xIndonesianRedup6"
num="xIndonesianRedup6"
paren="final"
></exampleRef
> for your convenience).</p
><example
num="xIndonesianRedup1-1"
><listWord
letter="xIndonesianRedup1a-1"
><langData
lang="lBahasaIndonesia"
>pel</langData
><gloss
lang="lGloss"
>‘mop’</gloss
></listWord
><listWord
letter="xIndonesianRedup1b-1"
><langData
lang="lBahasaIndonesia"
>pel-pel</langData
><gloss
lang="lGloss"
>‘mops’</gloss
></listWord
></example
><example
num="xIndonesianRedup2-1"
><listWord
letter="xIndonesianRedup2a-1"
><langData
lang="lBahasaIndonesia"
>buku</langData
><gloss
lang="lGloss"
>‘book’</gloss
></listWord
><listWord
letter="xIndonesianRedup2b-1"
><langData
lang="lBahasaIndonesia"
>buku-buku</langData
><gloss
lang="lGloss"
>‘books’</gloss
></listWord
></example
><example
num="xIndonesianRedup3-1"
><listWord
letter="xIndonesianRedup3a-1"
><langData
lang="lBahasaIndonesia"
>komik</langData
><gloss
lang="lGloss"
>‘clown’</gloss
></listWord
><listWord
letter="xIndonesianRedup3b-1"
><langData
lang="lBahasaIndonesia"
>komik-komik</langData
><gloss
lang="lGloss"
>‘clowns’</gloss
></listWord
></example
><example
num="xIndonesianRedup4-1"
><listWord
letter="xIndonesianRedup4a-1"
><langData
lang="lBahasaIndonesia"
>orang</langData
><gloss
lang="lGloss"
>‘person’</gloss
></listWord
><listWord
letter="xIndonesianRedup4b-1"
><langData
lang="lBahasaIndonesia"
>orang-orang</langData
><gloss
lang="lGloss"
>‘people’</gloss
></listWord
></example
><example
num="xIndonesianRedup6-1"
><listWord
letter="xIndonesianRedup6a-1"
><langData
lang="lBahasaIndonesia"
>perpustakaan</langData
><gloss
lang="lGloss"
>‘library’</gloss
></listWord
><listWord
letter="xIndonesianRedup6b-1"
><langData
lang="lBahasaIndonesia"
>perpustakaan-perpustakaan</langData
><gloss
lang="lGloss"
>‘libraries’</gloss
></listWord
></example
><p
>Recall that in this data, the entire stem material is copied, no matter how long it is. In addition, an orthographic hyphen is inserted between the reduplicated material and the original stem.</p
><p
>To handle full reduplication data like this using the new <object
type="HermitCrab"
></object
>, what do we do? Remember that these processes are described by two parts: a pattern and a result.</p
><p
>So, what is the pattern here for full reduplication? Since it is full reduplication, we want to describe a pattern that is the entire stem. That is, we will want to copy everything in the input.</p
><p
>What would the result look like? The result would be to copy the entire stem, then insert a morpheme boundary symbol, the (orthographic) hyphen, and then another copy of the entire stem. It might look like this:</p
><example
num="xIndonesianFullRedupProcess"
><table
border="1"
><tr
><th
>Pattern</th
><th
valign="middle"
> </th
><th
>Result</th
></tr
><tr
><td
><object
type="TT"
> X</object
> </td
><td
rowspan="2"
valign="middle"
>⇒ </td
><td
rowspan="2"
valign="bottom"
> <object
type="TT"
>1</object
>  <object
type="TT"
>+ </object
><langData
lang="lBahasaIndonesia"
>-</langData
><object
type="TT"
> 1</object
></td
></tr
><tr
><td
><object
type="TT"
> 1 </object
></td
></tr
></table
></example
><p
>So in <exampleRef
letter="xIndonesianFullRedupProcess"
num="xIndonesianFullRedupProcess"
></exampleRef
>, the pattern is quite simple: it is just the stem (indicated in this case by <object
type="TT"
>X</object
>). The result refers to the index number of the stem material (<object
type="TT"
>1</object
>), inserts a morpheme boundary symbol (<object
type="TT"
>+</object
>), the phonological shape of the hyphen (<langData
lang="lBahasaIndonesia"
>-</langData
> in this case), and then a copy of the stem (indicated by the index number <object
type="TT"
>1</object
>). Note that in order to include the orthographic hyphen in this process rule, we have to define it as a phoneme. See example <exampleRef
letter="xIndonesianPhonemeFeatureMatrix"
num="xIndonesianPhonemeFeatureMatrix"
></exampleRef
> and endnote <endnoteRef
note="nIndonesianPhonemeFeatureMatrix"
></endnoteRef
> for more on this “phoneme;” also see sections <appendixRef
app="sHCTipsEveryPhonemeInOrthography"
></appendixRef
> and <appendixRef
app="sHCTipsUniquePhoneme"
></appendixRef
>.</p
><p
>Like we did in section <sectionRef
sec="sReduplicationFull"
></sectionRef
>, we are treating the reduplication affix as a suffix. With the new <object
type="HermitCrab"
></object
>, we can actually treat it either as a prefix or as a suffix. Either one will work fine. Note that this is different from the default <object
type="WordWorks"
></object
> parser where it is important to determine which kind of affix it is.</p
><p
>By the way, if we chose not to use something like an orthographic hyphen to separate the two parts of the full reduplication, the affix process rule would be written like this::</p
><example
num="xPlainFullRedupProcess"
><table
border="1"
><tr
><th
>Pattern</th
><th
valign="middle"
> </th
><th
>Result</th
></tr
><tr
><td
><object
type="TT"
> X</object
> </td
><td
rowspan="2"
valign="middle"
>⇒ </td
><td
rowspan="2"
valign="bottom"
> <object
type="TT"
>1</object
>  <object
type="TT"
>+ 1</object
></td
></tr
><tr
><td
><object
type="TT"
> 1 </object
></td
></tr
></table
></example
><p
>Note how this rule merely says to make a copy of the stem and insert a morpheme boundary between the two copies. Because this rule is a copy of the entire stem, the rule itself does not give any indication of whether the affix is a prefix or a suffix (like the other process rules below do). One implication of this is that you must be sure to set the morpheme type within the lexical entry for a full reduplication affix.</p
></section4
><section4
id="sHCRedupPartial"
><secTitle
>Partial reduplication as a process</secTitle
><p
><indexedItem
term="iTagalog"
></indexedItem
><indexedItem
term="iRedupPartial"
></indexedItem
>Turning now to partial reduplication, recall the Tagalog data from section <sectionRef
sec="sReduplicationPartial"
></sectionRef
>. The data in <exampleRef
letter="xTagalogReduplication3"
num="xTagalogReduplication3"
></exampleRef
> are repeated here from <exampleRef
letter="xTagalogReduplication2"
num="xTagalogReduplication2"
></exampleRef
> for your convenience.</p
><example
num="xTagalogReduplication3"
><listWord
letter="xSusulat3"
><langData
lang="lTagalog"
>susulat</langData
><gloss
lang="lGloss"
>‘to write (imperfective)’</gloss
></listWord
><listWord
letter="xMagpasulat3"
><langData
lang="lTagalog"
>magpasulat</langData
><gloss
lang="lGloss"
>‘to make someone write (perfective)’</gloss
></listWord
><listWord
letter="xMagpapasulat3"
><langData
lang="lTagalog"
>magpapasulat</langData
><gloss
lang="lGloss"
>‘to make someone write (imperfective)’</gloss
></listWord
></example
><p
>Recall that in this data, the imperfective aspect is realized by reduplicating the first CV syllable of the stem to which it attaches. (The <langData
lang="lTagalog"
>mag</langData
>- prefix is what some call actor focus or actor voice.)</p
><p
>In order to treat this reduplication as a process using the new <object
type="HermitCrab"
></object
>, we need to first determine the pattern and the result of the process. What is the pattern? Since what reduplicates is the first consonant and vowel of the stem, we will need to specify the first consonant and also the first vowel. We then can specify “whatever else is left over."</p
><p
>What might the result be? We will need to have a copy of the initial consonant, then a copy of the initial vowel, a morpheme boundary, and then the initial consonant, the initial vowel, and finally, “whatever else is left over." It might look like this:</p
><example
num="xTagalogPartialRedupProcess"
><table
border="1"
><tr
><th
colspan="3"
>Pattern</th
><th
> </th
><th
>Result</th
></tr
><tr
><td
align="center"
><object
type="TT"
>[C]</object
></td
><td
align="center"
><object
type="TT"
>[V]</object
></td
><td
align="center"
><object
type="TT"
>X</object
></td
><td
rowspan="2"
valign="middle"
>⇒ </td
><td
rowspan="2"
valign="bottom"
> <object
type="TT"
>1 2 + 1 2 3</object
></td
></tr
><tr
><td
align="center"
><object
type="TT"
>1</object
></td
><td
align="center"
><object
type="TT"
>2</object
></td
><td
align="center"
><object
type="TT"
> 3 </object
></td
></tr
></table
></example
><p
>Thus, in <exampleRef
letter="xTagalogPartialRedupProcess"
num="xTagalogPartialRedupProcess"
></exampleRef
> the pattern has three parts: the initial consonant (<object
type="TT"
>[C]</object
>), the vowel that follows it (<object
type="TT"
>[V]</object
>),<endnote
id="nCVAsSegmentOrFeature"
><p
>It does not matter whether the <object
type="TT"
>C</object
> and <object
type="TT"
>V</object
> natural classes are defined via segments or via phonological features. What is important is to be sure that these natural classes do indeed correctly identify the set of phonemes you have in mind.</p
></endnote
> and “whatever else is left over" (the <object
type="TT"
>X</object
>). Notice that these each have their respective index number, 1 through 3. The result is to copy the initial consonant (indicated by the first <object
type="TT"
>1</object
>), copy the initial vowel (indicated by the first <object
type="TT"
>2</object
>), the morpheme boundary (indicated by the <object
type="TT"
>+</object
>), and then to keep the original stem itself: the initial consonant (indicated by the last <object
type="TT"
>1</object
>), the initial vowel (indicated by the last <object
type="TT"
>2</object
>), and “whatever else is left over" (indicated by the <object
type="TT"
>3</object
>).</p
><p
>Note that in the pattern the “whatever else is left over" (the <object
type="TT"
>X</object
>) can be empty or have any positive number of segments in it. One thing this implies is that this rule will apply to a simple CV stem. In some languages this may be incorrect. That is, there may be a requirement that the stem be at least CVC or CVV in shape. How could we modify this rule to allow for this extra requirement? One way is to create a natural class that consists of all consonants as well as all vowels. Let's call it <object
type="TT"
>[A]</object
> (for all segments). Then we could rewrite the above rule as follows:</p
><example
num="xTagalogPartialRedupProcessCVAStem"
><table
border="1"
><tr
><th
colspan="4"
>Pattern</th
><th
valign="middle"
> </th
><th
>Result</th
></tr
><tr
><td
align="center"
><object
type="TT"
>[C]</object
></td
><td
align="center"
><object
type="TT"
>[V]</object
></td
><td
align="center"
><object
type="TT"
>[A]</object
></td
><td
align="center"
><object
type="TT"
>X</object
></td
><td
rowspan="2"
valign="middle"
>⇒ </td
><td
rowspan="2"
valign="bottom"
> <object
type="TT"
>1 2 3 + 1 2 3 4</object
></td
></tr
><tr
><td
align="center"
><object
type="TT"
>1</object
></td
><td
align="center"
><object
type="TT"
>2</object
></td
><td
align="center"
><object
type="TT"
>3</object
></td
><td
align="center"
><object
type="TT"
> 4 </object
></td
></tr
></table
></example
><p
>Since the pattern now requires a consonant, a vowel, plus one more segment, the rule can only be applied to stems that are at least CVC or CVV in shape.</p
><p
><indexedItem
term="iOrizabaNahuatl"
></indexedItem
>For another example, consider the Orizaba Nahuatl data in <exampleRef
letter="xNahuatlRedup1-1"
num="xNahuatlRedup1-1"
paren="initial"
></exampleRef
>-<exampleRef
letter="xNahuatlRedup2-1"
num="xNahuatlRedup2-1"
paren="final"
></exampleRef
>, repeated from <exampleRef
letter="xNahuatlRedup1"
num="xNahuatlRedup1"
paren="initial"
></exampleRef
>-<exampleRef
letter="xNahuatlRedup2"
num="xNahuatlRedup2"
paren="final"
></exampleRef
> (see section <sectionRef
sec="sReduplicationPartial"
></sectionRef
>).</p
><example
num="xNahuatlRedup1-1"
><listWord
letter="xNahuatlRedup1a-1"
><langData
lang="lNahuatl"
>tone</langData
><gloss
lang="lGloss"
>(the sun) shines</gloss
></listWord
><listWord
letter="xNahuatlRedup1b-1"
><langData
lang="lNahuatl"
>tohtone</langData
><gloss
lang="lGloss"
>(the sun) burns</gloss
></listWord
></example
><example
num="xNahuatlRedup2-1"
><listWord
letter="xNahuatlRedup2a-1"
><langData
lang="lNahuatl"
>chipintok</langData
><gloss
lang="lGloss"
>it is dripping</gloss
></listWord
><listWord
letter="xNahuatlRedup2b-1"
><langData
lang="lNahuatl"
>chihchipintok</langData
><gloss
lang="lGloss"
>it is dripping and dripping</gloss
></listWord
></example
><p
>Recall that the reduplication pattern here is to copy the first CV of the stem and then append an <langData
lang="lNahuatl"
>h</langData
>. That is, there is copied material plus some fixed material. In order to treat this as a process, we will need to write the pattern. What is it? Well, it is actually just like what we had for Tagalog above in <exampleRef
letter="xTagalogPartialRedupProcess"
num="xTagalogPartialRedupProcess"
></exampleRef
>: we need to specify the first consonant and the first vowel. These two items are the material that will be copied from the stem. Since every pattern must include it, we also need to then specify “whatever else is left over."</p
><p
>What will the result be? Like with the Tagalog case, we need to copy the initial consonant and copy the initial vowel. This time, however, we need to then insert an <langData
lang="lNahuatl"
>h</langData
>. After this we need the morpheme boundary, then the first consonant, the first vowel, and finally “whatever else is left over." The process rule might look like this:</p
><example
num="xNahuatlPartialRedupProcess"
><table
border="1"
><tr
><th
colspan="3"
>Pattern</th
><th
valign="middle"
> </th
><th
>Result</th
></tr
><tr
><td
align="center"
><object
type="TT"
>[C]</object
></td
><td
align="center"
><object
type="TT"
>[V]</object
></td
><td
align="center"
><object
type="TT"
>X</object
></td
><td
rowspan="2"
valign="middle"
>⇒ </td
><td
rowspan="2"
valign="bottom"
> <object
type="TT"
>1 2 </object
><langData
lang="lNahuatl"
>h</langData
><object
type="TT"
> + 1 2 3</object
></td
></tr
><tr
><td
align="center"
><object
type="TT"
>1</object
></td
><td
align="center"
><object
type="TT"
>2</object
></td
><td
align="center"
><object
type="TT"
> 3 </object
></td
></tr
></table
></example
><p
>Thus, in <exampleRef
letter="xNahuatlPartialRedupProcess"
num="xNahuatlPartialRedupProcess"
></exampleRef
> the pattern has three parts: the initial consonant (<object
type="TT"
>[C]</object
>), the vowel that follows it (<object
type="TT"
>[V]</object
>), and “whatever else is left over" (the <object
type="TT"
>X</object
>). Notice that these each have their respective index number, 1 through 3. The result is to copy the initial consonant (indicated by the first <object
type="TT"
>1</object
>), copy the initial vowel (indicated by the first <object
type="TT"
>2</object
>), insert the phoneme <langData
lang="lNahuatl"
>h</langData
>, the morpheme boundary (indicated by the <object
type="TT"
>+</object
>), and then to keep the original stem itself: the initial consonant (indicated by the last <object
type="TT"
>1</object
>), the initial vowel (indicated by the last <object
type="TT"
>2</object
>), and “whatever else is left over" (indicated by the <object
type="TT"
>3</object
>).</p
></section4
></section3
><section3
id="sHermitCrabInfixation"
><secTitle
>Infixation as a process</secTitle
><p
><indexedItem
term="iInfixation"
></indexedItem
>Now let's consider another kind of affix process for which we can write a process rule: infixation.</p
><p
><indexedItem
term="iTagalog"
></indexedItem
>Suppose one has an infix -<langData
lang="lTagalog"
>um</langData
>- that inserts after the first consonant of the stem like we saw above for Tagalog in section <sectionRef
sec="sIssueInfixation"
></sectionRef
> (this is part of <exampleRef
letter="xTagalogInfixation"
num="xTagalogInfixation"
></exampleRef
> repeated here for your convenience):</p
><example
num="xTagalogInfixation-1"
><listWord
letter="xSulat-1"
><langData
lang="lTagalog"
>sulat</langData
><gloss
lang="lGloss"
>‘to write or writing (infinitive form)’</gloss
></listWord
><listWord
letter="xSumulat-1"
><langData
lang="lTagalog"
>sumulat</langData
><gloss
lang="lGloss"
>‘to write (with actor focus)’</gloss
></listWord
></example
><p
>Once again, to treat this as a process, we need to identify the pattern and then identify the result. What is the pattern? The pattern begins with the initial consonant and is followed by whatever else the stem might have.</p
><p
>What is the result? The result would be to copy the initial consonant, insert the form of the infix (<langData
lang="lTagalog"
>um</langData
>), and then copy whatever the rest of the stem was. It might look like this:</p
><example
num="xTagalogAffixProcess"
><table
border="1"
><tr
><th
colspan="2"
>Pattern</th
><th
valign="middle"
> </th
><th
>Result</th
></tr
><tr
><td
align="center"
><object
type="TT"
>[C]</object
></td
><td
align="center"
><object
type="TT"
>X</object
></td
><td
rowspan="2"
valign="middle"
>⇒ </td
><td
rowspan="2"
valign="bottom"
> <object
type="TT"
>1</object
> <langData
lang="lTagalog"
>u m</langData
> <object
type="TT"
>2</object
></td
></tr
><tr
><td
align="center"
><object
type="TT"
>1</object
></td
><td
align="center"
><object
type="TT"
> 2 </object
></td
></tr
></table
></example
><p
>So in <exampleRef
letter="xTagalogAffixProcess"
num="xTagalogAffixProcess"
></exampleRef
>, the pattern consists of the consonant natural class (indicated by <object
type="TT"
>[C]</object
>) and whatever else is in the stem (indicated by <object
type="TT"
>X</object
>). The result refers to the index number of the consonant natural class (<object
type="TT"
>1</object
>), inserts the phonemes of the infix (first <langData
lang="lTagalog"
>u</langData
> and then <langData
lang="lTagalog"
>m</langData
> in this case), and then it refers to the rest of the stem (indicated by the index number <object
type="TT"
>2</object
>).</p
><p
><indexedItem
term="iTobaBatak"
></indexedItem
>Some languages have an infix very much like the -<langData
lang="lTagalog"
>um</langData
>- of Tagalog, but with another situation to consider. For example, <citation
page="32"
ref="rYu2007"
></citation
> gives the following data from Toba Batak:</p
><example
num="xTobaBatak"
><listWord
letter="xTobaBatakA"
><langData
lang="lTobaBatak"
>b-al-átuk</langData
><gloss
lang="lGloss"
>‘ladder’</gloss
></listWord
><listWord
letter="xTobaBatakB"
><langData
lang="lTobaBatak"
>al-ógo</langData
><gloss
lang="lGloss"
>‘wind’</gloss
></listWord
></example
><p
>What is special about the <langData
lang="lTobaBatak"
>al</langData
> affix? It infixes after an initial consonant in <exampleRef
letter="xTobaBatakA"
num="xTobaBatakA"
></exampleRef
> whereas it prefixes before an initial vowel in <exampleRef
letter="xTobaBatakB"
num="xTobaBatakB"
></exampleRef
>. How can we deal with this case using the new <object
type="HermitCrab"
></object
>?</p
><p
>First, we can handle the consonant-initial case similarly to what we did for Tagalog. That is, we can write an affix process rule just like this:</p
><example
num="xTobaBatakAffixProcessA"
><table
border="1"
><tr
><th
colspan="2"
>Pattern</th
><th
valign="middle"
> </th
><th
>Result</th
></tr
><tr
><td
align="center"
><object
type="TT"
>[C]</object
></td
><td
align="center"
><object
type="TT"
>X</object
></td
><td
rowspan="2"
valign="middle"
>⇒ </td
><td
rowspan="2"
valign="bottom"
> <object
type="TT"
>1</object
> <langData
lang="lTagalog"
>a l</langData
> <object
type="TT"
>2</object
></td
></tr
><tr
><td
align="center"
><object
type="TT"
>1</object
></td
><td
align="center"
><object
type="TT"
> 2 </object
></td
></tr
></table
></example
><p
>This works just like what we had for Tagalog in <exampleRef
letter="xTagalogAffixProcess"
num="xTagalogAffixProcess"
></exampleRef
> except that it inserts different segmental material (<langData
lang="lTobaBatak"
>al</langData
> instead of <langData
lang="lTagalog"
>um</langData
>).</p
><p
>But how can we deal with the vowel initial case where the <langData
lang="lTobaBatak"
>al</langData
> affix prefixes before the vowel? All we need to do is to add a prefix allomorph to this lexical entry which is conditioned to occur before a vowel.</p
><section4
id="sInfixationRootAndPatternAsProcess"
><secTitle
>Infixation and Root and Pattern Morphology</secTitle
><p
><indexedItem
term="iRootAndPatternMorphology"
></indexedItem
><indexedItem
term="iSemitic"
></indexedItem
>Yet another way that infixation can be treated as a process was discussed in section <sectionRef
sec="sInfixationRootAndPattern"
></sectionRef
>. Consider the <indexedItem
term="iSilti"
></indexedItem
>Silt'i data repeated here for your convenience:</p
><example
num="xSilti2-1"
><interlinear
><lineGroup
><line
><wrd
><langData
lang="lSilti"
>wakaba</langData
></wrd
><wrd
><exampleRef
equal="yes"
letter="xSilti2"
num="xSilti2"
></exampleRef
></wrd
></line
><line
><wrd
><langData
lang="lSilti"
>a-a-wkb-a</langData
></wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>PERF-buy-3rdSgPERF</gloss
></wrd
></line
></lineGroup
><free
>‘he bought’</free
></interlinear
></example
><p
>Recall that such Semitic languages often have roots composed of three consonants, as exemplified in the Silt'i data in <exampleRef
equal="no"
letter="xSilti2-1"
letterOnly="no"
num="xSilti2-1"
></exampleRef
>, where ‘buy’ is the root <langData
lang="lSilti"
>wkb</langData
>. The aspect markers are composed of vowel patterns that fit between or around the root consonants, such as the <langData
lang="lSilti"
>a-a</langData
> vowel pattern indicating the perfective aspect.</p
><p
>Recall that in order to model this using the default <object
type="WordWorks"
></object
> parser, we had to treat each vowel as a distinct infix. So the analysis would look like what is in <exampleRef
letter="xSiltiAnalysis-1"
num="xSiltiAnalysis-1"
></exampleRef
>, assuming the inflectional template given in <exampleRef
letter="xSiltiTemplate-1"
num="xSiltiTemplate-1"
></exampleRef
>.</p
><example
num="xSiltiAnalysis-1"
><interlinear
><lineGroup
><line
><langData
lang="lSilti"
>wakaba</langData
></line
><line
><langData
lang="lSilti"
>a-a-wkb-a</langData
></line
><line
><gloss
lang="lGloss"
>Perf1-Perf2-buy-3rdSgPerf</gloss
></line
></lineGroup
></interlinear
></example
><example
num="xSiltiTemplate-1"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Aspect 1</th
><th
align="left"
valign="top"
>Aspect 2</th
><th
align="left"
valign="top"
>Stem</th
><th
align="left"
valign="top"
>Subject</th
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‑Perf1‑</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
>etc.</td
></tr
></table
></td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‑Perf2‑</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
>etc.</td
></tr
></table
></td
><td
> </td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‑3rdSgPerf</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
>etc.</td
></tr
></table
></td
></tr
></table
></example
><p
>What is bothersome about this analysis? It is that what is conceptually one morpheme had to be treated as two morphemes. That is, the <langData
lang="lSilti"
>-a- -a-</langData
> perfective aspect morpheme had to be split into two distinct entries.</p
><p
>With the new <object
type="HermitCrab"
></object
>, however, we can write an infix process rule for the single perfective aspect morpheme and our inflectional template can also include just a single slot for Aspect.</p
><p
>What would the pattern be for this perfective aspect? We would need the three consonants of the root, plus “whatever else.”</p
><p
>What would the result look like? It would be the first consonant, then the first <langData
lang="lSilti"
>a</langData
>, the second consonant, the second <langData
lang="lSilti"
>a</langData
>, the third consonant, and “whatever else.” So one way to do it would be like this:</p
><example
num="xSiltiPerfAsProcess"
><table
border="1"
><tr
><th
colspan="4"
>Pattern</th
><th
valign="middle"
> </th
><th
>Result</th
></tr
><tr
><td
align="center"
><object
type="TT"
>[C]</object
></td
><td
align="center"
><object
type="TT"
>[C]</object
></td
><td
align="center"
><object
type="TT"
>[C]</object
></td
><td
align="center"
><object
type="TT"
>X</object
></td
><td
rowspan="2"
valign="middle"
>⇒ </td
><td
rowspan="2"
valign="bottom"
> <object
type="TT"
>1</object
> <langData
lang="lSilti"
>a </langData
> <object
type="TT"
>2</object
><langData
lang="lSilti"
> a</langData
><object
type="TT"
> 3 4</object
></td
></tr
><tr
><td
align="center"
><object
type="TT"
>1</object
></td
><td
align="center"
><object
type="TT"
>2</object
></td
><td
align="center"
><object
type="TT"
>3</object
></td
><td
align="center"
><object
type="TT"
> 4 </object
></td
></tr
></table
></example
><p
>We could also simplify the inflectional template to look like this:</p
><example
num="xSiltiTemplate-1a"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Aspect</th
><th
align="left"
valign="top"
>Stem</th
><th
align="left"
valign="top"
>Subject</th
></tr
><tr
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‑Perf‑</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
>etc.</td
></tr
></table
></td
><td
> </td
><td
align="left"
valign="top"
><table
><tr
><td
align="left"
valign="top"
><gloss
lang="lGloss"
>‑3rdSgPerf</gloss
></td
></tr
><tr
><td
align="left"
valign="top"
>etc.<indexedRangeEnd
begin="bInfixation"
></indexedRangeEnd
></td
></tr
></table
></td
></tr
></table
></example
></section4
></section3
></section2
><section2
id="sHermitCrabPhonologicalRules"
><secTitle
>Phonological rules</secTitle
><p
><indexedRangeBegin
id="bPhonRules"
term="iPhonologicalRules"
></indexedRangeBegin
>Turning now to phonological processes, this section discusses how to write phonological rules using the new <object
type="HermitCrab"
></object
>. The basic capabilities of phonological rules are very similar to what are given in the classic generative phonology textbook <citation
ref="rKenstowiczAndKisseberth1979"
></citation
>. Since it is not really appropriate to review all of that material here, I will be assuming that you are familiar with the basic concepts. I will primarily illustrate such rules using several examples below.</p
><p
><indexedItem
term="iPhonRuleRuleFormula"
></indexedItem
>Note that “regular” phonological rules used in the new <object
type="HermitCrab"
></object
> follow the classic rule formula that describes the rule as a change from <object
type="Term"
>this</object
> to <object
type="Term"
>that</object
> when <object
type="Term"
>this</object
> occurs after <object
type="Term"
>C</object
> and before <object
type="Term"
>D</object
>.</p
><p
>The basic formula is given in <exampleRef
letter="xRegularPhologicalRuleFormula"
num="xRegularPhologicalRuleFormula"
></exampleRef
>:</p
><example
num="xRegularPhologicalRuleFormula"
><chart
><object
type="TT"
><object
type="Term"
>this</object
> → <object
type="Term"
>that</object
> / C _ D</object
></chart
></example
><pc
>where each of <object
type="TT"
><object
type="Term"
>this</object
></object
>, <object
type="TT"
><object
type="Term"
>that</object
></object
>, <object
type="TT"
>C</object
>, and <object
type="TT"
>D</object
> are either natural classes, segments or phonological feature structures. The first two are normally a single natural class, segment or feature structure, whereas the latter two may contain more than one of these in a sequence. The latter two may also be word boundary symbols. Neither <object
type="TT"
>C</object
> nor <object
type="TT"
>D</object
> are required. For deletion rules, <object
type="TT"
><object
type="Term"
>that</object
></object
>  is empty. Similarly, for insertion rules, <object
type="TT"
><object
type="Term"
>this</object
></object
>  is empty.</pc
><pc
>Another major characteristic of these rules is that they are ordered. That is, the output of <object
type="TT"
>rule</object
><object
type="Subscript"
>i</object
> becomes the input to <object
type="TT"
>rule</object
><object
type="Subscript"
>i+1</object
>.</pc
><section3
id="sHCRegularRules"
><secTitle
>“Regular” phonological rules</secTitle
><p
>This section provides several examples of how one might write non-metathesis or regular phonological rules. Section <appendixRef
app="sHCPhonMetathesis"
></appendixRef
> discusses an example of a metathesis rule.</p
><section4
id="sSelaruEpenthesis"
><secTitle
>Epenthesis</secTitle
><p
><indexedItem
term="iEpenthesis"
></indexedItem
>One of the issues mentioned in section <sectionRef
sec="sIssueEpenthesis"
></sectionRef
> was epenthesis. We can handle this as allomorphy (as in section <sectionRef
sec="sEpenthesis"
></sectionRef
>) or as a phonological rule. <indexedItem
term="iSelaru"
></indexedItem
>One case where a phonological rule is appropriate is in Selaru. Consider the following data:<endnote
id="nSelaruData"
><p
>The data presented here are from <citation
ref="rCowardAndCoward2000"
></citation
> and <citation
ref="rCowardGrammar"
></citation
>.</p
><p
>The abbreviations used in the glosses are:</p
><table
border="1"
><tr
><th
>Abbreviation</th
><th
>Meaning</th
></tr
><tr
><td
>2s</td
><td
>second person singular</td
></tr
><tr
><td
>3p</td
><td
>third person plural</td
></tr
><tr
><td
>3s</td
><td
>third person singular</td
></tr
></table
></endnote
></p
><example
num="xSelaruAEpen"
><listInterlinear
letter="xSelaruAEpenRoban"
><lineGroup
><line
><langData
lang="lSelaru"
>roban</langData
></line
><line
><langData
lang="lSelaru"
>r-oban</langData
></line
><line
><gloss
lang="lGloss"
>3p-hit</gloss
></line
></lineGroup
><free
>‘they hit’</free
></listInterlinear
><listInterlinear
letter="xSelaruAEpenRaknam"
><lineGroup
><line
><langData
lang="lSelaru"
>raknam</langData
></line
><line
><langData
lang="lSelaru"
>r-knam</langData
></line
><line
><gloss
lang="lGloss"
>3p-eat</gloss
></line
></lineGroup
><free
>‘they eat’</free
></listInterlinear
><listInterlinear
letter="xSelaruAEpenRba"
><lineGroup
><line
><langData
lang="lSelaru"
>rba</langData
></line
><line
><langData
lang="lSelaru"
>r-ba</langData
></line
><line
><gloss
lang="lGloss"
>3p-go</gloss
></line
></lineGroup
><free
>‘they go’</free
></listInterlinear
></example
><p
>Notice that the underlying form of the <gloss
lang="lGloss"
>3p</gloss
> prefix is <langData
lang="lSelaru"
>r</langData
>-. Where does the first <langData
lang="lSelaru"
>a</langData
> come from in <exampleRef
letter="xSelaruAEpenRaknam"
num="xSelaruAEpenRaknam"
></exampleRef
>, then? Under at least one analysis, we can say that the <langData
lang="lSelaru"
>a</langData
> is inserted or epenthesized as a default vowel in order to break up an unacceptable consonant cluster. If the <langData
lang="lSelaru"
>a</langData
> were not there, then the word would begin as <langData
lang="lSelaru"
>rkn</langData
> which is an invalid sequence of consonants in Selaru. So to make this word legitimate, we can say that there is a phonological rule that inserts the default vowel <langData
lang="lSelaru"
>a</langData
> after the first of three consecutive consonants. It might be written as</p
><example
num="xSelaruEpenRule"
><table
><tr
><td
valign="middle"
><object
type="tPhonRuleNullSet"
></object
></td
><td
valign="middle"
><indexedItem
term="iPhonRuleExamples"
></indexedItem
>---&gt;</td
><td
valign="middle"
><langData
lang="lSelaru"
>a</langData
></td
><td
valign="middle"
>/</td
><td
valign="middle"
><table
><tr
><td
valign="middle"
>C</td
></tr
></table
></td
><td
valign="middle"
>___</td
><td
valign="middle"
><table
><tr
><td
valign="middle"
>C</td
><td
valign="middle"
>C</td
></tr
></table
></td
></tr
></table
></example
><pc
>That is, when there are three consonants in a row, an epenthetic <langData
lang="lSelaru"
>a</langData
> is inserted between the first two consonants. <indexedItem
term="iEmptySetSymbol"
></indexedItem
>(I use the empty set symbol here to indicate that this is an insertion process; the user interface of FLEx uses a blank to indicate an insertion site.)</pc
></section4
><section4
id="sSealruGlide2Vowel"
><secTitle
>Glide becomes a vowel</secTitle
><p
><indexedItem
term="iSelaru"
></indexedItem
>Here is some more data from Selaru. <indexedItem
term="iApproximant"
></indexedItem
>Notice what happens to the underlying glides <langData
lang="lSelaru"
>w</langData
> and <langData
lang="lSelaru"
>y</langData
>.</p
><example
num="xSelaruGVW"
><listInterlinear
letter="xSelaruGVMwohut"
><lineGroup
><line
><langData
lang="lSelaru"
>mwohut</langData
></line
><line
><langData
lang="lSelaru"
>mw-ohut</langData
></line
><line
><gloss
lang="lGloss"
>2s-discern</gloss
></line
></lineGroup
><free
>‘you discern’</free
></listInterlinear
><listInterlinear
letter="xSelaruGVMuknam"
><lineGroup
><line
><langData
lang="lSelaru"
>muknam</langData
></line
><line
><langData
lang="lSelaru"
>mw-knam</langData
></line
><line
><gloss
lang="lGloss"
>2s-eat</gloss
></line
></lineGroup
><free
>‘you eat’</free
></listInterlinear
></example
><example
num="xSelaruGVY"
><listInterlinear
letter="xSelaruGVYoban"
><lineGroup
><line
><langData
lang="lSelaru"
>yoban</langData
></line
><line
><langData
lang="lSelaru"
>y-oban</langData
></line
><line
><gloss
lang="lGloss"
>3s-hit</gloss
></line
></lineGroup
><free
>‘he hit’</free
></listInterlinear
><listInterlinear
letter="xSelaruGVIknam"
><lineGroup
><line
><langData
lang="lSelaru"
>iknam</langData
></line
><line
><langData
lang="lSelaru"
>y-knam</langData
></line
><line
><gloss
lang="lGloss"
>3s-eat</gloss
></line
></lineGroup
><free
>‘he eats’</free
></listInterlinear
></example
><p
>These glides will sometimes surface as a vowel and sometimes as a glide. What are the conditioning factors for when they are a vowel and when they are a glide? Under at least one analysis, the glide becomes a vowel when it is followed by a consonant in a following morpheme. We can write a phonological rule to perform this process. It might look like the following:</p
><example
num="xSelaruGVRule"
><table
><tr
><td
valign="middle"
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>[</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
><indexedItem
term="iPhonRuleExamples"
></indexedItem
>?</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>consonantal</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>]</object
></td
></tr
></table
></td
><td
valign="middle"
>---&gt;</td
><td
valign="middle"
>V</td
><td
valign="middle"
>/</td
><td
valign="middle"
></td
><td
valign="middle"
>___</td
><td
valign="middle"
><table
><tr
><td
valign="middle"
>+</td
><td
valign="middle"
>C</td
></tr
></table
></td
></tr
></table
></example
><pc
>That is, a glide becomes a vowel when it is followed by a morpheme boundary and another consonant.</pc
><p
><indexedItem
term="iPhonRuleRuleOrdering"
></indexedItem
>In section <appendixRef
app="sSelaruEpenthesis"
></appendixRef
> there was a rule for epenthesizing an <langData
lang="lSelaru"
>a</langData
> after the first of three consonants (see <exampleRef
letter="xSelaruEpenRule"
num="xSelaruEpenRule"
></exampleRef
>). What would happen with <exampleRef
letter="xSelaruGVMuknam"
num="xSelaruGVMuknam"
></exampleRef
> and <exampleRef
letter="xSelaruGVIknam"
num="xSelaruGVIknam"
></exampleRef
> if the epenthesis rule applied before the rule in <exampleRef
letter="xSelaruGVRule"
num="xSelaruGVRule"
></exampleRef
>? We would get *<langData
lang="lSelaru"
>mawaknam</langData
> and *<langData
lang="lSelaru"
>yaknam</langData
>, respectively. Therefore, we either must be careful to order the rule in <exampleRef
letter="xSelaruGVRule"
num="xSelaruGVRule"
></exampleRef
> before the epenthesis rule or else we need to exclude the glides from the class of consonants.</p
></section4
><section4
id="sAwngiTone"
><secTitle
>Tone Processing</secTitle
><p
><indexedItem
term="iAwngi"
></indexedItem
><indexedItem
term="iPhonRuleTone"
></indexedItem
>Another potential use of phonological rules is for handling tone changes. Here is one simple illustration.</p
><p
>Consider the following word from Awngi:<endnote
id="nAwngi"
><p
>The Awngi data comes from Andreas Joswig, personnel communication (emails of 2008/11/19 and 2009/5/12).</p
><p
>The <langData
lang="lAwngi"
>ɨsk↗</langData
> root is actually the allomorph for first person singular or third person masculine or plural. The <langData
lang="lAwngi"
>-ɨɣwa</langData
> suffix is the past perfective form for all persons except second person plural and third person plural.</p
></endnote
></p
><example
num="xAwngi"
><interlinear
><lineGroup
><line
><langData
lang="lAwngi"
>ɨskɨ́ɣwa</langData
></line
><line
><langData
lang="lAwngi"
>ɨsk↗-ɨɣwa</langData
></line
><line
><gloss
lang="lGloss"
>be.there-past.perfective</gloss
></line
></lineGroup
><free
>‘I was there’ or ‘he was there’</free
></interlinear
></example
><p
>The root <langData
lang="lAwngi"
>ɨsk</langData
> has a final floating high tone (or, if you prefer to think of it in a different way, it causes a following tone to be raised). This is indicated here by the <langData
lang="lAwngi"
>↗</langData
> symbol. The suffix then gets the floating high tone (or it has the tone of its initial vowel raised).</p
><p
>How do we handle something like this with the new <object
type="HermitCrab"
></object
>? One way is to do the following.</p
><example
num="xAwngiSteps"
><chart
type="HowTo"
><ol
><li
>Create a custom tone phonological feature that has three values: <object
type="TT"
>high</object
>, <object
type="TT"
>low</object
>, and <object
type="TT"
>floating high</object
>.</li
><li
>Create distinct phonemes for each low-tone vowel and each high-tone vowel. (I assume Awngi marks high tone vowel with an acute accent and leaves low tone vowels unmarked.)</li
><li
>Give each low tone vowel a tone feature with a value of <object
type="TT"
>low</object
>.</li
><li
>Give each high tone vowel a tone feature with a value of <object
type="TT"
>high</object
>.</li
><li
>Also add a phoneme for the floating high tone (the <langData
lang="lAwngi"
>↗</langData
> symbol).</li
><li
>For the <langData
lang="lAwngi"
>↗</langData
> phoneme, give it a tone feature with a value of <object
type="TT"
>floating high</object
>.</li
><li
>Write two phonological rules and order them as follows:<ol
><li
>Dock the floating high tone.</li
><li
>Delete the floating high tone.</li
></ol
></li
></ol
></chart
></example
><p
>Here is how the docking rule might look:</p
><example
num="xAwngiDockRule"
><table
><tr
><td
valign="middle"
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎡</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
><indexedItem
term="iPhonRuleExamples"
></indexedItem
>+</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>syllabic</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎤</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎣</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>L</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>tone</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎦</object
></td
></tr
></table
></td
><td
valign="middle"
>---&gt;</td
><td
valign="middle"
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎡</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>+</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>syllabic</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎤</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎣</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>H</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>tone</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎦</object
></td
></tr
></table
></td
><td
valign="middle"
>/</td
><td
valign="middle"
><table
><tr
><td
valign="middle"
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>[</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
><langData
lang="lAwngi"
>↗</langData
></td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>tone</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>]</object
></td
></tr
></table
></td
><td
valign="middle"
><table
><tr
><td
valign="middle"
>[C]</td
><td
><table
cellpadding="0pt"
cellspacing="0pt"
><tr
><td
><object
type="Subscript"
> <object
type="tPhonRuleInfinity"
></object
> </object
></td
></tr
><tr
><td
><object
type="Subscript"
>0</object
></td
></tr
></table
></td
></tr
></table
></td
></tr
></table
></td
><td
valign="middle"
>___</td
><td
valign="middle"
></td
></tr
></table
></example
><pc
>This rule uses <object
type="TT"
>[+:syllabic]</object
> to indicate a vowel (or tone bearing unit). It means a low tone vowel becomes a high tone vowel when the low tone vowel is preceded by a floating high tone and where <indexedItem
term="iPhonRuleIteration"
></indexedItem
>there may be zero or more consonants in between. The use of the subscript <object
type="Subscript"
>0</object
> and the superscript <object
type="Superscript"
>∞</object
> after the consonant class <object
type="TT"
>[C]</object
> follows a standard notational device used in these kinds of phonological rules (see <citation
page="64"
ref="rKenstowiczAndKisseberth1979"
></citation
> and <citation
page="93"
ref="rHalleAndClements"
></citation
>). The subscript indicates the minimum number of occurrences and the superscript indicates the maximum number.<endnoteRef
note="nRuleIteration"
></endnoteRef
></pc
><p
><indexedItem
term="iPhonRuleDeletion"
></indexedItem
>Here is how the deletion rule might look:</p
><example
num="xAwngiDeletionRule"
><table
><tr
><td
valign="middle"
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>[</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
><langData
lang="lAwngi"
><indexedItem
term="iPhonRuleExamples"
></indexedItem
>↗</langData
></td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>tone</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>]</object
></td
></tr
></table
></td
><td
valign="middle"
>---&gt;</td
><td
valign="middle"
><indexedItem
term="iEmptySetSymbol"
></indexedItem
><object
type="tPhonRuleNullSet"
></object
></td
><td
valign="middle"
>/</td
><td
valign="middle"
></td
><td
valign="middle"
>___</td
><td
valign="middle"
></td
></tr
></table
></example
><pc
>That is, delete a floating high tone. (I use the empty set symbol here to indicate deletion; the user interface of FLEx uses a blank to indicate a deleted item.) Normally, deletion rules only apply once. If you find that you need a deletion rule to apply more than once, you will need to set the DelReapps Parser Parameter to more than zero. You will want to make this parameter be small or else the parser will run very slowly.</pc
><p
><indexedItem
term="iPhonRuleRuleOrdering"
></indexedItem
>Note that it is crucial for the docking rule to be ordered before the deletion rule. If we ordered them the other way around, then the docking rule would never apply because the floating high tone would have already been deleted.</p
></section4
><section4
id="sIndonesianNasalAssimilation"
><secTitle
>Nasal Assimilation</secTitle
><p
><indexedRangeBegin
id="bIndonesianNasalAssimilation"
term="iBahasaIndonesia"
></indexedRangeBegin
>Now let's look at some Bahasa Indonesia data for one of its “voice” or “focus” morphemes.<endnote
id="nIndonesianMengData"
><p
>The data presented here are from <citation
page="125"
ref="rHalleAndClements"
></citation
> and <citation
ref="rSneddon"
></citation
>. Since the latter does not always include stem glosses, some stem glosses were obtained via <link
href="http://www.babylon.com/define/108/Indonesian-English-Dictionary.html"
>http://www.babylon.com/define/108/Indonesian-English-Dictionary.html</link
> from May 21-28, 2009. The gloss for <langData
lang="lBahasaIndonesia"
>pijit</langData
> was gleaned from <link
href="http://www.kamus.net/result.php?w=id-indonesia&amp;q=pijit&amp;submit=Search&amp;e=0"
>http://www.kamus.net/result.php?w=id-indonesia&amp;q=pijit&amp;submit=Search&amp;e=0</link
> on May 26, 2009.</p
><p
>The abbreviations used in the glosses are:</p
><table
border="1"
><tr
><th
>Abbreviation</th
><th
>Meaning</th
></tr
><tr
><td
>-APPL</td
><td
>applicative</td
></tr
><tr
><td
>AV-</td
><td
>actor voice</td
></tr
><tr
><td
>CAUS-</td
><td
>causative (per-)</td
></tr
><tr
><td
>-CAUS</td
><td
>causative (-kan)</td
></tr
><tr
><td
>-CAUSi</td
><td
>causative (-i)</td
></tr
><tr
><td
>-CONT</td
><td
>continuative</td
></tr
><tr
><td
>-LOC</td
><td
>locative</td
></tr
><tr
><td
>-R</td
><td
>full stem reduplication</td
></tr
></table
><p
>Any errors in assigning glosses are mine.</p
><p
>We also use <langData
lang="lBahasaIndonesiaIPA"
>ⁿ </langData
> for the unspecified nasal instead of the more normal <langData
lang="lBahasaIndonesiaIPA"
>N</langData
>. See section <appendixRef
app="sHCTipsCase"
></appendixRef
> for an explanation.</p
></endnote
></p
><p
>Consider the following forms, where the first line is the orthographic form and the second line is the underlying form.</p
><example
num="xIndonesianmengVoicedObstruents"
><listInterlinear
letter="xIndonesianMembantu"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>membantu</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-bantu</langData
></line
><line
><gloss
lang="lGloss"
>AV-help</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMendengar"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>mendengar</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-deŋar</langData
></line
><line
><gloss
lang="lGloss"
>AV-hear</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMenggambar"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>menggambar</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-gambar</langData
></line
><line
><gloss
lang="lGloss"
>AV-draw.a.picture</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>What is the shape of the Actor Voice prefix? It appears that the final nasal assimilates to the point of articulation of the following voiced stop. We could write a rule for this as follows:</p
><example
num="xIndonesianNasalAssimulation"
><exampleHeading
><indexedItem
term="iPhonRuleExamples"
></indexedItem
><indexedItem
term="iPhonRuleAssimilation"
></indexedItem
><indexedItem
term="iPhonRuleAlphaVariables"
></indexedItem
>Nasal Assimilation</exampleHeading
><table
><tr
><td
valign="middle"
><langData
lang="lBahasaIndonesia"
>ⁿ</langData
></td
><td
valign="middle"
>---&gt;</td
><td
valign="middle"
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎡</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>+</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>nasal</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎤</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎣</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>α</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>Place</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎦</object
></td
></tr
></table
></td
><td
valign="middle"
>/</td
><td
valign="middle"
>[V]</td
><td
valign="middle"
>___</td
><td
valign="middle"
><table
><tr
><td
valign="middle"
>+</td
><td
valign="middle"
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎡</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>α</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>Place</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎤</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎣</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>-</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>sonorant</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎦</object
></td
></tr
></table
></td
></tr
></table
></td
></tr
></table
></example
><pc
>That is, a nasal unspecified for place of articulation will assimilate to the place of articulation of a following obstruent (when the nasal follows a vowel).<endnote
id="nAlphaVariables"
><p
><indexedItem
term="iPhonRuleAlphaVariables"
></indexedItem
>Please see the Help files to learn how to create these “feature variables” (also known as “alpha variables” since the first such variable is commonly represented by the Greek letter alpha α).</p
></endnote
></pc
><p
>The rule in <exampleRef
letter="xIndonesianNasalAssimulation"
num="xIndonesianNasalAssimulation"
></exampleRef
> exemplifies a process that happens in a number of languages.</p
><section5
id="sIndonesianNasalMess"
><secTitle
>Unspecified Nasal in Bahasa Indonesia</secTitle
><p
>The situation in Bahasa Indonesia, however, is actually much more complicated. For example, consider what happens with alveo-palatal affricates:</p
><example
num="xIndonesianmengAffricates"
><listInterlinear
letter="xIndonesianMenyjahit"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>menjahit</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-dʒahit</langData
></line
><line
><gloss
lang="lGloss"
>AV-sew</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMenycatat"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>mencatat</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-tʃatat</langData
></line
><line
><gloss
lang="lGloss"
>AV-write</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>Notice that while one might expect a palatal nasal <langData
lang="lBahasaIndonesiaIPA"
>ɲ</langData
> here, at least orthographically an alveolar <langData
lang="lBahasaIndonesia"
>n</langData
> is used. There are some other possibly orthographic conventions that appear to apply as well. Notice how things are written for a voiceless palatal fricative and a voiceless glottal fricative:</p
><example
num="xIndonesianmengSyAndH"
><listInterlinear
letter="xIndonesianMensyaratkan"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>mensyaratkan</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-ʃarat-kan</langData
></line
><line
><gloss
lang="lGloss"
>AV-condition-CAUS</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMenghitung"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>menghitung</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-hituŋ</langData
></line
><line
><gloss
lang="lGloss"
>AV-count</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>The palatal fricative uses the alveolar nasal <langData
lang="lBahasaIndonesia"
>n</langData
> where the glottal fricative uses the velar nasal <langData
lang="lBahasaIndonesia"
>ŋ</langData
>. That the glottal fricative takes the back-most nasal should not be surprising. There is no such thing as a glottal nasal, of course. It is surprising, however, that the palatal fricative does not use a palatal nasal when the orthography does have one (<langData
lang="lBahasaIndonesia"
>ny</langData
>).</p
><p
>We are not done with the interesting things that happen here. Consider what happens when a stem begins with a vowel:</p
><example
num="xIndonesianmengVowels"
><listInterlinear
letter="xIndonesianMengambil"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>mengambil</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-ambil</langData
></line
><line
><gloss
lang="lGloss"
>AV-take</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMengerang"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>mengerang</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-eraŋ</langData
></line
><line
><gloss
lang="lGloss"
>AV-groan</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMengisi"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>mengisi</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-isi</langData
></line
><line
><gloss
lang="lGloss"
>AV-fill.up</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMengolah"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>mengolah</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-olah</langData
></line
><line
><gloss
lang="lGloss"
>AV-process</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMengundang"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>mengundang</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-undaŋ</langData
></line
><line
><gloss
lang="lGloss"
>AV-invite</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>Notice how vowel-initial stems all take the velar nasal <langData
lang="lBahasaIndonesia"
>ng</langData
>. There is more. Consider the data below:</p
><example
num="xIndonesianmengSonorants"
><listInterlinear
letter="xIndonesianMelempar"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>melempar</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-lempar</langData
></line
><line
><gloss
lang="lGloss"
>AV-throw</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMenikah"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>menikah</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-nikah</langData
></line
><line
><gloss
lang="lGloss"
>AV-marry</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMengaco"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>mengaco</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-ŋatʃo</langData
></line
><line
><gloss
lang="lGloss"
>AV-chat</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMenyanyi"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>menyanyi</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-ɲaɲi</langData
></line
><line
><gloss
lang="lGloss"
>AV-sing</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMerasa"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>merasa</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-rasa</langData
></line
><line
><gloss
lang="lGloss"
>AV-feel</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMewakili"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>mewakili</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-wakil-i</langData
></line
><line
><gloss
lang="lGloss"
>AV-proxy-APPL</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMeyakini"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>meyakini</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-yakin-i</langData
></line
><line
><gloss
lang="lGloss"
>AV-certain-CAUSi</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>Notice how the <langData
lang="lBahasaIndonesiaIPA"
>məⁿ</langData
>- prefix surfaces as just <langData
lang="lBahasaIndonesia"
>me</langData
>. What is common among the initial segments of all the stems in <exampleRef
letter="xIndonesianmengSonorants"
num="xIndonesianmengSonorants"
></exampleRef
>? These are all sonorant consonants, so it appears that this affix loses its final nasal when it is followed by a sonorant consonant.</p
><p
>There is even more. Look at the following data:</p
><example
num="xIndonesianMengPTK"
><listInterlinear
letter="xIndonesianMemukul"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>memukul</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-pukul</langData
></line
><line
><gloss
lang="lGloss"
>AV-hit</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMenulis"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>menulis</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-tulis</langData
></line
><line
><gloss
lang="lGloss"
>AV-write</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMengirim"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>mengirim</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-kirim</langData
></line
><line
><gloss
lang="lGloss"
>AV-send</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>What is unusual here? Notice that while the unspecified nasal assimilates to the point of articulation of the following voiceless stop in <exampleRef
letter="xIndonesianMemukul"
num="xIndonesianMemukul"
></exampleRef
>-<exampleRef
letter="xIndonesianMengirim"
num="xIndonesianMengirim"
></exampleRef
>, that stop does not surface. So we might suppose that the nasal assimilates and then the voiceless stop deletes. What happens with other voiceless obstruents? Look at the following to see:</p
><example
num="xIndonesianmengFricatives"
><listInterlinear
letter="xIndonesianMemfitnah"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>memfitnah</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-fitnah</langData
></line
><line
><gloss
lang="lGloss"
>AV-slander</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMengkhawatirkan"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>mengkhawatirkan</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-xawatir-kan</langData
></line
><line
><gloss
lang="lGloss"
>AV-worry-CAUS</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMenyewa"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>menyewa</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-sewa</langData
></line
><line
><gloss
lang="lGloss"
>AV-lease</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMensyaratkan2"
><lineGroup
><line
><wrd
><langData
lang="lBahasaIndonesia"
>mensyaratkan</langData
></wrd
><wrd
><exampleRef
equal="yes"
letter="xIndonesianMensyaratkan"
num="xIndonesianMensyaratkan"
></exampleRef
></wrd
></line
><line
><wrd
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-ʃarat-kan</langData
></wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>AV-condition-CAUS</gloss
></wrd
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMenziarahi"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>menziarahi</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-ziarah-i</langData
></line
><line
><gloss
lang="lGloss"
>AV-make.a.pilgrimage-LOC</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMenghitung2"
><lineGroup
><line
><wrd
><langData
lang="lBahasaIndonesia"
>menghitung</langData
></wrd
><wrd
><exampleRef
equal="yes"
letter="xIndonesianMenghitung"
num="xIndonesianMenghitung"
></exampleRef
></wrd
></line
><line
><wrd
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-hituŋ</langData
></wrd
></line
><line
><wrd
><gloss
lang="lGloss"
>AV-count</gloss
></wrd
></line
></lineGroup
></listInterlinear
></example
><p
>Notice that there is only one fricative that deletes: <langData
lang="lBahasaIndonesia"
>s</langData
>. None of the other fricatives delete, even the voiceless ones like <langData
lang="lBahasaIndonesia"
>f</langData
>, <langData
lang="lBahasaIndonesia"
>sy</langData
>, and <langData
lang="lBahasaIndonesia"
>h</langData
>. Further, <langData
lang="lBahasaIndonesia"
>s</langData
> not only deletes, the nasal that is written in the practical orthography is palatal <langData
lang="lBahasaIndonesia"
>ny</langData
> instead of the expected <langData
lang="lBahasaIndonesia"
>n</langData
>.</p
><p
>To summarize, this is what we have seen:</p
><example
num="xIndonesianNFactors"
><chart
><ol
><li
>The unspecified nasal becomes <langData
lang="lBahasaIndonesia"
>ng</langData
> before a vowel.</li
><li
>The unspecified nasal deletes before a sonorant consonant.</li
><li
>The unspecified nasal assimilates to the point of articulation of a following obstruent with the following exceptions:<ol
><li
><langData
lang="lBahasaIndonesia"
>h</langData
> takes <langData
lang="lBahasaIndonesia"
>ng</langData
>.</li
><li
><langData
lang="lBahasaIndonesia"
>s</langData
> takes <langData
lang="lBahasaIndonesia"
>ny</langData
>.</li
><li
><langData
lang="lBahasaIndonesia"
>sy</langData
> takes <langData
lang="lBahasaIndonesia"
>n</langData
>.</li
></ol
></li
><li
>The following phonemes assimilate and then delete: <langData
lang="lBahasaIndonesia"
>p</langData
>, <langData
lang="lBahasaIndonesia"
>t</langData
>, <langData
lang="lBahasaIndonesia"
>k</langData
>, and <langData
lang="lBahasaIndonesia"
>s</langData
>.</li
></ol
></chart
></example
><p
>How might we deal with such an intricate combination of arguably unexpected factors and successfully implement them in <object
type="WordWorks"
></object
> using the new <object
type="HermitCrab"
></object
>? Here is one possible way:</p
><example
num="xIndonesianNHowTo"
><chart
type="HowTo"
><ol
><li
>Create the phonological features to use.</li
><li
>Make sure every phoneme is defined.</li
><li
>Assign these features to each phoneme.</li
><li
>Write a number of ordered phonological rules to deal with each case.</li
></ol
></chart
></example
><p
>How might we do the first step? Given that there appear to be some orthographic conventions employed in the practical orthography, one way to deal with some of the unusual assimilations is to create a special “orthographic place” feature and assign the phonemes to use the place involved in the practical orthography.</p
><p
>In addition, there is the problem with the segments that delete as illustrated above in <exampleRef
letter="xIndonesianMengPTK"
num="xIndonesianMengPTK"
></exampleRef
> and <exampleRef
letter="xIndonesianMenyewa"
num="xIndonesianMenyewa"
></exampleRef
>. To my knowledge, there is no true natural set of features that can encompass <langData
lang="lBahasaIndonesia"
>p</langData
>, <langData
lang="lBahasaIndonesia"
>t</langData
>, <langData
lang="lBahasaIndonesia"
>k</langData
>, and <langData
lang="lBahasaIndonesia"
>s</langData
> without also including some of the other voiceless fricatives. So one way to deal with this is to create a custom feature where <langData
lang="lBahasaIndonesia"
>p</langData
>, <langData
lang="lBahasaIndonesia"
>t</langData
>, <langData
lang="lBahasaIndonesia"
>k</langData
>, and <langData
lang="lBahasaIndonesia"
>s</langData
> have the <object
type="TT"
>+</object
> value and all other segments have the <object
type="TT"
>-</object
> value.</p
><p
>The phoneme-feature matrix shown in <exampleRef
letter="xIndonesianPhonemeFeatureMatrix"
num="xIndonesianPhonemeFeatureMatrix"
></exampleRef
> illustrates one way that the first three steps of <exampleRef
letter="xIndonesianNHowTo"
num="xIndonesianNHowTo"
></exampleRef
> could be done (see the <object
type="TT"
>OrthPlace</object
> feature for the assimilation place and the custom <object
type="TT"
>NO→N</object
> feature for the four segments which delete).<endnote
id="nIndonesianPhonemeFeatureMatrix"
><p
>The first “phoneme” is a hyphen which is used in full reduplicated forms. See <appendixRef
app="sHCRedupFull"
></appendixRef
>. Note that its features uniquely identify it so that it cannot be confused with any other phoneme. Another way to deal with this would be to create a custom feature for which the hyphen is the only phoneme that has a <object
type="TT"
>+</object
> value; all other phonemes would have a <object
type="TT"
>-</object
> value for this custom feature. (See section <appendixRef
app="sHCTipsUniquePhoneme"
></appendixRef
>.) The <object
type="TT"
>OrthPlace</object
> feature is a custom feature whose possible values indicate the place of articulation (<object
type="TT"
>labial</object
>, <object
type="TT"
>alveolar</object
>, <object
type="TT"
>palatal</object
>, <object
type="TT"
>velar</object
>, and <object
type="TT"
>glottal</object
>) or that the segment is unspecified for place (<object
type="TT"
>?</object
>). (The name reflects the observation that how this works seems to be more orthographic conventions than true place of articulation.) The <object
type="TT"
>NO→N</object
> feature's name is an attempt to imply that these segments (the <object
type="TT"
>O</object
>) delete after an unspecified nasal (the <object
type="TT"
>N</object
>).</p
></endnote
></p
><example
num="xIndonesianPhonemeFeatureMatrix"
><table
border="1"
type="tLeftOffset"
><tr
><th
> <indexedItem
term="iPhonRulePhonemeFeatureMatrix"
></indexedItem
></th
><th
>approx</th
><th
>back</th
><th
>cons</th
><th
>cont</th
><th
>dr</th
><th
>high</th
><th
>lat</th
><th
>low</th
><th
>nas</th
><th
>NO→N</th
><th
>OrthPlace</th
><th
>son</th
><th
>syl</th
><th
>voice</th
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>-</langData
></th
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>a</langData
></th
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>b</langData
></th
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>labial</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>c</langData
></th
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>alveolar</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>d</langData
></th
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>alveolar</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>e</langData
></th
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>f</langData
></th
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>labial</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>g</langData
></th
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>velar</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>h</langData
></th
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>velar</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>i</langData
></th
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>j</langData
></th
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>alveolar</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>k</langData
></th
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>velar</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>kh</langData
></th
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>velar</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>l</langData
></th
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>alveolar</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>m</langData
></th
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>labial</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>n</langData
></th
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>alveolar</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>ⁿ</langData
></th
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>?</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>ng</langData
></th
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>velar</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>ny</langData
></th
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>palatal</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>o</langData
></th
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>p</langData
></th
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>labial</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>r</langData
></th
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>alveolar</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>s</langData
></th
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>palatal</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>sy</langData
></th
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>alveolar</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>t</langData
></th
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>alveolar</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>u</langData
></th
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>w</langData
></th
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>velar</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>y</langData
></th
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>palatal</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lBahasaIndonesia"
>z</langData
></th
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>alveolar</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
></table
></example
><p
>Having devised a phonological feature system and assigned the appropriate feature values to the phonemes, the next step from <exampleRef
letter="xIndonesianNHowTo"
num="xIndonesianNHowTo"
></exampleRef
> is to write the phonological rules. What should they be? One way is to write rules for each of the four items given in <exampleRef
letter="xIndonesianNFactors"
num="xIndonesianNFactors"
></exampleRef
> above.</p
><p
>The following rule addresses the case for the vowels:</p
><example
num="xIndonesianUnspecifedNasalVowelRule"
><table
><tr
><td
valign="middle"
><langData
lang="lBahasaIndonesia"
>ⁿ</langData
></td
><td
valign="middle"
>---&gt;</td
><td
valign="middle"
><langData
lang="lBahasaIndonesia"
>ng</langData
></td
><td
valign="middle"
>/</td
><td
valign="middle"
></td
><td
valign="middle"
>___</td
><td
valign="middle"
><table
><tr
><td
valign="middle"
>+</td
><td
valign="middle"
>[V]</td
></tr
></table
></td
></tr
></table
></example
><pc
>That is, an unspecified nasal becomes a velar nasal before a vowel-initial morpheme.</pc
><p
>The next rule handles the case for the sonorant consonants:</p
><example
num="xIndonesianUnspecifedNasalSonorantConsonantRule"
><table
><tr
><td
valign="middle"
><langData
lang="lBahasaIndonesia"
>ⁿ</langData
></td
><td
valign="middle"
>---&gt;</td
><td
valign="middle"
><object
type="tPhonRuleNullSet"
></object
></td
><td
valign="middle"
>/</td
><td
valign="middle"
></td
><td
valign="middle"
>___</td
><td
valign="middle"
><table
><tr
><td
valign="middle"
>+</td
><td
valign="middle"
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎡</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>+</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>consonantal</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎤</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎣</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>+</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>sonorant</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎦</object
></td
></tr
></table
></td
></tr
></table
></td
></tr
></table
></example
><pc
>That is, an unspecified nasal deletes before a morpheme-initial sonorant consonant.</pc
><p
>The third rule does the nasal assimilation. Note how it is similar to <exampleRef
letter="xIndonesianNasalAssimulation"
num="xIndonesianNasalAssimulation"
></exampleRef
> above.</p
><example
num="xIndonesianUnspecifedNasalAssimilationRule"
><table
><tr
><td
valign="middle"
><langData
lang="lBahasaIndonesia"
>ⁿ</langData
></td
><td
valign="middle"
>---&gt;</td
><td
valign="middle"
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎡</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>+</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>nasal</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎤</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎣</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>α</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>OrthPlace</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎦</object
></td
></tr
></table
></td
><td
valign="middle"
>/</td
><td
valign="middle"
>[V]</td
><td
valign="middle"
>___</td
><td
valign="middle"
><table
><tr
><td
valign="middle"
>+</td
><td
valign="middle"
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎡</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>α</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>OrthPlace</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎤</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎣</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>-</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>sonorant</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎦</object
></td
></tr
></table
></td
></tr
></table
></td
></tr
></table
></example
><pc
>That is, an unspecified nasal assimilates to the place of articulation of a following obstruent when that obstruent begins another morpheme within the word. Note that by using the special <object
type="TT"
>OrthPlace</object
> feature and by setting its values to the implied place of articulation used in the orthography for segments like <langData
lang="lBahasaIndonesia"
>c</langData
>, <langData
lang="lBahasaIndonesia"
>j,</langData
> <langData
lang="lBahasaIndonesia"
>s</langData
>, <langData
lang="lBahasaIndonesia"
>sy</langData
>, and <langData
lang="lBahasaIndonesia"
>h</langData
> that orthographically assimilate to unexpected values, we avoid having to write special exception rules. The rule in <exampleRef
letter="xIndonesianUnspecifedNasalAssimilationRule"
num="xIndonesianUnspecifedNasalAssimilationRule"
></exampleRef
> will take care of these cases, too.</pc
><p
>The fourth and final rule is the one that takes care of the special case of the four segments that delete after assimilation.</p
><example
num="xIndonesianUnspecifedVoicelessObstruentDeletionRule"
><table
><tr
><td
valign="middle"
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>[</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>+</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>NO→N</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>]</object
></td
></tr
></table
></td
><td
valign="middle"
>---&gt;</td
><td
valign="middle"
><object
type="tPhonRuleNullSet"
></object
></td
><td
valign="middle"
>/</td
><td
valign="middle"
><table
><tr
><td
valign="middle"
><langData
lang="lBahasaIndonesia"
>e</langData
></td
><td
valign="middle"
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>[</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>+</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>nasal</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>]</object
></td
></tr
></table
></td
><td
valign="middle"
>+</td
></tr
></table
></td
><td
valign="middle"
>___</td
><td
valign="middle"
>[V]</td
></tr
></table
></example
><pc
>That is, delete a voiceless obstruent with the special <object
type="TT"
>[+:NO→N]</object
> feature when it occurs after the unspecified nasal across a morpheme boundary. Since my understanding is that the only time Bahasa Indonesia has an unspecified nasal, that unspecified nasal is preceded by the vowel <langData
lang="lBahasaIndonesia"
>e</langData
>, I've added this to the environment. It may make the new <object
type="HermitCrab"
></object
> run a bit more efficiently.</pc
><p
><indexedItem
term="iPhonRuleRuleOrdering"
></indexedItem
>What would happen if we reversed the order of the last two rules <exampleRef
letter="xIndonesianUnspecifedNasalAssimilationRule"
num="xIndonesianUnspecifedNasalAssimilationRule"
></exampleRef
> and <exampleRef
letter="xIndonesianUnspecifedVoicelessObstruentDeletionRule"
num="xIndonesianUnspecifedVoicelessObstruentDeletionRule"
></exampleRef
>? The <langData
lang="lBahasaIndonesia"
>p</langData
>, <langData
lang="lBahasaIndonesia"
>t</langData
>, <langData
lang="lBahasaIndonesia"
>k</langData
>, and <langData
lang="lBahasaIndonesia"
>s</langData
> would all delete before there was an opportunity for the unspecified nasal to assimilate. Therefore, it is crucial that we order these rules correctly.</p
></section5
><section5
id="sIndonesianNasalMessPlusRedup"
><secTitle
>Unspecified nasal and full reduplication in Bahasa Indonesia</secTitle
><p
><indexedItem
term="iRedupFull"
></indexedItem
>There is actually yet another complication in Bahasa Indonesia with the four segments that can assimilate and then delete. Consider the following forms where the verb stem is fully reduplicated as the continuative morpheme.<endnote
id="nMenunda-nunda"
><p
>Thanks to Jonathan Coombs (personal communication, email of May 30, 2012) for pointing out that the form in <exampleRef
letter="xIndonesianMenanti-nanti"
num="xIndonesianMenanti-nanti"
></exampleRef
> in earlier versions of this document (<langData
lang="lBahasaIndonesia"
>menunda-nunda</langData
>) is actually from the root <langData
lang="lBahasaIndonesia"
>tunda</langData
>, not the root *<langData
lang="lBahasaIndonesia"
>nunda</langData
>. He also suggested using <langData
lang="lBahasaIndonesia"
>menanti-nanti</langData
> whose root is indeed <langData
lang="lBahasaIndonesia"
>nanti</langData
>.</p
></endnote
></p
><example
num="xIndonesianmengFullRedup"
><listInterlinear
letter="xIndonesianMengurut-urut"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>mengurut-urut</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-urut-R</langData
></line
><line
><gloss
lang="lGloss"
>AV-stroke-CONT</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMenanti-nanti"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>menanti-nanti</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-nanti-R</langData
></line
><line
><gloss
lang="lGloss"
>AV-wait-CONT</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMembagi-bagi"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>membagi-bagi</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-bagi-R</langData
></line
><line
><gloss
lang="lGloss"
>AV-divide-CONT</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMemijit-mijit"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>memijit-mijit</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-pijit-R</langData
></line
><line
><gloss
lang="lGloss"
>AV-massage-CONT</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMenulis-nulis"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>menulis-nulis</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-tulis-R</langData
></line
><line
><gloss
lang="lGloss"
>AV-write-CONT</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMengayuh-ngayuh"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>mengayuh-ngayuh</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-kayuh-R</langData
></line
><line
><gloss
lang="lGloss"
>AV-pedal-CONT</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>What material is actually reduplicated? In <exampleRef
letter="xIndonesianMengurut-urut"
num="xIndonesianMengurut-urut"
paren="initial"
></exampleRef
>-<exampleRef
letter="xIndonesianMembagi-bagi"
letterOnly="yes"
num="xIndonesianMembagi-bagi"
paren="final"
></exampleRef
> it is clear that the original verb stem is reduplicated. In <exampleRef
letter="xIndonesianMemijit-mijit"
num="xIndonesianMemijit-mijit"
paren="initial"
></exampleRef
>-<exampleRef
letter="xIndonesianMengayuh-ngayuh"
letterOnly="yes"
num="xIndonesianMengayuh-ngayuh"
paren="final"
></exampleRef
>, however, what is reduplicated is the result of the assimilation rule as well as the deletion rule. For example, while one might expect to get *<langData
lang="lBahasaIndonesia"
>memijit-pijit</langData
> for <exampleRef
letter="xIndonesianMemijit-mijit"
num="xIndonesianMemijit-mijit"
></exampleRef
>; instead the assimilated <langData
lang="lBahasaIndonesia"
>m</langData
> is what is actually reduplicated.</p
><p
>Using the new <object
type="HermitCrab"
></object
>, it is possible to write a phonological rule that will handle this complex situation. Let's assume that we have created a reduplication entry for the continuative suffix which uses an affix process identical to what we had in <exampleRef
letter="xIndonesianFullRedupProcess"
num="xIndonesianFullRedupProcess"
></exampleRef
>. Also recall that when using the new <object
type="HermitCrab"
></object
> we need to think generatively. For the case of <exampleRef
letter="xIndonesianMemijit-mijit"
num="xIndonesianMemijit-mijit"
paren="initial"
></exampleRef
>-<exampleRef
letter="xIndonesianMengayuh-ngayuh"
letterOnly="yes"
num="xIndonesianMengayuh-ngayuh"
paren="final"
></exampleRef
>, this means that we need to assume that the continuative suffix process will apply to the verb stem, resulting in the reduplication of the underlying form of the verb stem. After this process, the <langData
lang="lBahasaIndonesia"
>meⁿ</langData
>- prefix will attach. Finally, we apply our phonological rules to the result. Thus, for the case of <exampleRef
letter="xIndonesianMemijit-mijit"
num="xIndonesianMemijit-mijit"
></exampleRef
>, the input to the phonological rules would be</p
><example
num="xIndonesianMemijit-mijitPhinRuleInput"
><word
><langData
lang="lBahasaIndonesia"
>meⁿ<object
type="TT"
>+</object
>pijit<object
type="TT"
>+</object
>pijit</langData
></word
></example
><p
>We then need a phonological rule that will match the “deletable” voiceless obstruent at the beginning of the reduplication suffix and change it to its corresponding nasal, when somewhere to the left of it, there is an unspecified nasal followed by the same “deletable” voiceless obstruent. In the case of <exampleRef
letter="xIndonesianMemijit-mijitPhinRuleInput"
num="xIndonesianMemijit-mijitPhinRuleInput"
></exampleRef
>, we need to match the <langData
lang="lBahasaIndonesia"
>p</langData
> just after the reduplication hyphen and change it to an <langData
lang="lBahasaIndonesia"
>m</langData
>. Here is a rule that will do this:</p
><example
num="xIndonesianUnspecifedNasalFullRedupRule"
><table
><tr
><td
valign="middle"
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎡</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>+</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>NO→N</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎤</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎢</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>α</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>OrthPlace</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎥</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎢</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>-</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>sonorant</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎥</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎣</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>-</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>voice</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎦</object
></td
></tr
></table
></td
><td
valign="middle"
>---&gt;</td
><td
valign="middle"
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎡</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
><indexedItem
term="iPhonRuleExamples"
></indexedItem
>-</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>continuant</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎤</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎢</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>-</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>NO→N</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎥</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎢</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>+</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>nasal</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎥</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎢</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>α</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>OrthPlace</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎥</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎢</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>+</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>sonorant</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎥</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎣</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>+</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>voice</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎦</object
></td
></tr
></table
></td
><td
valign="middle"
>/</td
><td
valign="middle"
><table
><tr
><td
valign="middle"
><langData
lang="lBahasaIndonesia"
>e</langData
></td
><td
valign="middle"
><langData
lang="lBahasaIndonesia"
>ⁿ</langData
></td
><td
valign="middle"
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎡</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>+</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>NO→N</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎤</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎢</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>α</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>OrthPlace</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎥</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎢</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>-</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>sonorant</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎥</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎣</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>-</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>voice</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎦</object
></td
></tr
></table
></td
><td
valign="middle"
><table
><tr
><td
valign="middle"
>[A]</td
><td
><table
cellpadding="0pt"
cellspacing="0pt"
><tr
><td
><object
type="Subscript"
> <object
type="tPhonRuleInfinity"
></object
> </object
></td
></tr
><tr
><td
><object
type="Subscript"
>0</object
></td
></tr
></table
></td
></tr
></table
></td
><td
valign="middle"
>-</td
></tr
></table
></td
><td
valign="middle"
>___</td
><td
valign="middle"
></td
></tr
></table
></example
><pc
>What does all this mean? Remember that all phonological rules follow the basic formula of <exampleRef
letter="xRegularPhologicalRuleFormula"
num="xRegularPhologicalRuleFormula"
></exampleRef
>. The <object
type="Term"
>this</object
> of <exampleRef
letter="xRegularPhologicalRuleFormula"
num="xRegularPhologicalRuleFormula"
></exampleRef
> is the first feature structure. The <object
type="Term"
>that</object
> is the second feature structure. In addition, there is only the left environment (the <object
type="TT"
>C</object
> of <exampleRef
letter="xRegularPhologicalRuleFormula"
num="xRegularPhologicalRuleFormula"
></exampleRef
>).</pc
><p
>One way to read this is that when there is a voiceless obstruent (indicated by <object
type="TT"
>[-:voice]</object
> and <object
type="TT"
>[-:sonorant]</object
>) which can undergo the special deletion (indicated by <object
type="TT"
>[+: NO→N]</object
>), change this voiceless obstruent to a nasal (indicated by <object
type="TT"
>[+:nasal]</object
>) at the same place of articulation (indicated by <object
type="TT"
>[α:OrthPlace]</object
> in both the first and second features).<endnoteRef
note="nAlphaVariables"
></endnoteRef
> Two of the other four features mentioned in the <object
type="Term"
>that</object
> part of the rule (<object
type="TT"
>[+:sonorant]</object
>, and <object
type="TT"
>[+:voice]</object
>) are needed because nasals have these features while obstruents have their opposite values. Also, since the nasals do not undergo the special deletion, we need to include the feature <object
type="TT"
>[-:NO→N]</object
>. We need to overtly mention these nasal-oriented values in order for the parser to correctly identify the nasal segment. If we left these out, then the parser would have a set of features that did not match any known phoneme and therefore, the rule would not work for us. The reason that the <object
type="TT"
>[-:continuant]</object
> feature is also used in the <object
type="Term"
>that</object
> part of the rule is that while the <langData
lang="lBahasaIndonesia"
>p</langData
>, <langData
lang="lBahasaIndonesia"
>t</langData
>, and <langData
lang="lBahasaIndonesia"
>k</langData
> segments already have the <object
type="TT"
>[-:continuant]</object
> feature (since they are stops), the <langData
lang="lBahasaIndonesia"
>s</langData
> segment does not (because it is a fricative and fricatives are <object
type="TT"
>[+:continuant]</object
>).</p
><p
>Turning now to the context of this rule, first note that it uses a natural class <object
type="TT"
>[A]</object
>. This is a custom natural class I added to this language project that consists of all the phonemes in the language (except for the orthographic hyphen). Having noted this, what does this context mean? I'll explain it working from where the <object
type="Term"
>this</object
> is found back to the left toward the front of the word: there must be an orthographic hyphen immediately before the <object
type="Term"
>this</object
>. <indexedItem
term="iPhonRuleIteration"
></indexedItem
>To the left of this there must be zero or more segments, indicated by the custom natural class <object
type="TT"
>[A]</object
> and the subscript <object
type="Subscript"
>0</object
> along with the superscript <object
type="Superscript"
>∞</object
>. This follows a standard notational device used in these kinds of phonological rules (see <citation
page="64"
ref="rKenstowiczAndKisseberth1979"
></citation
> and <citation
page="93"
ref="rHalleAndClements"
></citation
>). The subscript indicates the minimum number of occurrences and the superscript indicates the maximum number.<endnote
id="nRuleIteration"
><p
><indexedItem
term="iPhonRuleIteration"
></indexedItem
>Note that in order to create the iteration (zero or more) on the consonant class in the <object
type="WordWorks"
></object
> user interface for phonological rules, you may need select the consonant class and then perform a right click. Please see the Help files for setting occurrence (min. and max.) for how to add these to a rule.</p
></endnote
> In this case, we do not know how many there may be so we use any possible number (we could be more specific, especially at the maximum, but using infinity means that we never need to worry about what that maximum might be). So we use this special natural class with this notational device to indicate the “somewhere to the left of the hyphen.” What we want to find is the exact same segment that is in the <object
type="Term"
>this</object
> match. So note that to the immediate left of the <object
type="TT"
>[A]</object
> natural class is the same set of features used for the <object
type="TT"
>this</object
> match. Since we do not want to match just any such segment, but only the one that immediately follows the unspecified nasal, we put the unspecified nasal <langData
lang="lBahasaIndonesia"
>ⁿ</langData
> just before it. Finally, since it just so happens that all instances of the unspecified nasal in Bahasa Indonesia (as far as I know) are preceded by the vowel <langData
lang="lBahasaIndonesia"
>e</langData
>, we include that vowel, too.</p
></section5
><section5
id="sIndonesianNasalMessLoans"
><secTitle
>Unspecified nasal exceptions in Bahasa Indonesia</secTitle
><p
>Having addressed how to model most of the complications of the unspecified nasal in Bahasa Indonesia, it should be noted that there are at least three exceptional cases where the <langData
lang="lBahasaIndonesia"
>p</langData
>, <langData
lang="lBahasaIndonesia"
>t</langData
>, <langData
lang="lBahasaIndonesia"
>k</langData
>, and <langData
lang="lBahasaIndonesia"
>s</langData
> segments do not delete.</p
><p
>First, when the <langData
lang="lBahasaIndonesia"
>meⁿ</langData
>- prefix is followed immediately by the <langData
lang="lBahasaIndonesia"
>per</langData
>- prefix, the <langData
lang="lBahasaIndonesia"
>p</langData
> of the <langData
lang="lBahasaIndonesia"
>per</langData
>- prefix does not delete as illustrated in <exampleRef
letter="xIndonesianMengPer"
num="xIndonesianMengPer"
></exampleRef
>.</p
><example
num="xIndonesianMengPer"
><listInterlinear
letter="xIndonesianMemperelebar"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>memperlebar</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-per-lebar</langData
></line
><line
><gloss
lang="lGloss"
>AV-CAUS-wide</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMemperoleh"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>memperoleh</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-per-oleh</langData
></line
><line
><gloss
lang="lGloss"
>AV-CAUS-by</gloss
></line
></lineGroup
></listInterlinear
></example
><p
><indexedItem
term="iPhonRuleConstrainExceptionFeature"
></indexedItem
>We can use an <indexedItem
term="iPhonRuleExceptionFeatures"
></indexedItem
>exception “feature” to handle this exception. We do the following steps:</p
><example
num="xIndonesianNExceptionsHowTo"
><chart
type="HowTo"
><ol
><li
>Create the exception “feature”. We could call it ‘Does not undergo voiceless obstruent deletion” because this is the rule that does not apply (see <exampleRef
letter="xIndonesianUnspecifedVoicelessObstruentDeletionRule"
num="xIndonesianUnspecifedVoicelessObstruentDeletionRule"
paren="final"
></exampleRef
>.</li
><li
>Create or find the <langData
lang="lBahasaIndonesia"
>per</langData
>- entry.</li
><li
>Mark it as having this exception "feature” in its list of To Exception “Features”.</li
><li
>Find the phonological rule which deletes a voiceless obstruent <exampleRef
letter="xIndonesianUnspecifedVoicelessObstruentDeletionRule"
num="xIndonesianUnspecifedVoicelessObstruentDeletionRule"
></exampleRef
> and add this exception “feature” to its list of excluded properties.</li
></ol
></chart
></example
><p
>When the <object
type="HermitCrab"
></object
> finds the <langData
lang="lBahasaIndonesia"
>per</langData
>- morpheme, it will no longer try to apply the delete voiceless obstruent rule because it will be excluded. (Please note that you will only see that this rule is not applied during the synthesis process; during analysis, the rule will still be “unapplied.”)</p
><p
>The second exception is for loan words. Consider the following words:</p
><example
num="xIndonesianmengLoanWords"
><listInterlinear
letter="xIndonesianMemproklamasikan"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>memproklamasikan</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-proklamasi-kan</langData
></line
><line
><gloss
lang="lGloss"
>AV-proclamation-CAUS</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMentraktir"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>mentraktir</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-traktir</langData
></line
><line
><gloss
lang="lGloss"
>AV-treat.someone</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMenswadayakan"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>menswadayakan</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-swadaya-kan</langData
></line
><line
><gloss
lang="lGloss"
>AV-self.supporting-CAUS</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xIndonesianMengklasifikasikan"
><lineGroup
><line
><langData
lang="lBahasaIndonesia"
>mengklasifikasikan</langData
></line
><line
><langData
lang="lBahasaIndonesiaIPA"
>məⁿ-klasifikasi-kan</langData
></line
><line
><gloss
lang="lGloss"
>AV-classification-CAUS</gloss
></line
></lineGroup
></listInterlinear
></example
><p
>The crucial thing to notice here is that in none of these does the initial consonant of the stem delete. <indexedItem
term="iPhonRuleExceptionFeatures"
></indexedItem
>To handle these, add the exception “feature” created above to each stem entry. <citation
page="12"
ref="rSneddon"
></citation
> notes that as a loan word ceases to be considered as foreign and becomes thought of as part of the native vocabulary, the expected deletion will occur. If you find that happening for some word, merely remove the exception “feature” from it and the deletion rule will then apply.</p
><p
>The third exception is for monosyllabic stems, which <citation
page="13"
ref="rSneddon"
></citation
> says are all loan words. <indexedItem
term="iPhonRuleExceptionFeatures"
></indexedItem
>These, too, can be handled via our exception “feature” by marking these stems as having this exception "feature.”<indexedRangeEnd
begin="bIndonesianNasalAssimilation"
></indexedRangeEnd
></p
></section5
></section4
></section3
><section3
id="sHCRegularRuleConstraining"
><secTitle
>Constraining application of “regular” phonological rules</secTitle
><p
><indexedRangeBegin
id="bPhonRuleConstrain"
term="iPhonRuleConstrain"
></indexedRangeBegin
>There are times when the application of a “regular” rule needs to be limited to a set of categories or to some other properties of the word.</p
><section4
id="sHCRegularRuleConstrainingCategories"
><secTitle
>Rule applies only with certain categories</secTitle
><p
><indexedItem
term="iAxinincaCampa"
></indexedItem
><indexedItem
term="iPhonRuleConstrainCategory"
></indexedItem
>Consider the following data from <citation
page="108"
ref="rAxinincaCampa"
></citation
>.</p
><example
num="xAxinincaVerbTEpenthesis"
><listInterlinear
letter="xAxinincaVerbTEpenthesisPaddle"
><lineGroup
><line
><langData
lang="lAxinincaCampa"
>iNkomataati</langData
></line
><line
><langData
lang="lAxinincaCampa"
>i-N-koma-aa-i</langData
></line
><line
><gloss
lang="lGloss"
>3PM-FUTURE-paddle-REPETITIVE-FUTURE</gloss
></line
></lineGroup
><free
>‘he will paddle again’</free
></listInterlinear
><listInterlinear
letter="xAxinincaVerbTEpenthesisCut"
><lineGroup
><line
><langData
lang="lAxinincaCampa"
>iNtʃʰikaati</langData
></line
><line
><langData
lang="lAxinincaCampa"
>i-N-tʃʰik-aa-i</langData
></line
><line
><gloss
lang="lGloss"
>3PM-FUTURE-cut-REPETITIVE-FUTURE</gloss
></line
></lineGroup
><free
>‘he will cut again’</free
></listInterlinear
></example
><p
>Notice that when two vowels occur across morpheme boundaries, an epenthetic /<langData
lang="lAxinincaCampa"
>t</langData
>/ is inserted.</p
><p
>That is not the entire story, however. Consider what happens in the data in example <exampleRef
letter="xAxinincaNoun"
num="xAxinincaNoun"
></exampleRef
> (also from <citation
page="110"
ref="rAxinincaCampa"
></citation
>):</p
><example
num="xAxinincaNoun"
><listInterlinear
letter="xAxinincaNounSpiders"
><lineGroup
><line
><langData
lang="lAxinincaCampa"
>hitoiriki</langData
></line
><line
><langData
lang="lAxinincaCampa"
>hito-iriki</langData
></line
><line
><gloss
lang="lGloss"
>spider-DIMINUTIVE</gloss
></line
></lineGroup
><free
>‘small spiders’</free
></listInterlinear
><listInterlinear
letter="xAxinincaNounRocks"
><lineGroup
><line
><langData
lang="lAxinincaCampa"
>mapiiriki</langData
></line
><line
><langData
lang="lAxinincaCampa"
>mapi-iriki</langData
></line
><line
><gloss
lang="lGloss"
>rock-DIMINUTIVE</gloss
></line
></lineGroup
><free
>‘small rocks”</free
></listInterlinear
></example
><p
>In these words, even though two vowels occur across a morpheme boundary, no epenthetic /<langData
lang="lAxinincaCampa"
>t</langData
>/ is inserted.</p
><p
>What is the difference between the data in <exampleRef
letter="xAxinincaVerbTEpenthesis"
num="xAxinincaVerbTEpenthesis"
></exampleRef
> and <exampleRef
letter="xAxinincaNoun"
num="xAxinincaNoun"
></exampleRef
>? Notice that all the forms in <exampleRef
letter="xAxinincaVerbTEpenthesis"
num="xAxinincaVerbTEpenthesis"
></exampleRef
> are verbs while the ones in <exampleRef
letter="xAxinincaNoun"
num="xAxinincaNoun"
></exampleRef
> are nouns. So if we had a way to say that the phonological rule which inserts the epenthetic /<langData
lang="lAxinincaCampa"
>t</langData
>/ only applies on verbs, then we can deal with this kind of data.</p
><p
>With the <object
type="HermitCrab"
></object
>, it is possible to constrain a phonological rule so that it will apply only when certain categories are present in the word. Like many other situations involving categories in the <object
type="WordWorks"
></object
> parsers, the category hierarchy is respected. That is, if you specify that a particular phonological rule should only apply when a particular category is present, then that rule will only apply if that category or any of its subcategories (or their subcategories) are present.</p
></section4
><section4
id="sHCRegularRuleConstrainingProperties"
><secTitle
>Rule applies only with certain properties</secTitle
><p
><indexedItem
term="iPhonRuleConstrainProperty"
></indexedItem
>The <object
type="HermitCrab"
></object
> also allows one to constrain the application of a given phonological rule by limiting its application to when specified exception “features” or inflection classes are present or are not present. If one says that this set of exception “features” and/or inflection classes are required, then every one of them must be present before the phonological rule will be applied. If one says that this set of exception “features” and/or inflection classes are excluded, then the phonological rule will be applied only if none of these are present.</p
><p
><indexedItem
term="iPhonRuleConstrainExceptionFeature"
></indexedItem
>See section <appendixRef
app="sIndonesianNasalMessLoans"
></appendixRef
> for an example of using an exception “feature” which must not be present in order for a phonological rule to apply.<indexedRangeEnd
begin="bPhonRuleConstrain"
></indexedRangeEnd
></p
></section4
></section3
><section3
id="sHCPhonMetathesis"
><secTitle
>Phonological metathesis rules</secTitle
><p
><indexedItem
term="iSelaru"
></indexedItem
><indexedItem
term="iMetathesis"
></indexedItem
>Now let's look at an example of phonological metathesis. Consider the following data from Selaru,<endnote
id="nSelaru"
><p
>The Selaru data is from David Coward, personal communication (emails of 2008/11/15, 2008/11/17, and 2009/01/12). The abbreviations used in the Selaru data are:</p
><table
border="1"
><tr
><th
>Abbreviation</th
><th
>Meaning</th
></tr
><tr
><td
>ART</td
><td
>article</td
></tr
><tr
><td
>2s</td
><td
>2nd person singular</td
></tr
></table
></endnote
> paying special attention to the position of the <indexedItem
term="iApproximant"
></indexedItem
>glides in the underlying form (second line) versus the surface form (first line).</p
><example
num="xSelaruCat"
><listInterlinear
letter="xSelaruCatBase"
><lineGroup
><line
><langData
lang="lSelaru"
>sit</langData
></line
><line
><gloss
lang="lGloss"
>cat</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xSelaruCatArticle"
><lineGroup
><line
><langData
lang="lSelaru"
>sitke</langData
></line
><line
><langData
lang="lSelaru"
>sit-ke</langData
></line
><line
><gloss
lang="lGloss"
>cat-ART</gloss
></line
></lineGroup
></listInterlinear
></example
><example
num="xSelaruChicken"
><listInterlinear
letter="xSelaruChickenBase"
><lineGroup
><line
><langData
lang="lSelaru"
>sihy</langData
></line
><line
><gloss
lang="lGloss"
>chicken</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xSelaruChickenArticle"
><lineGroup
><line
><langData
lang="lSelaru"
>sihkye</langData
></line
><line
><langData
lang="lSelaru"
>sihy-ke</langData
></line
><line
><gloss
lang="lGloss"
>chicken-ART</gloss
></line
></lineGroup
></listInterlinear
></example
><example
num="xSelaruDog"
><listInterlinear
letter="xSelaruDogBase"
><lineGroup
><line
><langData
lang="lSelaru"
>asw</langData
></line
><line
><gloss
lang="lGloss"
>dog</gloss
></line
></lineGroup
></listInterlinear
><listInterlinear
letter="xSelaruDogArticle"
><lineGroup
><line
><langData
lang="lSelaru"
>askwe</langData
></line
><line
><langData
lang="lSelaru"
>asw-ke</langData
></line
><line
><gloss
lang="lGloss"
>dog-ART</gloss
></line
></lineGroup
></listInterlinear
></example
><example
num="xSelaru2sSit"
><interlinear
><lineGroup
><line
><langData
lang="lSelaru"
>mtwaklulw</langData
></line
><line
><langData
lang="lSelaru"
>mw-taklulw</langData
></line
><line
><gloss
lang="lGloss"
>2s-sit</gloss
></line
></lineGroup
></interlinear
></example
><p
>What happens to the glides <langData
lang="lSelaru"
>w</langData
> and <langData
lang="lSelaru"
>y</langData
>? They exchange places with a following consonant whenever the consonant comes before a vowel. (More data would show that this only happens with obstruent consonants.) This kind of exchange of segments is known as metathesis.</p
><p
>How do we model this metathesis using the new <object
type="HermitCrab"
></object
>? Since this kind of a change is not possible to write using the standard rule notation of <exampleRef
letter="xRegularPhologicalRuleFormula"
num="xRegularPhologicalRuleFormula"
></exampleRef
>, we need to create a special metathesis rule. These rules can be described very much like what we saw above for affix processes (e.g. see <citation
page="371"
ref="rKenstowiczAndKisseberth1979"
></citation
>). The user interface of <object
type="WordWorks"
></object
>, however, follows a different notation that we think is clearer. It might look like this for the Selaru metathesis case:</p
><example
num="xSelaruMetathesisRule"
><table
border="1"
type="tLeftOffset"
><tr
><td
> <indexedItem
term="iPhonRuleExamples"
></indexedItem
></td
><td
align="center"
>Left environment</td
><td
align="center"
colspan="2"
>Switch these items</td
><td
align="center"
>Right environment</td
></tr
><tr
><td
align="left"
valign="middle"
>Input</td
><td
align="center"
valign="middle"
> </td
><td
align="center"
valign="middle"
><table
><tr
><td
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>[</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>?</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>consonantal</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>]</object
></td
></tr
></table
></td
></tr
></table
></td
><td
align="center"
valign="middle"
><table
><tr
><td
align="center"
valign="bottom"
>+</td
><td
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎡</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>+</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>consonantal</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎤</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎣</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>-</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>sonorant</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎦</object
></td
></tr
></table
></td
></tr
></table
></td
><td
align="center"
valign="middle"
><table
><tr
><td
valign="middle"
>V</td
></tr
></table
></td
></tr
><tr
><td
align="left"
valign="middle"
>Result</td
><td
align="center"
valign="middle"
> </td
><td
align="center"
valign="middle"
><table
><tr
><td
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎡</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>+</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>consonantal</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎤</object
></td
></tr
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎣</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>-</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>sonorant</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>⎦</object
></td
></tr
></table
></td
></tr
></table
></td
><td
align="center"
valign="middle"
><table
><tr
><td
align="center"
valign="bottom"
>+</td
><td
><table
cellpadding="1pt"
cellspacing="0pt"
><tr
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>[</object
></td
><td
align="right"
type="tFSCell"
valign="middle"
>?</td
><td
type="tFSCell"
valign="middle"
>:</td
><td
type="tFSCell"
valign="middle"
>consonantal</td
><td
type="tFSCell"
valign="middle"
><object
type="tFSBrackets"
>]</object
></td
></tr
></table
></td
></tr
></table
></td
><td
align="center"
valign="middle"
><table
><tr
><td
valign="middle"
>V</td
></tr
></table
></td
></tr
></table
></example
><p
>The row labeled <object
type="TT"
>Input</object
> indicates the pattern of the input. Glides are indicated by the <object
type="tFSBrackets"
>[</object
>? : consonantal<object
type="tFSBrackets"
>]</object
> feature.<endnote
id="nSelaruGlideAsUnspecifiedConsonantal"
><p
>In the analysis used, glides are unspecified for the consonantal feature, indicated by the question mark. If the glide occurs between consonants and ends a morpheme, then the glide becomes a vowel.</p
></endnote
> Obstruents are indicated by the combination of <object
type="tFSBrackets"
>[</object
>+ : consonantal<object
type="tFSBrackets"
>]</object
> and <object
type="tFSBrackets"
>[</object
>- : sonorant<object
type="tFSBrackets"
>]</object
> features. The following vowel is indicated by the V in the right environment. Notice how the two middle column contents are switched in the final row (the result).</p
><p
>The following table shows a phoneme-feature matrix one might use for Selaru:</p
><example
num="xSelaruPhonemeFeatureMatrix"
><table
border="1"
type="tLeftOffset"
><tr
><th
> <indexedItem
term="iPhonRulePhonemeFeatureMatrix"
></indexedItem
></th
><th
>back</th
><th
>cg</th
><th
>cons</th
><th
>cont</th
><th
>cor</th
><th
>front</th
><th
>high</th
><th
>lat</th
><th
>nas</th
><th
>rnd</th
><th
>son</th
><th
>voice</th
></tr
><tr
><th
><langData
lang="lSelaru"
>a</langData
></th
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSelaru"
>b</langData
></th
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lSelaru"
>d</langData
></th
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lSelaru"
>e</langData
></th
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSelaru"
>f</langData
></th
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lSelaru"
>h</langData
></th
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lSelaru"
>i</langData
></th
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSelaru"
>j</langData
></th
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>?</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSelaru"
>k</langData
></th
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lSelaru"
>l</langData
></th
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSelaru"
>m</langData
></th
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSelaru"
>n</langData
></th
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSelaru"
>o</langData
></th
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSelaru"
>r</langData
></th
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSelaru"
>s</langData
></th
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lSelaru"
>t</langData
></th
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lSelaru"
>u</langData
></th
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSelaru"
>w</langData
></th
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>?</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSelaru"
>ʔ</langData
></th
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-<indexedRangeEnd
begin="bPhonRules"
></indexedRangeEnd
></td
></tr
></table
></example
></section3
></section2
></section1
><section1
id="sHermitCrabTips"
><secTitle
>Tips for Making the <object
type="HermitCrab"
></object
> Work Effectively.</secTitle
><p
><indexedItem
term="iPhonRuleTips"
></indexedItem
>In my testing of the new <object
type="HermitCrab"
></object
>, I noticed several key things one should keep in mind. These are given here.</p
><section2
id="sHCTipsEveryPhonemeInOrthography"
><secTitle
>Every Phoneme Used in the Orthography Must be Defined as a Phoneme</secTitle
><p
><indexedItem
term="iPhonemes"
></indexedItem
><indexedItem
term="iPhonRulePhonemes"
></indexedItem
>The first thing to keep in mind when you use the new <object
type="HermitCrab"
></object
> is that every phoneme used in the orthography must be listed among the phonemes in your language project.<endnote
id="nXAmpleAndPhonemes"
><p
>The default <object
type="WordWorks"
></object
> parser does not require this. For the default parser, you only need to define phonemes that are used in natural classes or in environments.</p
></endnote
> If a word or an affix or a phonological rule has even just one phoneme that is not listed in the list of phonemes, then the new <object
type="HermitCrab"
></object
> is guaranteed to not give an analysis for any word whatsoever, even if that word does not contain one of the missing phonemes. This is because the new parser crucially depends on phonemes being defined. This should not be surprising, really, for a parser that is able to handle phonological rules: it simply must know what the phonemes are in order to deal with such rules.</p
></section2
><section2
id="sHCTipsUniquePhoneme"
><secTitle
>The Phonological Features Need to Uniquely Identify Each Phoneme</secTitle
><p
><indexedItem
term="iPhonRulePhonemes"
></indexedItem
>Whenever you use phonological features with the new <object
type="HermitCrab"
></object
>, it is very important that each phoneme have distinct values for its phonological features. If two or more phonemes share the exact same set of phonological feature-value pairs, then the parser may not be able to correctly determine the morphemes involved. You may want to double check that every phoneme has a unique set of feature-value pairs. One way to do this is via the “Bulk Edit Phoneme Features” tool; another is via the “Grammar Sketch.” Both of these tools are in the Grammar area.</p
></section2
><section2
id="sHCTipsFullySpecify"
><secTitle
>Fully Specify Each Phoneme</secTitle
><p
><indexedItem
term="iPhonRulePhonemes"
></indexedItem
>While some phonological theories promote feature underspecification and while some theories also consider it to be good form to minimally specify features in a phonological rule, the way the new <object
type="HermitCrab"
></object
> works, you really need to be as specific as practical. So if a rule is not working, try to be more specific about the features.</p
></section2
><section2
id="sHCTipsFearuesInRulesShouldBeExplicit"
><secTitle
>Features Used in a Rule should be Explicit</secTitle
><p
><indexedItem
term="iPhonRuleFS"
></indexedItem
>Whenever you use a phonological feature structure in a phonological rule, be sure to use as many features as necessary to correctly identify the phonemes involved. If you are not explicit enough, the parser will not be able to identify the correct phonemes and your rule may well not work as you expect.</p
><p
>For example, in working on the <indexedItem
term="iBahasaIndonesia"
></indexedItem
>Bahasa Indonesia data, I wrote a complicated rule (see <exampleRef
letter="xIndonesianUnspecifedNasalFullRedupRule"
num="xIndonesianUnspecifedNasalFullRedupRule"
></exampleRef
>) where I wanted to change certain voiceless obstruents to their co-articulated nasal. Since these particular obstruents all shared a common feature value, I thought I could just use that feature and the place feature. That did not work. I had to be sure to include all features that differ between the phonemes involved. In particular, I needed to include <object
type="TT"
>sonorant</object
>, <object
type="TT"
>voice</object
>, and <object
type="TT"
>nasal</object
> feature values.</p
><p
>The lesson here is that while we humans may easily make correct assumptions about the sound system of a language, the parser cannot.</p
></section2
><section2
id="sHCTipsPhonemeInRule"
><secTitle
>Using a Phoneme in a Rule is More Efficient</secTitle
><p
><indexedItem
term="iPhonRulePhonemes"
></indexedItem
>When you have a choice between using features and a phoneme in a rule (i.e., the rule is about the phoneme), then write the rule in terms of the phoneme instead of some of its distinctive features. This is more efficient.</p
></section2
><section2
id="sHCTipsCase"
><secTitle
>Avoid Using Archiphonemes that are Uppercase Equivalents of a Character in Your Orthography</secTitle
><p
><indexedItem
term="iPhonRuleArchiphoneme"
></indexedItem
>In testing the <indexedItem
term="iBahasaIndonesia"
></indexedItem
>Bahasa Indonesia data, I had an affix that ended with an unspecified nasal (this affix has nasal assimilation to the point of articulation of a following obstruent as explained in section <appendixRef
app="sIndonesianNasalAssimilation"
></appendixRef
>). So I wrote a phonological rule to do the assimilation. To represent this affix, I used an archiphoneme of capital N. That is, I made it have the form <langData
lang="lBahasaIndonesia"
>meN</langData
>-. I also added a new phoneme whose representation was also this archiphoneme <langData
lang="lBahasaIndonesia"
>N</langData
>. Since the language already had an alveolar nasal (<langData
lang="lBahasaIndonesia"
>n</langData
>), it turned out that the new <object
type="HermitCrab"
></object
> did not successfully apply the rule.</p
><p
>The reason is that the new <object
type="HermitCrab"
></object
> automatically treated <langData
lang="lBahasaIndonesia"
>N</langData
> as the uppercase equivalent of the alveolar nasal <langData
lang="lBahasaIndonesia"
>n</langData
>. The solution I used was to change the representation of the unspecified nasal phoneme to a superscript n (<langData
lang="lBahasaIndonesia"
>ⁿ</langData
>). So while I could continue to use the N for the name of the unspecified nasal phoneme, I did need to be careful to change the representation/grapheme and all lexical forms to use the superscript n. For example, the affix I mentioned above became <langData
lang="lBahasaIndonesia"
>meⁿ</langData
>-. Once I made these changes, the new <object
type="HermitCrab"
></object
> was able to correctly parse words containing this morpheme. Note that it is not a problem to type forms such as <langData
lang="lBahasaIndonesia"
>meN</langData
>- into the Citation Form field of an affix's entry for publication purposes, since the parser does not look at the Citation Form at all.</p
></section2
><section2
id="sHCTipsAffixProcess"
><secTitle
>Make Sure Every Affix Process Rule is Complete</secTitle
><p
><indexedItem
term="iAffixProcess"
></indexedItem
>Whenever you create an affix process rule, be sure to fill in the morph type field and also put something in the form field. If the morph type field is empty, the rule may not work. The reason for putting something in the form field is so you will not just get “???” for the shape of the morpheme.</p
></section2
><section2
id="sHCTipsNaturalClasses"
><secTitle
>Natural Classes Defined by Phonemes May Not Work as Expected</secTitle
><p
><indexedItem
term="iNaturalClass"
></indexedItem
>This one is a bit tricky and not easy to explain.</p
><p
>When you have phonological features defined and have fully and uniquely specified each phoneme, you may still run into some odd behaviors with natural classes. Consider the following set of phonemes and features:</p
><example
num="xSalarPhonemes1"
><table
border="1"
type="tLeftOffset"
><tr
><th
> </th
><th
>***</th
><th
>art</th
><th
>cont</th
><th
>cor</th
><th
>front</th
><th
>high</th
><th
>rnd</th
><th
>son</th
><th
>str</th
><th
>voice</th
></tr
><tr
><th
><langData
lang="lSalar"
>-</langData
></th
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lSalar"
>a</langData
></th
><td
align="center"
> </td
><td
align="center"
>vowel</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSalar"
>b</langData
></th
><td
align="center"
> </td
><td
align="center"
>lab</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lSalar"
>c</langData
></th
><td
align="center"
> </td
><td
align="center"
>pal</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lSalar"
>ç</langData
></th
><td
align="center"
> </td
><td
align="center"
>pal</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lSalar"
>ch</langData
></th
><td
align="center"
> </td
><td
align="center"
>ret</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lSalar"
>d</langData
></th
><td
align="center"
> </td
><td
align="center"
>alv</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lSalar"
>e</langData
></th
><td
align="center"
> </td
><td
align="center"
>vowel</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSalar"
>f</langData
></th
><td
align="center"
> </td
><td
align="center"
>lab</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lSalar"
>g</langData
></th
><td
align="center"
> </td
><td
align="center"
>vel</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lSalar"
>ğ</langData
></th
><td
align="center"
> </td
><td
align="center"
>vel</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lSalar"
>h</langData
></th
><td
align="center"
> </td
><td
align="center"
>uvu</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lSalar"
>i</langData
></th
><td
align="center"
> </td
><td
align="center"
>vowel</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSalar"
>ı</langData
></th
><td
align="center"
> </td
><td
align="center"
>vowel</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSalar"
>k</langData
></th
><td
align="center"
> </td
><td
align="center"
>vel</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lSalar"
>l</langData
></th
><td
align="center"
> </td
><td
align="center"
>alv</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lSalar"
>m</langData
></th
><td
align="center"
> </td
><td
align="center"
>lab</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lSalar"
>n</langData
></th
><td
align="center"
> </td
><td
align="center"
>alv</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lSalar"
>ñ</langData
></th
><td
align="center"
> </td
><td
align="center"
>vel</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lSalar"
>o</langData
></th
><td
align="center"
> </td
><td
align="center"
>vowel</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSalar"
>ö</langData
></th
><td
align="center"
> </td
><td
align="center"
>vowel</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSalar"
>p</langData
></th
><td
align="center"
> </td
><td
align="center"
>lab</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lSalar"
>q</langData
></th
><td
align="center"
> </td
><td
align="center"
>uvu</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSalar"
>r</langData
></th
><td
align="center"
> </td
><td
align="center"
>alv</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lSalar"
>s</langData
></th
><td
align="center"
> </td
><td
align="center"
>alv</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lSalar"
>ş</langData
></th
><td
align="center"
> </td
><td
align="center"
>pal</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lSalar"
>sh</langData
></th
><td
align="center"
> </td
><td
align="center"
>ret</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lSalar"
>t</langData
></th
><td
align="center"
> </td
><td
align="center"
>alv</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lSalar"
>u</langData
></th
><td
align="center"
> </td
><td
align="center"
>vowel</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSalar"
>ü</langData
></th
><td
align="center"
> </td
><td
align="center"
>vowel</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
> </td
></tr
><tr
><th
><langData
lang="lSalar"
>v</langData
></th
><td
align="center"
> </td
><td
align="center"
>lab</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lSalar"
>x</langData
></th
><td
align="center"
> </td
><td
align="center"
>vel</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>-</td
></tr
><tr
><th
><langData
lang="lSalar"
>y</langData
></th
><td
align="center"
> </td
><td
align="center"
>pal</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lSalar"
>z</langData
></th
><td
align="center"
> </td
><td
align="center"
>alv</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
></tr
><tr
><th
><langData
lang="lSalar"
>zh</langData
></th
><td
align="center"
> </td
><td
align="center"
>ret</td
><td
align="center"
>+</td
><td
align="center"
>+</td
><td
align="center"
>-</td
><td
align="center"
>-</td
><td
align="center"
> </td
><td
align="center"
>-</td
><td
align="center"
>+</td
><td
align="center"
>+</td
></tr
></table
></example
><p
>One would expect that while these are not fully specified, they are unique. The problem came when a consonant natural class was defined as consisting of the following phonemes:</p
><example
num="xSalarC"
><single
><langData
lang="lSalar"
>b,  c,  ç,  ch,  d,  f,  g,  ğ,  h,  k,  l,  m,  n,  ñ,  p,  q,  r,  s,  ş,  sh,  t,  v,  x,  y,  z,  zh</langData
></single
></example
><p
>and there was an affix process rule whose match portion ended in two consonants. One naturally would expect that only those phonemes defined in the consonant natural class would be considered. But this is not how the <object
type="HermitCrab"
></object
> works during its synthesis process. During synthesis, it uses only phonological features. When it was attempting to see if a sequence like <langData
lang="lSalar"
>madi</langData
> ended in two consonants, it said “yes, it does.” How did this happen? How could it think that the final <langData
lang="lSalar"
>i</langData
> was a consonant?</p
><p
>The answer is primarily related to the multi-valued nature of the art feature. Since the various phonemes that are part of the consonant natural class (see <exampleRef
letter="xSalarC"
num="xSalarC"
></exampleRef
>) have different values for the art feature, the <object
type="HermitCrab"
></object
> has to ignore this feature when considering phonological features. Looking at the feature chart in <exampleRef
letter="xSalarPhonemes1"
num="xSalarPhonemes1"
></exampleRef
> and ignoring the art column, notice that the /<langData
lang="lSalar"
>i</langData
>/ phoneme and the /<langData
lang="lSalar"
>l</langData
>/ phoneme have compatible phonological features. Because of this, the <object
type="HermitCrab"
></object
> said that the final <langData
lang="lSalar"
>i</langData
> of the base <langData
lang="lSalar"
>madi</langData
> matched the consonant natural class.</p
><p
>The solution was to add a binary feature of ±consonantal. This was + for all consonants and - for all vowels.</p
><p
>The moral of this story, then, is to make sure that the phonological feature system is such that each natural class, when defined via features, contains just the phonemes you want. Using binary features can certainly make this easier.</p
><p
>We have added warning messages about this situation in the Try-A-Word tool. The message tells you what the natural class is, what the implied phonological features are, what the predicted phonemes are and what the actual phonemes in the class are. We hope this helps you figure out how to avoid this potential problem.</p
></section2
></section1
><section1
id="sHermitCrabLimitations"
><secTitle
>Known limitations</secTitle
><p
><indexedItem
term="iPhonRuleLimitations"
></indexedItem
>There are several known limitations of the current implementation of the new <object
type="HermitCrab"
></object
>.</p
><section2
id="sHCLimitNoTrace"
><secTitle
>Seeing what steps the parser takes not fully complete</secTitle
><p
>The default parser for <object
type="WordWorks"
></object
> has a way for you to see what steps the parser took while parsing a word (see the <object
type="Tool"
>Try a Word</object
> tool). While this has been implemented for the new <object
type="HermitCrab"
></object
>, it does not yet always give you an explanation for why a certain path failed. A later version of <object
type="WordWorks"
></object
> will include this capability.</p
></section2
><section2
id="sHCLimitAffixesApplyOnlyOnce"
><secTitle
>Affixes are tried only once per word</secTitle
><p
>While the default <object
type="WordWorks"
></object
> parser will try a given affix as many times as its form is found within a single word, the new <object
type="HermitCrab"
></object
> tries a given form (or affix process) only once per word. This is normally not an issue since it is quite rare for an affix to be repeated several times within a word. There are cases, however, where this is an issue. For example, <citation
ref="rCowardAndCoward2000"
></citation
> note that in Selaru, “It is possible to reduplicate <langData
lang="lSelaru"
>/nini/</langData
>, <langData
lang="lSelaru"
>/soso/</langData
> and others basically without limit. As many as eight reduplication levels have been encountered in natural text.”</p
><p
>If you run into this limitation, a possible work-around is to add extra allomorphs for the affix involved or to add the form as a distinct lexical entry. You also, of course, have the option of just allowing the new parser to fail to parse such words.</p
></section2
><section2
id="sHCLimitNoAdHocRules"
><secTitle
>Natural classes defined by segments may or may not work as expected</secTitle
><p
><indexedItem
term="iNaturalClass"
></indexedItem
>When you define a natural class by listing the segments (as opposed to using phonological features), the new <object
type="HermitCrab"
></object
> may not treat this natural class exactly as you expect (see section <appendixRef
app="sHCTipsNaturalClasses"
></appendixRef
> for an example). If you do not have any phonological features defined, then the new parser will treat the class as consisting solely of the segments listed in the class.</p
><p
>If, on the other hand, you have defined phonological features, then the new <object
type="HermitCrab"
></object
> converts all the segments listed in the natural class into their respective feature sets. It then takes the set intersection of all those features and uses that to determine if a given segment is in that natural class. Normally, this is not an issue. In one case, however, when I was trying to deal with the recalcitrant case of the <langData
lang="lBahasaIndonesia"
>meN</langData
>- prefix in Bahasa Indonesia (see section <appendixRef
app="sIndonesianNasalAssimilation"
></appendixRef
>) where a following <langData
lang="lBahasaIndonesia"
>p</langData
>, <langData
lang="lBahasaIndonesia"
>t</langData
>, <langData
lang="lBahasaIndonesia"
>k</langData
>, or <langData
lang="lBahasaIndonesia"
>s</langData
>, deletes, I knew that I was not aware of a real natural class that would cover these segments and not also include the other voiceless obstruents that do not delete. So I tried to by-pass this by creating a segment-based natural class that just included these four segments. Since I had also defined phonological features, this approach did not work for me. I had to create a special phonological feature whose value was <object
type="TT"
>+</object
> for these four segments and <object
type="TT"
>-</object
> for all other segments.</p
><p
>We have added warning messages about this situation in the Try-A-Word tool. The message tells you what the natural class is, what the implied phonological features are, what the predicted phonemes are and what the actual phonemes in the class are. We hope this helps you figure out how to avoid this potential problem.</p
></section2
><section2
id="sHCLimitSegmentParsing"
><secTitle
>Ambiguous digraphs and multigraphs may not work as expected</secTitle
><p
><indexedItem
term="iDigraphs"
></indexedItem
>When an orthography contains ambiguous sequences for phonemes, the <object
type="HermitCrab"
></object
> may not parse the sequence the way you expect.</p
><p
>For example, suppose your orthography includes the orthographic sequences shown in example <exampleRef
letter="xAmbiguousPhonemes"
num="xAmbiguousPhonemes"
></exampleRef
>.</p
><example
num="xAmbiguousPhonemes"
><table
border="1"
><tr
><th
>Grapheme</th
><th
>Phoneme</th
></tr
><tr
><td
><langData
lang="lVernacular"
>i</langData
></td
><td
>high front vowel</td
></tr
><tr
><td
><langData
lang="lVernacular"
>u</langData
></td
><td
>high back rounded vowel</td
></tr
><tr
><td
><langData
lang="lVernacular"
>k</langData
></td
><td
>voiceless velar stop</td
></tr
><tr
><td
><langData
lang="lVernacular"
>ki</langData
></td
><td
>palatalized voiceless velar stop</td
></tr
><tr
><td
><langData
lang="lVernacular"
>ku</langData
></td
><td
>labialized voiceless velar stop</td
></tr
></table
></example
><p
>When there are a sequences like <langData
lang="lVernacular"
>kut</langData
> and <langData
lang="lVernacular"
>kuat</langData
>, what will happen? The first should find <langData
lang="lVernacular"
>k</langData
>, <langData
lang="lVernacular"
>u</langData
>, and <langData
lang="lVernacular"
>t</langData
>. The second should find <langData
lang="lVernacular"
>ku</langData
>, <langData
lang="lVernacular"
>a</langData
> and <langData
lang="lVernacular"
>t</langData
>. The problem is that currently the <object
type="HermitCrab"
></object
> determines what the phonemes are by finding the longest match first. This means whenever it finds <langData
lang="lVernacular"
>ku</langData
>, it will <object
type="Bold"
>always</object
> treat it as the <langData
lang="lVernacular"
>ku</langData
> phoneme. Thus, it thinks that <langData
lang="lVernacular"
>kut</langData
> consists of two phonemes: <langData
lang="lVernacular"
>ku</langData
> and <langData
lang="lVernacular"
>t</langData
>, which is incorrect in this orthography.</p
><p
>Unfortunately, the only currently available solution is to change the orthography to remove the ambiguity (such as using <langData
lang="lVernacular"
>kʷ</langData
> instead of <langData
lang="lVernacular"
>ku</langData
> and using <langData
lang="lVernacular"
>kʲ</langData
> instead of <langData
lang="lVernacular"
>ki</langData
>). We hope to have a solution for this in a future version of the <object
type="HermitCrab"
></object
>.</p
></section2
></section1
></appendix
><endnotes
></endnotes
><references
><refAuthor
citename="Aronoff"
name="Aronoff, Mark"
><refWork
id="rAronoff1994"
><refDate
>1994</refDate
><refTitle
>Morphology by Itself</refTitle
><book
><series
>Linguistic Inquiry Monograph Twenty-Two</series
><location
>Cambridge, Massachusetts</location
><publisher
>The MIT Press</publisher
></book
></refWork
></refAuthor
><refAuthor
citename="Austin, Kalstrom, and Hernández"
name="Austin Krumholz, Jeanne, Marjorie Kalstrom Dolson, and Miguel Hernández Ayuso"
><refWork
id="rDiccionarioPopoloca"
><refDate
>1995</refDate
><refTitle
>Diccionario poploca de San Juan Atzingo Puebla</refTitle
><book
><location
>Tucson, AZ</location
><publisher
>Instituto Lingüístico de Verano, A.C.</publisher
></book
></refWork
></refAuthor
><refAuthor
citename="Bickford"
name="Bickford, J. Albert"
><refWork
id="rBickford"
><refDate
>1998</refDate
><refTitle
>Tools for Analyzing the World's Languages</refTitle
><book
><location
>Dallas</location
><publisher
>The Summer Institute of Linguistics</publisher
></book
></refWork
></refAuthor
><refAuthor
citename="Black"
name="Black, H. Andrew"
><refWork
id="rShipiboV2"
><refDate
>1992</refDate
><refTitle
>South American Verb Second Phenomena: Evidence from Shipibo</refTitle
><article
><jTitle
>Syntax at Santa Cruz</jTitle
><jVol
>1</jVol
><jPages
>35-63</jPages
></article
></refWork
></refAuthor
><refAuthor
citename="Coward"
name="Coward, David Forrest"
><refWork
id="rCowardGrammar"
><refDate
>2005</refDate
><refTitle
>An Introduction to the Grammar of Selaru</refTitle
><ms
><institution
>SIL International</institution
></ms
></refWork
></refAuthor
><refAuthor
citename="Coward &amp; Coward"
name="Coward, David and Naomi Coward"
><refWork
id="rCowardAndCoward2000"
><refDate
>2000</refDate
><refTitle
>A phonological sketch of the Selaru language</refTitle
><collection
><collEd
plural="no"
>Charles E. Grimes</collEd
><collTitle
>Spices from the east: papers in languages of eastern Indonesia.</collTitle
><collVol
>Pacific Linguistics, 503</collVol
><collPages
>9-54</collPages
><location
>Canberra</location
><publisher
>Research School of Pacific and Asian Studies, Australian National University</publisher
></collection
></refWork
></refAuthor
><refAuthor
citename="Engel, Engel and Alvarez"
name="Engel, Ralph Mary Allhiser de Engel, and José Mateo Alvarez"
><refWork
id="rZoqueDict"
><refDate
>1987</refDate
><refTitle
>Diccionario zoque de Franciso León</refTitle
><book
><location
>México, D.F.</location
><publisher
>Instituto Lingüístico de Verano</publisher
></book
></refWork
></refAuthor
><refAuthor
citename="Gardner"
name="Gardner, Simon"
><refWork
id="rGardner"
><refDate
>1994</refDate
><refTitle
>A Problem in Boundary Morphophonemics for Computer Analysis</refTitle
><article
><jTitle
>Notes on Computing</jTitle
><jVol
>13.6</jVol
><jPages
>44-48</jPages
></article
></refWork
></refAuthor
><refAuthor
citename="Halle &amp; Clements"
name="Halle, Morris and G.N.Clements"
><refWork
id="rHalleAndClements"
><refDate
>1983</refDate
><refTitle
>Problem Book in Phonology: A Workbook for Introductory Courses in Linguistics and Modern Phonology</refTitle
><book
><location
>Cambridge, Massachusetts</location
><publisher
>Bradford</publisher
></book
></refWork
></refAuthor
><refAuthor
citename="Hockett"
name="Hockett, Charles"
><refWork
id="rHockett"
><refDate
>1954</refDate
><refTitle
>Two models of grammatical description</refTitle
><article
><jTitle
>Word</jTitle
><jVol
>10</jVol
><jPages
>210-231</jPages
></article
></refWork
></refAuthor
><refAuthor
citename="Inkelas"
name="Inkelas, Sharon"
><refWork
id="rLing115"
><refDate
>2001</refDate
><refTitle
>Derivational Morphology Handout</refTitle
><webPage
><url
>http://ist-socrates.berkeley.edu/~aclyu/ling115/handout07.pdf</url
></webPage
></refWork
></refAuthor
><refAuthor
citename="Itô"
name="Itô, Junko"
><refWork
id="rIto1989"
><refDate
>1989</refDate
><refTitle
>A prosodic theory of epenthesis</refTitle
><article
><jTitle
>Natural Language and Linguistic Theory</jTitle
><jVol
>7</jVol
><jPages
>217-259</jPages
></article
></refWork
></refAuthor
><refAuthor
citename="Kenstowicz and Kisseberth"
name="Kenstowicz, Michael and Charles Kisseberth"
><refWork
id="rKenstowiczAndKisseberth1979"
><refDate
>1979</refDate
><refTitle
>Generative Phonology: Description and Theory</refTitle
><book
><location
>Orlando, Florida</location
><publisher
>Academic Press, Inc.</publisher
></book
></refWork
></refAuthor
><refAuthor
citename="López y Newberg"
name="López L., Filemón y Ronaldo Newberg Y."
><refWork
id="rYalalagVerbBook"
><refDate
>1990</refDate
><refTitle
>La Conjugación del Verbo Zapoteco; Zapoteco de Yalálag</refTitle
><book
><location
>México, D.F</location
><publisher
>Instituto Lingüístico de Verano, A.C.</publisher
></book
></refWork
></refAuthor
><refAuthor
citename="Payne"
name="Payne, David L."
><refWork
id="rAxinincaCampa"
><refDate
>1981</refDate
><refTitle
>The Phonology and Morphology of Axininca Campa</refTitle
><book
><series
>Summer Institute of Linguistics Publications in Linguistics, 66</series
><location
>Texas</location
><publisher
>Summer Institute of Linguistics and the University of Texas at Arlington</publisher
></book
></refWork
></refAuthor
><refAuthor
citename="T.Payne"
name="Payne, Thomas E."
><refWork
id="rTPayne1997"
><refDate
>1997</refDate
><refTitle
>Describing morphosyntax: a guide for field linguists</refTitle
><book
><location
>New York</location
><publisher
>Cambridge University Press</publisher
></book
></refWork
></refAuthor
><refAuthor
citename="Pickett, Black &amp; Marcial"
name="Pickett, Velma B., Cheryl Black and Vicente Marcial Cerqueda"
><refWork
id="rIZPracticalGrammar"
><refDate
>2001</refDate
><refTitle
>Grammatica Popular del Zapoteco del Istmo</refTitle
><book
><edition
>2nd Edition</edition
><location
>Juchitán, Oaxaca, Mexico and Tucson, Arizona</location
><publisher
>Centro de Investigación y Desarrollo Binnizá A.C. and Instituto Lingüístico de Verano A.C.</publisher
></book
><url
>http://www.sil.org/mexico/zapoteca/istmo/G023a-GramaticaZapIstmo-zai.htm</url
></refWork
></refAuthor
><refAuthor
citename="Principia Cybernetica Web"
name="Principia Cybernetica Web"
><refWork
id="rOccamsRazor"
><refDate
>1997</refDate
><refTitle
>Occam's Razor</refTitle
><webPage
><url
>http://pespmc1.vub.ac.be/OCCAMRAZ.html</url
></webPage
></refWork
></refAuthor
><refAuthor
citename="Sneddon"
name="Sneddon, James Neil"
><refWork
id="rSneddon"
><refDate
>1996</refDate
><refTitle
>Indonesian: A Comprehensive Grammar</refTitle
><book
><location
>New York</location
><publisher
>Routledge</publisher
></book
></refWork
></refAuthor
><refAuthor
citename="Spencer"
name="Spencer, Andrew"
><refWork
id="rSpencer1991"
><refDate
>1991</refDate
><refTitle
>Morphological Theory</refTitle
><book
><location
>Cambridge</location
><publisher
>Basil Blackwell</publisher
></book
></refWork
></refAuthor
><refAuthor
citename="Swift"
name="Swift, Kenneth"
><refWork
id="rSwift"
><refDate
>1988</refDate
><refTitle
>Morfología del Caquinte</refTitle
><book
><series
>Serie Lingüística Peruana, No. 25</series
><location
>Yarinacocha, Péru</location
><publisher
>Instituto Lingüístico de Verano</publisher
></book
></refWork
></refAuthor
><refAuthor
citename="Tuggy"
name="Tuggy T., David"
><refWork
id="rTuggyCurso"
><refDate
>1991</refDate
><refTitle
>Curso del Nájuatl Moderno</refTitle
><book
><location
>Puebla, México</location
><publisher
>Universidad de las Américas</publisher
></book
></refWork
></refAuthor
><refAuthor
citename="Velásquez"
name="Velásquez de la Cadena, Marciano, Edward Gray, Juan L. Iriba, Ida Navarro Hinojosa, Manuel Blanco-González, and Richard John Wiezell"
><refWork
id="rVelazquezDictionary"
><refDate
>1974</refDate
><refTitle
>New Revised Velásquez Spanish and English Dictionary</refTitle
><book
><location
>Chicago</location
><publisher
>Follett Publishing Company</publisher
></book
></refWork
></refAuthor
><refAuthor
citename="Weber"
name="Weber, David John"
><refWork
id="rHuallagaQuechuaGrammar"
><refDate
>1989</refDate
><refTitle
>A Grammar of Huallaga (Huánuco) Quechua</refTitle
><book
><series
>Linguistics Volume 112</series
><location
>Berkeley</location
><publisher
>University of California Press</publisher
></book
></refWork
></refAuthor
><refAuthor
citename="Weber, Black, and McConnel"
name="Weber, David J., H. Andrew Black, and Stephen R. McConnel"
><refWork
id="rAMPLEBook"
><refDate
>1988</refDate
><refTitle
>AMPLE: A Tool for Exploring Morphology</refTitle
><book
><series
>Occasional Publications in Academic Computing No. 12</series
><location
>Dallas, Texas</location
><publisher
>Summer Institute of Linguistics</publisher
></book
></refWork
></refAuthor
><refAuthor
citename="Whitehead"
name="Whitehead, Carl R."
><refWork
id="rMenyaGrammar"
><refDate
>2004</refDate
><refTitle
>A reference grammar of Menya, an Angan language of Papua New Guinea</refTitle
><dissertation
><institution
>University of Manitoba</institution
></dissertation
><url
>http://www.sil.org/pacific/png/abstract.asp?id=44419</url
></refWork
></refAuthor
><refAuthor
citename="Yu"
name="Yu, Alan C. L."
><refWork
id="rYu2007"
><refDate
>2007</refDate
><refTitle
>A Natural History of Infixation</refTitle
><book
><location
>New York</location
><publisher
>Oxford University Press</publisher
></book
></refWork
></refAuthor
></references
><index
kind="language"
></index
><index
kind="subject"
></index
></backMatter
><languages
><language
color="blue"
font-family="Ezra SIL"
font-size="135%"
id="lAncientHebrew"
></language
><language
color="blue"
id="lAxinincaCampa"
></language
><language
color="blue"
font-family="Charis SIL"
id="lAwngi"
></language
><language
color="blue"
id="lBahasaIndonesia"
></language
><language
color="navy"
font-family="Charis SIL"
font-size="95%"
id="lBahasaIndonesiaIPA"
></language
><language
color="blue"
id="lCaquinte"
></language
><language
color="blue"
id="lEng"
></language
><language
color="green"
id="lGloss"
></language
><language
color="blue"
id="lGreek"
></language
><language
color="blue"
id="lHanunoo"
></language
><language
color="blue"
id="lIsthmus"
></language
><language
color="blue"
font-family="Courier New"
id="lKaron"
></language
><language
color="blue"
id="lLatin"
></language
><language
color="blue"
font-family="Doulos SIL"
id="lMenya"
></language
><language
color="blue"
id="lNahuatl"
></language
><language
color="blue"
id="lPopoloca"
></language
><language
color="blue"
id="lQuechua"
></language
><language
id="lReference"
></language
><language
color="blue"
id="lSalar"
></language
><language
color="blue"
id="lSelaru"
></language
><language
color="blue"
id="lSilti"
></language
><language
color="blue"
id="lShipibo"
></language
><language
color="blue"
id="lSpanish"
></language
><language
color="blue"
id="lTagalog"
></language
><language
color="blue"
id="lTobaBatak"
></language
><language
color="blue"
id="lTurka"
></language
><language
color="blue"
id="lTurkish"
></language
><language
color="blue"
id="lVernacular"
></language
><language
color="blue"
id="lWanca"
></language
><language
color="blue"
id="lYalalag"
></language
><language
color="blue"
id="lZoque"
></language
></languages
><types
><type
font-weight="bold"
id="Bold"
></type
><type
color="red"
font-family="Fixedsys"
id="category"
></type
><type
font-style="italic"
id="Definition"
></type
><type
after="experimental phonological rule-based parser"
color="navy"
id="HermitCrab"
></type
><type
cssSpecial="background-color: #fffccc;"
id="HowTo"
xsl-foSpecial="background-color=&quot;#fffccc&quot;"
></type
><type
font-weight="bold"
id="InFocus"
></type
><type
cssSpecial="margin-left:.25in;"
id="leftOffset"
></type
><type
cssSpecial="margin-top:-10pt;"
id="LessSpaceBeforeTable"
></type
><type
font-family="Fixedsys"
id="MorphemeType"
></type
><type
font-family="Fixedsys"
font-style="italic"
id="PhonRuleFormulaItem"
></type
><type
font-family="Charis SIL CompactSmallCaps"
id="SmallCaps"
></type
><type
cssSpecial="vertical-align:sub;"
font-size="65%"
id="Subscript"
xsl-foSpecial="baseline-shift='sub'"
></type
><type
cssSpecial="vertical-align:super;"
font-size="65%"
id="Superscript"
xsl-foSpecial="baseline-shift='super'"
></type
><type
font-style="italic"
id="Term"
></type
><type
color="navy"
font-family="Fixedsys"
id="Tool"
></type
><type
color="red"
font-family="Courier New"
id="TreeNT"
></type
><type
color="black"
font-family="Courier New"
id="TT"
></type
><type
cssSpecial="direction:rtl; text-align:right;"
font-family="Courier New"
id="TTRTL"
></type
><type
cssSpecial="text-decoration:underline"
id="Underscore"
xsl-foSpecial="text-decoration=&quot;underline&quot;"
></type
><type
after="FieldWorks Language Explorer"
color="navy"
font-family="Courier New"
font-size="95%"
id="WordWorks"
></type
><type
cssSpecial="margin-left: .25in;"
id="tLeftOffset"
></type
><type
color="black"
font-family="Charis SIL"
id="tFSBrackets"
></type
><type
color="black"
font-family="Charis SIL"
id="tAlphaVariable"
></type
><type
cssSpecial="padding-top:0pt; padding-bottom:0pt; "
id="tFSCell"
></type
><type
after="∅"
color="black"
font-family="Charis SIL"
id="tPhonRuleNullSet"
></type
><type
after="∞"
color="black"
font-family="Charis SIL"
id="tPhonRuleInfinity"
></type
><type
cssSpecial="padding-left:0pt; "
id="tIterationCell"
></type
></types
><indexTerms
><indexTerm
id="iAdhocConstraints"
><term
>Ad hoc constraints</term
><indexTerms
><indexTerm
id="iAdhocAllo"
><term
>Allomorph-oriented</term
></indexTerm
><indexTerm
id="iAdhocGroup"
><term
>Grouping</term
></indexTerm
><indexTerm
id="iAdhocKeyAllo"
><term
>Key Allomorph</term
></indexTerm
><indexTerm
id="iAdhocKeyMorpheme"
><term
>Key Morpheme</term
></indexTerm
><indexTerm
id="iAdhocMorph"
><term
>Morpheme-oriented</term
></indexTerm
><indexTerm
id="iAdhocOtherAllomorphs"
><term
>Other Allomorph(s)</term
></indexTerm
><indexTerm
id="iAdhocOtherMorphemes"
><term
>Other Morpheme(s)</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iAffixes"
><term
>Affixes</term
><indexTerms
><indexTerm
id="iAffixCircumfix"
see="iCircumfix"
><term
>Circumfix</term
></indexTerm
><indexTerm
id="iAffixClitics"
see="iClitic"
><term
>Clitics</term
></indexTerm
><indexTerm
id="iAffixDerivational"
see="iDerivationalAffix"
><term
>Derivational Affix</term
></indexTerm
><indexTerm
id="iAffixInflectional"
see="iInflectionalAffix"
><term
>Inflectional Affix</term
></indexTerm
><indexTerm
id="iAffixInterfix"
see="iCompInterfix"
><term
>Interfixes</term
></indexTerm
><indexTerm
id="iAffixNonproductive"
><term
>Non-productive Affix</term
></indexTerm
><indexTerm
id="iAffixProcess"
><term
>Process</term
></indexTerm
><indexTerm
id="iAffixUnclassified"
><term
>Unclassified Affix</term
></indexTerm
><indexTerm
id="iAffixUnderSpecified"
><term
>Underspecified</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iAllomorphy"
><term
>Allomorphy</term
><indexTerms
><indexTerm
id="iAffixAlloFeats"
><term
>Affix Allomorphy (conditioned by features)</term
></indexTerm
><indexTerm
id="iAlloAlternateForms"
see="iAlternateForms"
><term
>Allomorphs Field</term
></indexTerm
><indexTerm
id="iAlloEnvironments"
><term
>Environments</term
></indexTerm
><indexTerm
id="iAlloFreeFluctuation"
><term
>Free fluctuation</term
></indexTerm
><indexTerm
id="iAlloLexemeForm"
see="iLexemeForm"
><term
>Lexeme Form Field</term
></indexTerm
><indexTerm
id="iAlloNulls"
see="iNullAllomorph"
><term
>Null Allomorphs</term
></indexTerm
><indexTerm
id="iAlloOrder"
><term
>Ordering of Allomorphs</term
></indexTerm
><indexTerm
id="iAlloStemNames"
see="iStemNames"
><term
>Stem Allomorphy (Stem Names)</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iAlternateForms"
><term
>Allomorph Forms Field</term
></indexTerm
><indexTerm
id="iAmbiguity"
><term
>Ambiguity</term
></indexTerm
><indexTerm
id="iAnalyses"
><term
>Analyses</term
><indexTerms
><indexTerm
id="iAnalysesAmbiguous"
see="iAmbiguity"
><term
>Ambiguity</term
></indexTerm
><indexTerm
id="iAnalysesIncorrect"
see="iAdhocConstraints"
><term
>Eliminating Incorrect Parses</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iApproximant"
><term
>Approximant</term
></indexTerm
><indexTerm
id="iAtzingoPopoloca"
kind="language"
><term
>Atzingo Popoloca</term
></indexTerm
><indexTerm
id="iAwngi"
kind="language"
><term
>Awngi</term
></indexTerm
><indexTerm
id="iAxinincaCampa"
kind="language"
><term
>Axininca Campa</term
></indexTerm
><indexTerm
id="iBahasaIndonesia"
kind="language"
><term
>Bahasa Indonesia</term
></indexTerm
><indexTerm
id="iBoundRoot"
><term
>Bound Root</term
></indexTerm
><indexTerm
id="iBoundStem"
><term
>Bound Stem</term
></indexTerm
><indexTerm
id="iCaquinte"
kind="language"
><term
>Caquinte</term
></indexTerm
><indexTerm
id="iCategory"
><term
>Category</term
><indexTerms
><indexTerm
id="iCategoryChanging"
><term
>Changing Category</term
></indexTerm
><indexTerm
id="iCategoryHierarchy"
><term
>Category Hierarchy</term
></indexTerm
><indexTerm
id="iCategoryInflectableFeatures"
><term
>Inflectable Features</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iClass"
><term
>Class</term
><indexTerms
><indexTerm
id="iClassConjugation"
see="iConjugationClass"
><term
>Conjugation Class</term
></indexTerm
><indexTerm
id="iClassDeclension"
see="iDeclensionClass"
><term
>Declension Class</term
></indexTerm
><indexTerm
id="iClassInflection"
see="iInflectionClass"
><term
>Inflection Class</term
><indexTerms
><indexTerm
id="iClassInflectionSubclass"
see="iInflClassSublcass"
><term
>Subclass</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iClassNatural"
see="iNaturalClass"
><term
>Natural Class</term
></indexTerm
><indexTerm
id="iClassNounClass"
see="iNounClass"
><term
>Noun Class</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iCircumfix"
><term
>Circumfix</term
></indexTerm
><indexTerm
id="iClitic"
><term
>Clitic</term
><indexTerms
><indexTerm
id="iCliticEnclitic"
><term
>Enclitic</term
></indexTerm
><indexTerm
id="iCliticProclitic"
><term
>Proclitic</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iCoalescence"
><term
>Coalescence</term
></indexTerm
><indexTerm
id="iCooccurrenceConstraint"
><term
>Co-occurrence Constraints</term
></indexTerm
><indexTerm
id="iComplexFeature"
see="iInflFeatComplex"
><term
>Complex Feature</term
></indexTerm
><indexTerm
id="iCompounding"
><term
>Compounding</term
><indexTerms
><indexTerm
id="iCompInterfix"
><term
>Affixes in Middle of Compounds</term
></indexTerm
><indexTerm
id="iCompEndocentric"
see="iCompHeaded"
><term
>Endocentric Compound</term
></indexTerm
><indexTerm
id="iComopExocentric"
see="iCompNonheaded"
><term
>Exocentric Compound</term
></indexTerm
><indexTerm
id="iCompHeaded"
><term
>Headed Compound</term
></indexTerm
><indexTerm
id="iCompIncorporation"
><term
>Incorporation</term
></indexTerm
><indexTerm
id="iCompNonheaded"
><term
>Non-headed Compound</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iConjugationClass"
see="iInflectionClass"
><term
>Conjugation Class</term
></indexTerm
><indexTerm
id="iDeclensionClass"
see="iInflectionClass"
><term
>Declension Class</term
></indexTerm
><indexTerm
id="iDefaultFeature"
see="iInflFeatDefault"
><term
>Default Feature</term
></indexTerm
><indexTerm
id="iDefaultInflectionClass"
see="iInflClassDefault"
><term
>Default Inflection Class</term
></indexTerm
><indexTerm
id="iDerivation"
kind="subject"
><term
>Derivation</term
><indexTerms
><indexTerm
id="iDerivationCatChanging"
><term
>Category Changing</term
></indexTerm
><indexTerm
id="iDerivationalAffix"
><term
>Derivational Affix</term
><indexTerms
><indexTerm
id="iDerivAffixUnderspecified"
><term
>Underspecified</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iDerivationInflClass"
><term
>Inflection Classes, and</term
></indexTerm
><indexTerm
id="iDerivationInflFeature"
><term
>Inflection Features, and</term
></indexTerm
><indexTerm
id="iDerivOutsideInflection"
><term
>Outside of Inflection</term
></indexTerm
><indexTerm
id="iDerivationVsInflection"
><term
>Versus Inflection</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iDiscontinuousMorpheme"
><term
>Discontinuous Morpheme</term
></indexTerm
><indexTerm
id="iDigraphs"
><term
>Digraphs in Hermit Crab</term
></indexTerm
><indexTerm
id="iEmptySetSymbol"
><term
>Empty Set Symbol</term
></indexTerm
><indexTerm
id="iEnclitic"
see="iClitic"
><term
>Enclitic</term
></indexTerm
><indexTerm
id="iEnglish"
kind="language"
><term
>English</term
></indexTerm
><indexTerm
id="iEnvironments"
><term
>Environments</term
><indexTerms
><indexTerm
id="iEnvAllo"
see="iAlloEnvironments"
><term
>Allomorph Environments</term
></indexTerm
><indexTerm
id="iEnvAndInflClasses"
see="iInflClassEnvironments"
><term
>And Inflection Classes</term
></indexTerm
><indexTerm
id="iEnvInfix"
><term
>Infix Environments</term
></indexTerm
><indexTerm
id="iEnvReduplication"
><term
>Reduplication Environments</term
></indexTerm
><indexTerm
id="iEnvWordBoundary"
see="iWordBoundary"
><term
>Word Boundary</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iEpenthesis"
><term
>Epenthesis</term
></indexTerm
><indexTerm
id="iExceptionFeatures"
><term
>Exception Features</term
></indexTerm
><indexTerm
id="iFeatures"
see="iInflectionFeature"
><term
>Features</term
></indexTerm
><indexTerm
id="iFreeFluctuation"
see="iAlloFreeFluctuation"
><term
>Free fluctuation</term
></indexTerm
><indexTerm
id="iGender"
see="iInflectionFeature"
><term
>Gender</term
></indexTerm
><indexTerm
id="iGlide"
see="iApproximant"
><term
>Glide</term
></indexTerm
><indexTerm
id="iHermitCrabParser"
><term
>Hermit Crab Parser</term
></indexTerm
><indexTerm
id="iHuallagaQuechua"
kind="language"
><term
>Huallaga Quechua</term
></indexTerm
><indexTerm
id="iIndonesian"
kind="language"
see="iBahasaIndonesia"
><term
>Indonesian</term
></indexTerm
><indexTerm
id="iInfix"
see="iInfixation"
><term
>Infix</term
><indexTerms
><indexTerm
id="iInfixinfInterfix"
see="iInterfixes"
><term
>Infixing Interfix</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iInfixation"
><term
>Infixation</term
></indexTerm
><indexTerm
id="iInflection"
kind="subject"
><term
>Inflection</term
><indexTerms
><indexTerm
id="iInflectionalAffix"
><term
>Inflectional Affix</term
><indexTerms
><indexTerm
id="iInflAffixUnderspecified"
><term
>Underspecified</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iInflectionClass"
><term
>Inflection Class</term
><indexTerms
><indexTerm
id="iInflClassDefault"
><term
>Default Inflection Class</term
></indexTerm
><indexTerm
id="iInflClassEnvironments"
><term
>And Allomorph Environments</term
></indexTerm
><indexTerm
id="iInflClassSublcass"
><term
>Subclass</term
><indexTerms
><indexTerm
id="iInflSubClassEnvironments"
><term
>And Allomorph Environments</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iInflClassVsInflFeature"
><term
>Versus Inflection Features</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iInflectionFeature"
><term
>Inflection Feature</term
><indexTerms
><indexTerm
id="iInflFeatAgreement"
><term
>Agreement Features</term
></indexTerm
><indexTerm
id="iInflFeatAllomorphy"
><term
>And Allomorphy</term
></indexTerm
><indexTerm
id="iInflFeatDefault"
><term
>Default Features</term
></indexTerm
><indexTerm
id="iInflFeatCatalog"
><term
>Feature Catalog</term
></indexTerm
><indexTerm
id="iInflFeatComplex"
><term
>Complex Features</term
></indexTerm
><indexTerm
id="iInflFeatType"
><term
>Feature Type</term
></indexTerm
><indexTerm
id="iInflFeatRuleOutParses"
><term
>Using Features to Rule Out Incorrect Parses</term
></indexTerm
><indexTerm
id="iInflFeatVsInflClass"
><term
>Versus Inflection Class</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iInflectionalSlot"
><term
>Inflectional Slot</term
><indexTerms
><indexTerm
id="iInflSlotOptional"
><term
>Optionality</term
></indexTerm
><indexTerm
id="iInflSlotOrder"
><term
>Order</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iInflectionalTemplate"
><term
>Inflectional Template</term
></indexTerm
><indexTerm
id="iInflVsDerivation"
see="iDerivationVsInflection"
><term
>Versus Derivation</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iInterfixes"
><term
>Interfixes</term
></indexTerm
><indexTerm
id="iIrrInflForms"
><term
>Irregularly inflected forms</term
></indexTerm
><indexTerm
id="iIsthmusZapotec"
kind="language"
><term
>Isthmus Zapotec</term
></indexTerm
><indexTerm
id="iItemAndArrangement"
><term
>Item and Arrangement</term
></indexTerm
><indexTerm
id="iItemAndProcess"
><term
>Item and Process</term
></indexTerm
><indexTerm
id="iLatin"
kind="language"
><term
>Latin</term
></indexTerm
><indexTerm
id="iLexemeForm"
><term
>Lexeme Form Field</term
></indexTerm
><indexTerm
id="iMenya"
kind="language"
><term
>Menya</term
></indexTerm
><indexTerm
id="iMetathesis"
><term
>Metathesis</term
></indexTerm
><indexTerm
id="iMorphemeTypes"
><term
>Morpheme Types</term
></indexTerm
><indexTerm
id="iMorphologicalParser"
><term
>Morphological Parser</term
></indexTerm
><indexTerm
id="iMorphophonemics"
><term
>Morphophonemics</term
></indexTerm
><indexTerm
id="iMGA"
><term
>Morphosyntactic Glossing Assistant</term
></indexTerm
><indexTerm
id="iMorphotactics"
><term
>Morphotactics</term
></indexTerm
><indexTerm
id="iNaturalClass"
><term
>Natural Class</term
><indexTerms
><indexTerm
id="iNatClassAbbreviations"
><term
>Abbreviations</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iNonproductiveAffix"
see="iAffixNonproductive"
><term
>Non-productive Affix</term
></indexTerm
><indexTerm
id="iNounClass"
see="iInflectionFeature"
><term
>Noun Class</term
></indexTerm
><indexTerm
id="iNullAllomorph"
><term
>Null Allomorph</term
></indexTerm
><indexTerm
id="iOccamsRazor"
><term
>Occam's Razor</term
></indexTerm
><indexTerm
id="iAllomorphOrder"
see="iAlloOrder"
><term
>Order of Allomorphs in an Entry</term
></indexTerm
><indexTerm
id="iOrizabaNahuatl"
kind="language"
><term
>Orizaba Nahuatl</term
></indexTerm
><indexTerm
id="iParser"
see="iMorphologicalParser"
><term
>Parser</term
><indexTerms
><indexTerm
id="iHermitCrab"
><term
><genericTarget
id="gHermitCrabInIndex"
></genericTarget
>New Experimental Parser</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iParticle"
><term
>Particle</term
></indexTerm
><indexTerm
id="iPartOfSpeech"
see="iCategory"
><term
>Part of Speech</term
></indexTerm
><indexTerm
id="iPerformanceSupport"
><term
>Performance Support</term
></indexTerm
><indexTerm
id="iPhonemes"
><term
>Phonemes</term
><indexTerms
><indexTerm
id="iPhonemeClasses"
see="iNaturalClass"
><term
>Classes</term
></indexTerm
><indexTerm
id="iPhonemeRepresentation"
><term
>Representation</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iPhonologicalRules"
><term
>Phonological Rules</term
><indexTerms
><indexTerm
id="iPhonRuleAlphaVariables"
><term
>Alpha Variables</term
></indexTerm
><indexTerm
id="iPhonRuleArchiphoneme"
><term
>Archiphonemes and</term
></indexTerm
><indexTerm
id="iPhonRuleAssimilation"
><term
>Assimilation</term
></indexTerm
><indexTerm
id="iPhonRuleConstrain"
><term
>Constraining</term
><indexTerms
><indexTerm
id="iPhonRuleConstrainCategory"
><term
>Constrain by Category</term
></indexTerm
><indexTerm
id="iPhonRuleConstrainExceptionFeature"
><term
>Constrain by Exception “Feature”</term
></indexTerm
><indexTerm
id="iPhonRuleConstrainProperty"
><term
>Constrain by Property</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iPhonRuleDeletion"
><term
>Deletion Rule</term
></indexTerm
><indexTerm
id="iPhonRuleExamples"
><term
>Examples</term
></indexTerm
><indexTerm
id="iPhonRuleExceptionFeatures"
><term
>Exception “Features” in</term
></indexTerm
><indexTerm
id="iPhonRuleFS"
><term
>Feature Structures in</term
></indexTerm
><indexTerm
id="iPhonRuleGenerative"
><term
>Generative approach</term
></indexTerm
><indexTerm
id="iPhonRuleIteration"
><term
>Iteration in Rule</term
></indexTerm
><indexTerm
id="iPhonRuleLimitations"
><term
>Limitations</term
></indexTerm
><indexTerm
id="iPhonRulePhonemes"
><term
>Phonemes and</term
></indexTerm
><indexTerm
id="iPhonRulePhonemeFeatureMatrix"
><term
>Phoneme-Feature Matrix Examples</term
></indexTerm
><indexTerm
id="iPhonRuleRuleFormula"
><term
>Rule Formula</term
></indexTerm
><indexTerm
id="iPhonRuleRuleOrdering"
><term
>Rule Ordering</term
></indexTerm
><indexTerm
id="iPhonRuleTips"
><term
>Tips in using</term
></indexTerm
><indexTerm
id="iPhonRuleTone"
><term
>Tone</term
></indexTerm
><indexTerm
id="iPhonRuleTryParser"
><term
>Trying the <object
type="HermitCrab"
></object
></term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iPhrase"
><term
>Phrase</term
></indexTerm
><indexTerm
id="iPopoloca"
kind="language"
see="iAtzingoPopoloca"
><term
>Popoloca</term
></indexTerm
><indexTerm
id="iPrefix"
><term
>Prefix</term
><indexTerms
><indexTerm
id="iPrefixInterfix"
see="iInterfixes"
><term
>Prefixing Interfix</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iProclitic"
see="iClitic"
><term
>Proclitic</term
></indexTerm
><indexTerm
id="iPronominalHierarchy"
><term
>Pronominal Hierarchy</term
></indexTerm
><indexTerm
id="iQuechua"
kind="language"
><term
>Quechua</term
><indexTerms
><indexTerm
id="iQuechuaHuallaga"
kind="language"
see="iHuallagaQuechua"
><term
>Huallaga Quechua</term
></indexTerm
><indexTerm
id="iQuechuaWanca"
kind="language"
see="iWancaQuechua"
><term
>Wanca Quechua</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iReduplication"
><term
>Reduplication</term
><indexTerms
><indexTerm
id="iRedupFull"
><term
>Full Reduplication</term
></indexTerm
><indexTerm
id="iRedupPartial"
><term
>Partial Reduplication</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iRoot"
><term
>Root</term
></indexTerm
><indexTerm
id="iRootAndPatternMorphology"
><term
>Root and Pattern Morphology</term
></indexTerm
><indexTerm
id="iRootVariant"
see="iStemNames"
><term
>Root Variant</term
></indexTerm
><indexTerm
id="iSegments"
see="iPhonemes"
><term
>Segments</term
></indexTerm
><indexTerm
id="iSelaru"
kind="language"
><term
>Selaru</term
></indexTerm
><indexTerm
id="iSemitic"
kind="language"
><term
>Semitic</term
></indexTerm
><indexTerm
id="iShipibo"
kind="language"
><term
>Shipibo</term
></indexTerm
><indexTerm
id="iSilti"
kind="language"
><term
>Silt'i</term
></indexTerm
><indexTerm
id="iSlot"
see="iInflectionalSlot"
><term
>Slot</term
></indexTerm
><indexTerm
id="iSpanish"
kind="language"
><term
>Spanish</term
></indexTerm
><indexTerm
id="iStages"
><term
>Stages of the <object
type="WordWorks"
></object
> parser.</term
><indexTerms
><indexTerm
id="iStage1"
><term
>Stage 1</term
></indexTerm
><indexTerm
id="iStage2"
><term
>Stage 2</term
></indexTerm
><indexTerm
id="iStage3"
><term
>Stage 3</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iStem"
><term
>Stem</term
></indexTerm
><indexTerm
id="iStemAllomorph"
see="iStemNames"
><term
>Stem Allomorph</term
></indexTerm
><indexTerm
id="iStemNames"
><term
>Stem Names</term
></indexTerm
><indexTerm
id="iStemVariant"
see="iStemNames"
><term
>Stem Variant</term
></indexTerm
><indexTerm
id="iSubclass"
see="iInflClassSublcass"
><term
>Subclass</term
></indexTerm
><indexTerm
id="iSuffix"
><term
>Suffix</term
><indexTerms
><indexTerm
id="iSuffixInterfix"
see="iInterfixes"
><term
>Suffixing Interfix</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iSyllable"
><term
>Syllable</term
></indexTerm
><indexTerm
id="iTagalog"
kind="language"
><term
>Tagalog</term
></indexTerm
><indexTerm
id="iTemplate"
see="iInflectionalTemplate"
><term
>Template</term
></indexTerm
><indexTerm
id="iTobaBatak"
kind="language"
><term
>Toba Batak</term
></indexTerm
><indexTerm
id="iTone"
see="iPhonRuleTone"
><term
>Tone</term
></indexTerm
><indexTerm
id="iTurka"
kind="language"
><term
>Turka</term
></indexTerm
><indexTerm
id="iTurkish"
kind="language"
><term
>Turkish</term
></indexTerm
><indexTerm
id="iVowelCoalesence"
see="iCoalescence"
><term
>Vowel Coalescence</term
></indexTerm
><indexTerm
id="iWancaQuechua"
kind="language"
><term
>Wanca Quechua</term
></indexTerm
><indexTerm
id="iWordBoundary"
><term
>Word Boundary</term
></indexTerm
><indexTerm
id="iXAmple"
><term
>XAmple</term
></indexTerm
><indexTerm
id="iXeroxParser"
><term
>Xerox Parser</term
></indexTerm
><indexTerm
id="iYalalagZapotec"
kind="language"
><term
>Yalálag Zapotec</term
></indexTerm
><indexTerm
id="iZapotec"
kind="language"
><term
>Zapotec</term
><indexTerms
><indexTerm
id="iZapotecIsthmus"
kind="language"
see="iIsthmusZapotec"
><term
>Isthmus</term
></indexTerm
><indexTerm
id="iZapotecYalalag"
kind="language"
see="iYalalagZapotec"
><term
>Yalálag</term
></indexTerm
></indexTerms
></indexTerm
><indexTerm
id="iZeroAllomorph"
see="iNullAllomorph"
><term
>Zero Allomorph</term
></indexTerm
></indexTerms
></lingPaper
>
